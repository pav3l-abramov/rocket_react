{"ast":null,"code":"import { drawing as draw, geometry as geom } from '@progress/kendo-drawing';\nimport ChartElement from './chart-element';\nimport TextBox from './text-box';\nimport AxisLabel from './axis-label';\nimport Note from './note';\nimport Box from './box';\nimport { ChartService } from '../services';\nimport createAxisTick from './utils/create-axis-tick';\nimport createAxisGridLine from './utils/create-axis-grid-line';\nimport { NONE, BLACK, CENTER, TOP, BOTTOM, LEFT, RIGHT, OUTSIDE, X, Y, WIDTH, HEIGHT } from '../common/constants';\nimport { alignPathToPixel, deepExtend, getTemplate, grep, defined, isObject, inArray, limitValue, round, setDefaultOptions } from '../common';\nvar Axis = function (ChartElement) {\n  function Axis(options, chartService) {\n    if (chartService === void 0) chartService = new ChartService();\n    ChartElement.call(this, options);\n    this.chartService = chartService;\n    if (!this.options.visible) {\n      this.options = deepExtend({}, this.options, {\n        labels: {\n          visible: false\n        },\n        line: {\n          visible: false\n        },\n        margin: 0,\n        majorTickSize: 0,\n        minorTickSize: 0\n      });\n    }\n    this.options.minorTicks = deepExtend({}, {\n      color: this.options.line.color,\n      width: this.options.line.width,\n      visible: this.options.minorTickType !== NONE\n    }, this.options.minorTicks, {\n      size: this.options.minorTickSize,\n      align: this.options.minorTickType\n    });\n    this.options.majorTicks = deepExtend({}, {\n      color: this.options.line.color,\n      width: this.options.line.width,\n      visible: this.options.majorTickType !== NONE\n    }, this.options.majorTicks, {\n      size: this.options.majorTickSize,\n      align: this.options.majorTickType\n    });\n    this.initFields();\n    if (!this.options._deferLabels) {\n      this.createLabels();\n    }\n    this.createTitle();\n    this.createNotes();\n  }\n  if (ChartElement) Axis.__proto__ = ChartElement;\n  Axis.prototype = Object.create(ChartElement && ChartElement.prototype);\n  Axis.prototype.constructor = Axis;\n  Axis.prototype.initFields = function initFields() {};\n\n  // abstract labelsCount(): Number\n  // abstract createAxisLabel(index, options): AxisLabel\n\n  Axis.prototype.labelsRange = function labelsRange() {\n    return {\n      min: this.options.labels.skip,\n      max: this.labelsCount()\n    };\n  };\n  Axis.prototype.normalizeLabelRotation = function normalizeLabelRotation(labelOptions) {\n    var rotation = labelOptions.rotation;\n    if (isObject(rotation)) {\n      labelOptions.alignRotation = rotation.align;\n      labelOptions.rotation = rotation.angle;\n    }\n  };\n  Axis.prototype.createLabels = function createLabels() {\n    var this$1 = this;\n    var options = this.options;\n    var align = options.vertical ? RIGHT : CENTER;\n    var labelOptions = deepExtend({}, options.labels, {\n      align: align,\n      zIndex: options.zIndex\n    });\n    var step = Math.max(1, labelOptions.step);\n    this.clearLabels();\n    if (labelOptions.visible) {\n      this.normalizeLabelRotation(labelOptions);\n      if (labelOptions.rotation === \"auto\") {\n        labelOptions.rotation = 0;\n        options.autoRotateLabels = true;\n      }\n      var range = this.labelsRange();\n      for (var idx = range.min; idx < range.max; idx += step) {\n        var labelContext = {\n          index: idx,\n          count: range.max\n        };\n        var label = this$1.createAxisLabel(idx, labelOptions, labelContext);\n        if (label) {\n          this$1.append(label);\n          this$1.labels.push(label);\n        }\n      }\n    }\n  };\n  Axis.prototype.clearLabels = function clearLabels() {\n    this.children = grep(this.children, function (child) {\n      return !(child instanceof AxisLabel);\n    });\n    this.labels = [];\n  };\n  Axis.prototype.clearTitle = function clearTitle() {\n    var this$1 = this;\n    if (this.title) {\n      this.children = grep(this.children, function (child) {\n        return child !== this$1.title;\n      });\n      this.title = undefined;\n    }\n  };\n  Axis.prototype.clear = function clear() {\n    this.clearLabels();\n    this.clearTitle();\n  };\n  Axis.prototype.lineBox = function lineBox() {\n    var ref = this;\n    var options = ref.options;\n    var box = ref.box;\n    var vertical = options.vertical;\n    var mirror = options.labels.mirror;\n    var axisX = mirror ? box.x1 : box.x2;\n    var axisY = mirror ? box.y2 : box.y1;\n    var lineWidth = options.line.width || 0;\n    return vertical ? new Box(axisX, box.y1, axisX, box.y2 - lineWidth) : new Box(box.x1, axisY, box.x2 - lineWidth, axisY);\n  };\n  Axis.prototype.createTitle = function createTitle() {\n    var options = this.options;\n    var titleOptions = deepExtend({\n      rotation: options.vertical ? -90 : 0,\n      text: \"\",\n      zIndex: 1,\n      visualSize: true\n    }, options.title);\n    if (titleOptions.visible && titleOptions.text) {\n      var title = new TextBox(titleOptions.text, titleOptions);\n      this.append(title);\n      this.title = title;\n    }\n  };\n  Axis.prototype.createNotes = function createNotes() {\n    var this$1 = this;\n    var options = this.options;\n    var notes = options.notes;\n    var items = notes.data || [];\n    this.notes = [];\n    for (var i = 0; i < items.length; i++) {\n      var item = deepExtend({}, notes, items[i]);\n      item.value = this$1.parseNoteValue(item.value);\n      var note = new Note({\n        value: item.value,\n        text: item.label.text,\n        dataItem: item\n      }, item, this$1.chartService);\n      if (note.options.visible) {\n        if (defined(note.options.position)) {\n          if (options.vertical && !inArray(note.options.position, [LEFT, RIGHT])) {\n            note.options.position = options.reverse ? LEFT : RIGHT;\n          } else if (!options.vertical && !inArray(note.options.position, [TOP, BOTTOM])) {\n            note.options.position = options.reverse ? BOTTOM : TOP;\n          }\n        } else {\n          if (options.vertical) {\n            note.options.position = options.reverse ? LEFT : RIGHT;\n          } else {\n            note.options.position = options.reverse ? BOTTOM : TOP;\n          }\n        }\n        this$1.append(note);\n        this$1.notes.push(note);\n      }\n    }\n  };\n  Axis.prototype.parseNoteValue = function parseNoteValue(value) {\n    return value;\n  };\n  Axis.prototype.renderVisual = function renderVisual() {\n    ChartElement.prototype.renderVisual.call(this);\n    this.createPlotBands();\n  };\n  Axis.prototype.createVisual = function createVisual() {\n    ChartElement.prototype.createVisual.call(this);\n    this.createBackground();\n    this.createLine();\n  };\n  Axis.prototype.gridLinesVisual = function gridLinesVisual() {\n    var gridLines = this._gridLines;\n    if (!gridLines) {\n      gridLines = this._gridLines = new draw.Group({\n        zIndex: -2\n      });\n      this.appendVisual(this._gridLines);\n    }\n    return gridLines;\n  };\n  Axis.prototype.createTicks = function createTicks(lineGroup) {\n    var options = this.options;\n    var lineBox = this.lineBox();\n    var mirror = options.labels.mirror;\n    var majorUnit = options.majorTicks.visible ? options.majorUnit : 0;\n    var tickLineOptions = {\n      // TODO\n      // _alignLines: options._alignLines,\n      vertical: options.vertical\n    };\n    function render(tickPositions, tickOptions, skipUnit) {\n      var count = tickPositions.length;\n      var step = Math.max(1, tickOptions.step);\n      if (tickOptions.visible) {\n        for (var i = tickOptions.skip; i < count; i += step) {\n          if (defined(skipUnit) && i % skipUnit === 0) {\n            continue;\n          }\n          tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\n          tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\n          tickLineOptions.position = tickPositions[i];\n          lineGroup.append(createAxisTick(tickLineOptions, tickOptions));\n        }\n      }\n    }\n    render(this.getMajorTickPositions(), options.majorTicks);\n    render(this.getMinorTickPositions(), options.minorTicks, majorUnit / options.minorUnit);\n  };\n  Axis.prototype.createLine = function createLine() {\n    var options = this.options;\n    var line = options.line;\n    var lineBox = this.lineBox();\n    if (line.width > 0 && line.visible) {\n      var path = new draw.Path({\n        stroke: {\n          width: line.width,\n          color: line.color,\n          dashType: line.dashType\n        }\n\n        /* TODO\n        zIndex: line.zIndex,\n        */\n      });\n\n      path.moveTo(lineBox.x1, lineBox.y1).lineTo(lineBox.x2, lineBox.y2);\n      if (options._alignLines) {\n        alignPathToPixel(path);\n      }\n      var group = this._lineGroup = new draw.Group();\n      group.append(path);\n      this.visual.append(group);\n      this.createTicks(group);\n    }\n  };\n  Axis.prototype.getActualTickSize = function getActualTickSize() {\n    var options = this.options;\n    var tickSize = 0;\n    if (options.majorTicks.visible && options.minorTicks.visible) {\n      tickSize = Math.max(options.majorTicks.size, options.minorTicks.size);\n    } else if (options.majorTicks.visible) {\n      tickSize = options.majorTicks.size;\n    } else if (options.minorTicks.visible) {\n      tickSize = options.minorTicks.size;\n    }\n    return tickSize;\n  };\n  Axis.prototype.createBackground = function createBackground() {\n    var ref = this;\n    var options = ref.options;\n    var box = ref.box;\n    var background = options.background;\n    if (background) {\n      this._backgroundPath = draw.Path.fromRect(box.toRect(), {\n        fill: {\n          color: background\n        },\n        stroke: null\n      });\n      this.visual.append(this._backgroundPath);\n    }\n  };\n  Axis.prototype.createPlotBands = function createPlotBands() {\n    var this$1 = this;\n    var options = this.options;\n    var plotBands = options.plotBands || [];\n    var vertical = options.vertical;\n    var plotArea = this.plotArea;\n    if (plotBands.length === 0) {\n      return;\n    }\n    var group = this._plotbandGroup = new draw.Group({\n      zIndex: -1\n    });\n    var altAxis = grep(this.pane.axes, function (axis) {\n      return axis.options.vertical !== this$1.options.vertical;\n    })[0];\n    for (var idx = 0; idx < plotBands.length; idx++) {\n      var item = plotBands[idx];\n      var slotX = void 0,\n        slotY = void 0;\n      var labelOptions = item.label;\n      var label = void 0;\n      if (vertical) {\n        slotX = (altAxis || plotArea.axisX).lineBox();\n        slotY = this$1.getSlot(item.from, item.to, true);\n      } else {\n        slotX = this$1.getSlot(item.from, item.to, true);\n        slotY = (altAxis || plotArea.axisY).lineBox();\n      }\n      if (labelOptions) {\n        labelOptions.vAlign = labelOptions.position || LEFT;\n        label = this$1.createPlotBandLabel(labelOptions, item, new Box(slotX.x1, slotY.y1, slotX.x2, slotY.y2));\n      }\n      if (slotX.width() !== 0 && slotY.height() !== 0) {\n        var bandRect = new geom.Rect([slotX.x1, slotY.y1], [slotX.width(), slotY.height()]);\n        var path = draw.Path.fromRect(bandRect, {\n          fill: {\n            color: item.color,\n            opacity: item.opacity\n          },\n          stroke: null\n        });\n        group.append(path);\n        if (label) {\n          group.append(label);\n        }\n      }\n    }\n    this.appendVisual(group);\n  };\n  Axis.prototype.createPlotBandLabel = function createPlotBandLabel(label, item, box) {\n    if (label.visible === false) {\n      return null;\n    }\n    var text = label.text;\n    var textbox;\n    if (defined(label) && label.visible) {\n      var labelTemplate = getTemplate(label);\n      if (labelTemplate) {\n        text = labelTemplate({\n          text: text,\n          item: item\n        });\n      } else if (label.format) {\n        text = this.chartService.format.auto(label.format, text);\n      }\n      if (!label.color) {\n        label.color = this.options.labels.color;\n      }\n    }\n    textbox = new TextBox(text, label);\n    textbox.reflow(box);\n    textbox.renderVisual();\n    return textbox.visual;\n  };\n  Axis.prototype.createGridLines = function createGridLines(altAxis) {\n    var options = this.options;\n    var minorGridLines = options.minorGridLines;\n    var majorGridLines = options.majorGridLines;\n    var minorUnit = options.minorUnit;\n    var vertical = options.vertical;\n    var axisLineVisible = altAxis.options.line.visible;\n    var majorUnit = majorGridLines.visible ? options.majorUnit : 0;\n    var lineBox = altAxis.lineBox();\n    var linePos = lineBox[vertical ? \"y1\" : \"x1\"];\n    var lineOptions = {\n      lineStart: lineBox[vertical ? \"x1\" : \"y1\"],\n      lineEnd: lineBox[vertical ? \"x2\" : \"y2\"],\n      vertical: vertical\n    };\n    var majorTicks = [];\n    var container = this.gridLinesVisual();\n    function render(tickPositions, gridLine, skipUnit) {\n      var count = tickPositions.length;\n      var step = Math.max(1, gridLine.step);\n      if (gridLine.visible) {\n        for (var i = gridLine.skip; i < count; i += step) {\n          var pos = round(tickPositions[i]);\n          if (!inArray(pos, majorTicks)) {\n            if (i % skipUnit !== 0 && (!axisLineVisible || linePos !== pos)) {\n              lineOptions.position = pos;\n              container.append(createAxisGridLine(lineOptions, gridLine));\n              majorTicks.push(pos);\n            }\n          }\n        }\n      }\n    }\n    render(this.getMajorTickPositions(), majorGridLines);\n    render(this.getMinorTickPositions(), minorGridLines, majorUnit / minorUnit);\n    return container.children;\n  };\n  Axis.prototype.reflow = function reflow(box) {\n    var ref = this;\n    var options = ref.options;\n    var labels = ref.labels;\n    var title = ref.title;\n    var vertical = options.vertical;\n    var count = labels.length;\n    var sizeFn = vertical ? WIDTH : HEIGHT;\n    var titleSize = title ? title.box[sizeFn]() : 0;\n    var space = this.getActualTickSize() + options.margin + titleSize;\n    var rootBox = (this.getRoot() || {}).box || box;\n    var boxSize = rootBox[sizeFn]();\n    var maxLabelSize = 0;\n    for (var i = 0; i < count; i++) {\n      var labelSize = labels[i].box[sizeFn]();\n      if (labelSize + space <= boxSize) {\n        maxLabelSize = Math.max(maxLabelSize, labelSize);\n      }\n    }\n    if (vertical) {\n      this.box = new Box(box.x1, box.y1, box.x1 + maxLabelSize + space, box.y2);\n    } else {\n      this.box = new Box(box.x1, box.y1, box.x2, box.y1 + maxLabelSize + space);\n    }\n    this.arrangeTitle();\n    this.arrangeLabels();\n    this.arrangeNotes();\n  };\n  Axis.prototype.getLabelsTickPositions = function getLabelsTickPositions() {\n    return this.getMajorTickPositions();\n  };\n  Axis.prototype.labelTickIndex = function labelTickIndex(label) {\n    return label.index;\n  };\n  Axis.prototype.arrangeLabels = function arrangeLabels() {\n    var this$1 = this;\n    var ref = this;\n    var options = ref.options;\n    var labels = ref.labels;\n    var labelsBetweenTicks = this.labelsBetweenTicks();\n    var vertical = options.vertical;\n    var mirror = options.labels.mirror;\n    var tickPositions = this.getLabelsTickPositions();\n    for (var idx = 0; idx < labels.length; idx++) {\n      var label = labels[idx];\n      var tickIx = this$1.labelTickIndex(label);\n      var labelSize = vertical ? label.box.height() : label.box.width();\n      var firstTickPosition = tickPositions[tickIx];\n      var nextTickPosition = tickPositions[tickIx + 1];\n      var positionStart = void 0,\n        positionEnd = void 0;\n      if (vertical) {\n        if (labelsBetweenTicks) {\n          var middle = firstTickPosition + (nextTickPosition - firstTickPosition) / 2;\n          positionStart = middle - labelSize / 2;\n        } else {\n          positionStart = firstTickPosition - labelSize / 2;\n        }\n        positionEnd = positionStart;\n      } else {\n        if (labelsBetweenTicks) {\n          positionStart = firstTickPosition;\n          positionEnd = nextTickPosition;\n        } else {\n          positionStart = firstTickPosition - labelSize / 2;\n          positionEnd = positionStart + labelSize;\n        }\n      }\n      this$1.positionLabel(label, mirror, positionStart, positionEnd);\n    }\n  };\n  Axis.prototype.positionLabel = function positionLabel(label, mirror, positionStart, positionEnd) {\n    if (positionEnd === void 0) positionEnd = positionStart;\n    var options = this.options;\n    var vertical = options.vertical;\n    var lineBox = this.lineBox();\n    var labelOffset = this.getActualTickSize() + options.margin;\n    var labelBox;\n    if (vertical) {\n      var labelX = lineBox.x2;\n      if (mirror) {\n        labelX += labelOffset;\n        label.options.rotationOrigin = LEFT;\n      } else {\n        labelX -= labelOffset + label.box.width();\n        label.options.rotationOrigin = RIGHT;\n      }\n      labelBox = label.box.move(labelX, positionStart);\n    } else {\n      var labelY = lineBox.y1;\n      if (mirror) {\n        labelY -= labelOffset + label.box.height();\n        label.options.rotationOrigin = BOTTOM;\n      } else {\n        labelY += labelOffset;\n        label.options.rotationOrigin = TOP;\n      }\n      labelBox = new Box(positionStart, labelY, positionEnd, labelY + label.box.height());\n    }\n    label.reflow(labelBox);\n  };\n  Axis.prototype.autoRotateLabelAngle = function autoRotateLabelAngle(labelBox, slotWidth) {\n    if (labelBox.width() < slotWidth) {\n      return 0;\n    }\n    if (labelBox.height() > slotWidth) {\n      return -90;\n    }\n    return -45;\n  };\n  Axis.prototype.autoRotateLabels = function autoRotateLabels() {\n    var this$1 = this;\n    if (!this.options.autoRotateLabels || this.options.vertical) {\n      return false;\n    }\n    var tickPositions = this.getMajorTickPositions();\n    var labels = this.labels;\n    var limit = Math.min(labels.length, tickPositions.length - 1);\n    var angle = 0;\n    for (var idx = 0; idx < limit; idx++) {\n      var width = Math.abs(tickPositions[idx + 1] - tickPositions[idx]);\n      var labelBox = labels[idx].box;\n      var labelAngle = this$1.autoRotateLabelAngle(labelBox, width);\n      if (labelAngle !== 0) {\n        angle = labelAngle;\n      }\n      if (angle === -90) {\n        break;\n      }\n    }\n    if (angle !== 0) {\n      for (var idx$1 = 0; idx$1 < labels.length; idx$1++) {\n        labels[idx$1].options.rotation = angle;\n        labels[idx$1].reflow(new Box());\n      }\n      return true;\n    }\n  };\n  Axis.prototype.arrangeTitle = function arrangeTitle() {\n    var ref = this;\n    var options = ref.options;\n    var title = ref.title;\n    var mirror = options.labels.mirror;\n    var vertical = options.vertical;\n    if (title) {\n      if (vertical) {\n        title.options.align = mirror ? RIGHT : LEFT;\n        title.options.vAlign = title.options.position;\n      } else {\n        title.options.align = title.options.position;\n        title.options.vAlign = mirror ? TOP : BOTTOM;\n      }\n      title.reflow(this.box);\n    }\n  };\n  Axis.prototype.arrangeNotes = function arrangeNotes() {\n    var this$1 = this;\n    for (var idx = 0; idx < this.notes.length; idx++) {\n      var item = this$1.notes[idx];\n      var value = item.options.value;\n      var slot = void 0;\n      if (defined(value)) {\n        if (this$1.shouldRenderNote(value)) {\n          item.show();\n        } else {\n          item.hide();\n        }\n        slot = this$1.noteSlot(value);\n      } else {\n        item.hide();\n      }\n      item.reflow(slot || this$1.lineBox());\n    }\n  };\n  Axis.prototype.noteSlot = function noteSlot(value) {\n    return this.getSlot(value);\n  };\n  Axis.prototype.alignTo = function alignTo(secondAxis) {\n    var lineBox = secondAxis.lineBox();\n    var vertical = this.options.vertical;\n    var pos = vertical ? Y : X;\n    this.box.snapTo(lineBox, pos);\n    if (vertical) {\n      this.box.shrink(0, this.lineBox().height() - lineBox.height());\n    } else {\n      this.box.shrink(this.lineBox().width() - lineBox.width(), 0);\n    }\n    this.box[pos + 1] -= this.lineBox()[pos + 1] - lineBox[pos + 1];\n    this.box[pos + 2] -= this.lineBox()[pos + 2] - lineBox[pos + 2];\n  };\n  Axis.prototype.axisLabelText = function axisLabelText(value, options, context) {\n    var this$1 = this;\n    var text;\n    var tmpl = getTemplate(options);\n    var defaultText = function () {\n      if (!options.format) {\n        return value;\n      }\n      return this$1.chartService.format.localeAuto(options.format, [value], options.culture);\n    };\n    if (tmpl) {\n      var templateContext = Object.assign({}, context, {\n        get text() {\n          return defaultText();\n        },\n        value: value,\n        format: options.format,\n        culture: options.culture\n      });\n      text = tmpl(templateContext);\n    } else {\n      text = defaultText();\n    }\n    return text;\n  };\n  Axis.prototype.slot = function slot(from, to, limit) {\n    var slot = this.getSlot(from, to, limit);\n    if (slot) {\n      return slot.toRect();\n    }\n  };\n  Axis.prototype.contentBox = function contentBox() {\n    var box = this.box.clone();\n    var labels = this.labels;\n    if (labels.length) {\n      var axis = this.options.vertical ? Y : X;\n      if (this.chartService.isPannable(axis)) {\n        var offset = this.maxLabelOffset();\n        box[axis + 1] -= offset.start;\n        box[axis + 2] += offset.end;\n      } else {\n        if (labels[0].options.visible) {\n          box.wrap(labels[0].box);\n        }\n        var lastLabel = labels[labels.length - 1];\n        if (lastLabel.options.visible) {\n          box.wrap(lastLabel.box);\n        }\n      }\n    }\n    return box;\n  };\n  Axis.prototype.maxLabelOffset = function maxLabelOffset() {\n    var this$1 = this;\n    var ref = this.options;\n    var vertical = ref.vertical;\n    var reverse = ref.reverse;\n    var labelsBetweenTicks = this.labelsBetweenTicks();\n    var tickPositions = this.getLabelsTickPositions();\n    var offsetField = vertical ? Y : X;\n    var labels = this.labels;\n    var startPosition = reverse ? 1 : 0;\n    var endPosition = reverse ? 0 : 1;\n    var maxStartOffset = 0;\n    var maxEndOffset = 0;\n    for (var idx = 0; idx < labels.length; idx++) {\n      var label = labels[idx];\n      var tickIx = this$1.labelTickIndex(label);\n      var startTick = void 0,\n        endTick = void 0;\n      if (labelsBetweenTicks) {\n        startTick = tickPositions[tickIx + startPosition];\n        endTick = tickPositions[tickIx + endPosition];\n      } else {\n        startTick = endTick = tickPositions[tickIx];\n      }\n      maxStartOffset = Math.max(maxStartOffset, startTick - label.box[offsetField + 1]);\n      maxEndOffset = Math.max(maxEndOffset, label.box[offsetField + 2] - endTick);\n    }\n    return {\n      start: maxStartOffset,\n      end: maxEndOffset\n    };\n  };\n  Axis.prototype.limitRange = function limitRange(from, to, min, max, offset) {\n    var options = this.options;\n    if (from < min && offset < 0 && (!defined(options.min) || options.min <= min) || max < to && offset > 0 && (!defined(options.max) || max <= options.max)) {\n      return null;\n    }\n    if (to < min && offset > 0 || max < from && offset < 0) {\n      return {\n        min: from,\n        max: to\n      };\n    }\n    var rangeSize = to - from;\n    var minValue = from;\n    var maxValue = to;\n    if (from < min && offset < 0) {\n      minValue = limitValue(from, min, max);\n      maxValue = limitValue(from + rangeSize, min + rangeSize, max);\n    } else if (to > max && offset > 0) {\n      maxValue = limitValue(to, min, max);\n      minValue = limitValue(to - rangeSize, min, max - rangeSize);\n    }\n    return {\n      min: minValue,\n      max: maxValue\n    };\n  };\n  Axis.prototype.valueRange = function valueRange() {\n    return {\n      min: this.seriesMin,\n      max: this.seriesMax\n    };\n  };\n  Axis.prototype.lineDir = function lineDir() {\n    /*\n     * Axis line direction:\n     *   * Vertical: up.\n     *   * Horizontal: right.\n     */\n\n    var ref = this.options;\n    var vertical = ref.vertical;\n    var reverse = ref.reverse;\n    return (vertical ? -1 : 1) * (reverse ? -1 : 1);\n  };\n  Axis.prototype.lineInfo = function lineInfo() {\n    var ref = this.options;\n    var vertical = ref.vertical;\n    var lineBox = this.lineBox();\n    var lineSize = vertical ? lineBox.height() : lineBox.width();\n    var axis = vertical ? Y : X;\n    var axisDir = this.lineDir();\n    var startEdge = axisDir === 1 ? 1 : 2;\n    var axisOrigin = axis + startEdge.toString();\n    var lineStart = lineBox[axisOrigin];\n    return {\n      axis: axis,\n      axisOrigin: axisOrigin,\n      axisDir: axisDir,\n      lineBox: lineBox,\n      lineSize: lineSize,\n      lineStart: lineStart\n    };\n  };\n  Axis.prototype.pointOffset = function pointOffset(point) {\n    var ref = this.lineInfo();\n    var axis = ref.axis;\n    var axisDir = ref.axisDir;\n    var axisOrigin = ref.axisOrigin;\n    var lineBox = ref.lineBox;\n    var lineSize = ref.lineSize;\n    var relative = axisDir > 0 ? point[axis] - lineBox[axisOrigin] : lineBox[axisOrigin] - point[axis];\n    var offset = relative / lineSize;\n    return offset;\n  };\n\n  // Computes the axis range change (delta) for a given scale factor.\n  // The delta is subtracted from the axis range:\n  //   * delta > 0 reduces the axis range (zoom-in)\n  //   * delta < 0 expands the axis range (zoom-out)\n  Axis.prototype.scaleToDelta = function scaleToDelta(rawScale, range) {\n    // Scale >= 1 would result in axis range of 0.\n    // Scale <= -1 would reverse the scale direction.\n    var MAX_SCALE = 0.999;\n    var scale = limitValue(rawScale, -MAX_SCALE, MAX_SCALE);\n    var delta;\n    if (scale > 0) {\n      delta = range * Math.min(1, scale);\n    } else {\n      delta = range - range / (1 + scale);\n    }\n    return delta;\n  };\n  Axis.prototype.labelsBetweenTicks = function labelsBetweenTicks() {\n    return !this.options.justified;\n  };\n\n  //add legacy fields to the options that are no longer generated by default\n  Axis.prototype.prepareUserOptions = function prepareUserOptions() {};\n  return Axis;\n}(ChartElement);\nsetDefaultOptions(Axis, {\n  labels: {\n    visible: true,\n    rotation: 0,\n    mirror: false,\n    step: 1,\n    skip: 0\n  },\n  line: {\n    width: 1,\n    color: BLACK,\n    visible: true\n  },\n  title: {\n    visible: true,\n    position: CENTER\n  },\n  majorTicks: {\n    align: OUTSIDE,\n    size: 4,\n    skip: 0,\n    step: 1\n  },\n  minorTicks: {\n    align: OUTSIDE,\n    size: 3,\n    skip: 0,\n    step: 1\n  },\n  axisCrossingValue: 0,\n  majorTickType: OUTSIDE,\n  minorTickType: NONE,\n  majorGridLines: {\n    skip: 0,\n    step: 1\n  },\n  minorGridLines: {\n    visible: false,\n    width: 1,\n    color: BLACK,\n    skip: 0,\n    step: 1\n  },\n  // TODO: Move to line or labels options\n  margin: 5,\n  visible: true,\n  reverse: false,\n  justified: true,\n  notes: {\n    label: {\n      text: \"\"\n    }\n  },\n  _alignLines: true,\n  _deferLabels: false\n});\nexport default Axis;","map":{"version":3,"names":["drawing","draw","geometry","geom","ChartElement","TextBox","AxisLabel","Note","Box","ChartService","createAxisTick","createAxisGridLine","NONE","BLACK","CENTER","TOP","BOTTOM","LEFT","RIGHT","OUTSIDE","X","Y","WIDTH","HEIGHT","alignPathToPixel","deepExtend","getTemplate","grep","defined","isObject","inArray","limitValue","round","setDefaultOptions","Axis","options","chartService","call","visible","labels","line","margin","majorTickSize","minorTickSize","minorTicks","color","width","minorTickType","size","align","majorTicks","majorTickType","initFields","_deferLabels","createLabels","createTitle","createNotes","__proto__","prototype","Object","create","constructor","labelsRange","min","skip","max","labelsCount","normalizeLabelRotation","labelOptions","rotation","alignRotation","angle","this$1","vertical","zIndex","step","Math","clearLabels","autoRotateLabels","range","idx","labelContext","index","count","label","createAxisLabel","append","push","children","child","clearTitle","title","undefined","clear","lineBox","ref","box","mirror","axisX","x1","x2","axisY","y2","y1","lineWidth","titleOptions","text","visualSize","notes","items","data","i","length","item","value","parseNoteValue","note","dataItem","position","reverse","renderVisual","createPlotBands","createVisual","createBackground","createLine","gridLinesVisual","gridLines","_gridLines","Group","appendVisual","createTicks","lineGroup","majorUnit","tickLineOptions","render","tickPositions","tickOptions","skipUnit","tickX","tickY","getMajorTickPositions","getMinorTickPositions","minorUnit","path","Path","stroke","dashType","moveTo","lineTo","_alignLines","group","_lineGroup","visual","getActualTickSize","tickSize","background","_backgroundPath","fromRect","toRect","fill","plotBands","plotArea","_plotbandGroup","altAxis","pane","axes","axis","slotX","slotY","getSlot","from","to","vAlign","createPlotBandLabel","height","bandRect","Rect","opacity","textbox","labelTemplate","format","auto","reflow","createGridLines","minorGridLines","majorGridLines","axisLineVisible","linePos","lineOptions","lineStart","lineEnd","container","gridLine","pos","sizeFn","titleSize","space","rootBox","getRoot","boxSize","maxLabelSize","labelSize","arrangeTitle","arrangeLabels","arrangeNotes","getLabelsTickPositions","labelTickIndex","labelsBetweenTicks","tickIx","firstTickPosition","nextTickPosition","positionStart","positionEnd","middle","positionLabel","labelOffset","labelBox","labelX","rotationOrigin","move","labelY","autoRotateLabelAngle","slotWidth","limit","abs","labelAngle","idx$1","slot","shouldRenderNote","show","hide","noteSlot","alignTo","secondAxis","snapTo","shrink","axisLabelText","context","tmpl","defaultText","localeAuto","culture","templateContext","assign","contentBox","clone","isPannable","offset","maxLabelOffset","start","end","wrap","lastLabel","offsetField","startPosition","endPosition","maxStartOffset","maxEndOffset","startTick","endTick","limitRange","rangeSize","minValue","maxValue","valueRange","seriesMin","seriesMax","lineDir","lineInfo","lineSize","axisDir","startEdge","axisOrigin","toString","pointOffset","point","relative","scaleToDelta","rawScale","MAX_SCALE","scale","delta","justified","prepareUserOptions","axisCrossingValue"],"sources":["C:/Users/Павел/Desktop/react humster/my-app/node_modules/@progress/kendo-charts/dist/es/core/axis.js"],"sourcesContent":["import { drawing as draw, geometry as geom } from '@progress/kendo-drawing';\n\nimport ChartElement from './chart-element';\nimport TextBox from './text-box';\nimport AxisLabel from './axis-label';\nimport Note from './note';\nimport Box from './box';\nimport { ChartService } from '../services';\n\nimport createAxisTick from './utils/create-axis-tick';\nimport createAxisGridLine from './utils/create-axis-grid-line';\n\nimport { NONE, BLACK, CENTER, TOP, BOTTOM, LEFT, RIGHT, OUTSIDE, X, Y, WIDTH, HEIGHT } from '../common/constants';\nimport { alignPathToPixel, deepExtend, getTemplate, grep, defined, isObject, inArray, limitValue, round, setDefaultOptions } from '../common';\n\nvar Axis = (function (ChartElement) {\n    function Axis(options, chartService) {\n        if ( chartService === void 0 ) chartService = new ChartService();\n\n        ChartElement.call(this, options);\n\n        this.chartService = chartService;\n\n        if (!this.options.visible) {\n            this.options = deepExtend({}, this.options, {\n                labels: {\n                    visible: false\n                },\n                line: {\n                    visible: false\n                },\n                margin: 0,\n                majorTickSize: 0,\n                minorTickSize: 0\n            });\n        }\n\n        this.options.minorTicks = deepExtend({}, {\n            color: this.options.line.color,\n            width: this.options.line.width,\n            visible: this.options.minorTickType !== NONE\n        }, this.options.minorTicks, {\n            size: this.options.minorTickSize,\n            align: this.options.minorTickType\n        });\n\n        this.options.majorTicks = deepExtend({}, {\n            color: this.options.line.color,\n            width: this.options.line.width,\n            visible: this.options.majorTickType !== NONE\n        }, this.options.majorTicks, {\n            size: this.options.majorTickSize,\n            align: this.options.majorTickType\n        });\n\n        this.initFields();\n\n        if (!this.options._deferLabels) {\n            this.createLabels();\n        }\n\n        this.createTitle();\n        this.createNotes();\n    }\n\n    if ( ChartElement ) Axis.__proto__ = ChartElement;\n    Axis.prototype = Object.create( ChartElement && ChartElement.prototype );\n    Axis.prototype.constructor = Axis;\n\n    Axis.prototype.initFields = function initFields () {\n    };\n\n    // abstract labelsCount(): Number\n    // abstract createAxisLabel(index, options): AxisLabel\n\n    Axis.prototype.labelsRange = function labelsRange () {\n        return {\n            min: this.options.labels.skip,\n            max: this.labelsCount()\n        };\n    };\n\n    Axis.prototype.normalizeLabelRotation = function normalizeLabelRotation (labelOptions) {\n        var rotation = labelOptions.rotation;\n\n        if (isObject(rotation)) {\n            labelOptions.alignRotation = rotation.align;\n            labelOptions.rotation = rotation.angle;\n        }\n    };\n\n    Axis.prototype.createLabels = function createLabels () {\n        var this$1 = this;\n\n        var options = this.options;\n        var align = options.vertical ? RIGHT : CENTER;\n        var labelOptions = deepExtend({ }, options.labels, {\n            align: align,\n            zIndex: options.zIndex\n        });\n        var step = Math.max(1, labelOptions.step);\n\n        this.clearLabels();\n\n        if (labelOptions.visible) {\n            this.normalizeLabelRotation(labelOptions);\n            if (labelOptions.rotation === \"auto\") {\n                labelOptions.rotation = 0;\n                options.autoRotateLabels = true;\n            }\n\n            var range = this.labelsRange();\n            for (var idx = range.min; idx < range.max; idx += step) {\n                var labelContext = { index: idx, count: range.max };\n                var label = this$1.createAxisLabel(idx, labelOptions, labelContext);\n                if (label) {\n                    this$1.append(label);\n                    this$1.labels.push(label);\n                }\n            }\n        }\n    };\n\n    Axis.prototype.clearLabels = function clearLabels () {\n        this.children = grep(this.children, function (child) { return !(child instanceof AxisLabel); });\n        this.labels = [];\n    };\n\n    Axis.prototype.clearTitle = function clearTitle () {\n        var this$1 = this;\n\n        if (this.title) {\n            this.children = grep(this.children, function (child) { return child !== this$1.title; });\n            this.title = undefined;\n        }\n    };\n\n    Axis.prototype.clear = function clear () {\n        this.clearLabels();\n        this.clearTitle();\n    };\n\n    Axis.prototype.lineBox = function lineBox () {\n        var ref = this;\n        var options = ref.options;\n        var box = ref.box;\n        var vertical = options.vertical;\n        var mirror = options.labels.mirror;\n        var axisX = mirror ? box.x1 : box.x2;\n        var axisY = mirror ? box.y2 : box.y1;\n        var lineWidth = options.line.width || 0;\n\n        return vertical ?\n            new Box(axisX, box.y1, axisX, box.y2 - lineWidth) :\n            new Box(box.x1, axisY, box.x2 - lineWidth, axisY);\n    };\n\n    Axis.prototype.createTitle = function createTitle () {\n        var options = this.options;\n        var titleOptions = deepExtend({\n            rotation: options.vertical ? -90 : 0,\n            text: \"\",\n            zIndex: 1,\n            visualSize: true\n        }, options.title);\n\n        if (titleOptions.visible && titleOptions.text) {\n            var title = new TextBox(titleOptions.text, titleOptions);\n            this.append(title);\n            this.title = title;\n        }\n    };\n\n    Axis.prototype.createNotes = function createNotes () {\n        var this$1 = this;\n\n        var options = this.options;\n        var notes = options.notes;\n        var items = notes.data || [];\n\n        this.notes = [];\n\n        for (var i = 0; i < items.length; i++) {\n            var item = deepExtend({}, notes, items[i]);\n            item.value = this$1.parseNoteValue(item.value);\n\n            var note = new Note({\n                value: item.value,\n                text: item.label.text,\n                dataItem: item\n            }, item, this$1.chartService);\n\n            if (note.options.visible) {\n                if (defined(note.options.position)) {\n                    if (options.vertical && !inArray(note.options.position, [ LEFT, RIGHT ])) {\n                        note.options.position = options.reverse ? LEFT : RIGHT;\n                    } else if (!options.vertical && !inArray(note.options.position, [ TOP, BOTTOM ])) {\n                        note.options.position = options.reverse ? BOTTOM : TOP;\n                    }\n                } else {\n                    if (options.vertical) {\n                        note.options.position = options.reverse ? LEFT : RIGHT;\n                    } else {\n                        note.options.position = options.reverse ? BOTTOM : TOP;\n                    }\n                }\n                this$1.append(note);\n                this$1.notes.push(note);\n            }\n        }\n    };\n\n    Axis.prototype.parseNoteValue = function parseNoteValue (value) {\n        return value;\n    };\n\n    Axis.prototype.renderVisual = function renderVisual () {\n        ChartElement.prototype.renderVisual.call(this);\n\n        this.createPlotBands();\n    };\n\n    Axis.prototype.createVisual = function createVisual () {\n        ChartElement.prototype.createVisual.call(this);\n\n        this.createBackground();\n        this.createLine();\n    };\n\n    Axis.prototype.gridLinesVisual = function gridLinesVisual () {\n        var gridLines = this._gridLines;\n        if (!gridLines) {\n            gridLines = this._gridLines = new draw.Group({\n                zIndex: -2\n            });\n            this.appendVisual(this._gridLines);\n        }\n\n        return gridLines;\n    };\n\n    Axis.prototype.createTicks = function createTicks (lineGroup) {\n        var options = this.options;\n        var lineBox = this.lineBox();\n        var mirror = options.labels.mirror;\n        var majorUnit = options.majorTicks.visible ? options.majorUnit : 0;\n        var tickLineOptions = {\n            // TODO\n            // _alignLines: options._alignLines,\n            vertical: options.vertical\n        };\n\n        function render(tickPositions, tickOptions, skipUnit) {\n            var count = tickPositions.length;\n            var step = Math.max(1, tickOptions.step);\n\n            if (tickOptions.visible) {\n                for (var i = tickOptions.skip; i < count; i += step) {\n                    if (defined(skipUnit) && (i % skipUnit === 0)) {\n                        continue;\n                    }\n\n                    tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\n                    tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\n                    tickLineOptions.position = tickPositions[i];\n\n                    lineGroup.append(createAxisTick(tickLineOptions, tickOptions));\n                }\n            }\n        }\n\n        render(this.getMajorTickPositions(), options.majorTicks);\n        render(this.getMinorTickPositions(), options.minorTicks, majorUnit / options.minorUnit);\n    };\n\n    Axis.prototype.createLine = function createLine () {\n        var options = this.options;\n        var line = options.line;\n        var lineBox = this.lineBox();\n\n        if (line.width > 0 && line.visible) {\n            var path = new draw.Path({\n                stroke: {\n                    width: line.width,\n                    color: line.color,\n                    dashType: line.dashType\n                }\n\n                /* TODO\n                zIndex: line.zIndex,\n                */\n            });\n\n            path.moveTo(lineBox.x1, lineBox.y1)\n                .lineTo(lineBox.x2, lineBox.y2);\n\n            if (options._alignLines) {\n                alignPathToPixel(path);\n            }\n\n            var group = this._lineGroup = new draw.Group();\n            group.append(path);\n\n            this.visual.append(group);\n            this.createTicks(group);\n        }\n    };\n\n    Axis.prototype.getActualTickSize = function getActualTickSize () {\n        var options = this.options;\n        var tickSize = 0;\n\n        if (options.majorTicks.visible && options.minorTicks.visible) {\n            tickSize = Math.max(options.majorTicks.size, options.minorTicks.size);\n        } else if (options.majorTicks.visible) {\n            tickSize = options.majorTicks.size;\n        } else if (options.minorTicks.visible) {\n            tickSize = options.minorTicks.size;\n        }\n\n        return tickSize;\n    };\n\n    Axis.prototype.createBackground = function createBackground () {\n        var ref = this;\n        var options = ref.options;\n        var box = ref.box;\n        var background = options.background;\n\n        if (background) {\n            this._backgroundPath = draw.Path.fromRect(box.toRect(), {\n                fill: {\n                    color: background\n                },\n                stroke: null\n            });\n\n            this.visual.append(this._backgroundPath);\n        }\n    };\n\n    Axis.prototype.createPlotBands = function createPlotBands () {\n        var this$1 = this;\n\n        var options = this.options;\n        var plotBands = options.plotBands || [];\n        var vertical = options.vertical;\n        var plotArea = this.plotArea;\n\n        if (plotBands.length === 0) {\n            return;\n        }\n\n        var group = this._plotbandGroup = new draw.Group({\n            zIndex: -1\n        });\n\n        var altAxis = grep(this.pane.axes, function (axis) { return axis.options.vertical !== this$1.options.vertical; })[0];\n\n        for (var idx = 0; idx < plotBands.length; idx++) {\n            var item = plotBands[idx];\n            var slotX = (void 0), slotY = (void 0);\n            var labelOptions = item.label;\n            var label = (void 0);\n\n            if (vertical) {\n                slotX = (altAxis || plotArea.axisX).lineBox();\n                slotY = this$1.getSlot(item.from, item.to, true);\n            } else {\n                slotX = this$1.getSlot(item.from, item.to, true);\n                slotY = (altAxis || plotArea.axisY).lineBox();\n            }\n\n            if (labelOptions) {\n                labelOptions.vAlign = labelOptions.position || LEFT;\n                label = this$1.createPlotBandLabel(\n                    labelOptions,\n                    item,\n                    new Box(\n                        slotX.x1,\n                        slotY.y1,\n                        slotX.x2,\n                        slotY.y2\n                    )\n\n                );\n            }\n\n            if (slotX.width() !== 0 && slotY.height() !== 0) {\n                var bandRect = new geom.Rect(\n                    [ slotX.x1, slotY.y1 ],\n                    [ slotX.width(), slotY.height() ]\n                );\n\n                var path = draw.Path.fromRect(bandRect, {\n                    fill: {\n                        color: item.color,\n                        opacity: item.opacity\n                    },\n                    stroke: null\n                });\n\n                group.append(path);\n                if (label) {\n                    group.append(label);\n                }\n            }\n        }\n\n        this.appendVisual(group);\n    };\n\n    Axis.prototype.createPlotBandLabel = function createPlotBandLabel (label, item, box) {\n\n        if (label.visible === false) {\n            return null;\n        }\n\n        var text = label.text;\n        var textbox;\n\n        if (defined(label) && label.visible) {\n            var labelTemplate = getTemplate(label);\n            if (labelTemplate) {\n                text = labelTemplate({ text: text, item: item });\n            } else if (label.format) {\n                text = this.chartService.format.auto(label.format, text);\n            }\n\n            if (!label.color) {\n                label.color = this.options.labels.color;\n            }\n        }\n\n        textbox = new TextBox(text, label);\n        textbox.reflow(box);\n        textbox.renderVisual();\n\n        return textbox.visual;\n    };\n\n    Axis.prototype.createGridLines = function createGridLines (altAxis) {\n        var options = this.options;\n        var minorGridLines = options.minorGridLines;\n        var majorGridLines = options.majorGridLines;\n        var minorUnit = options.minorUnit;\n        var vertical = options.vertical;\n        var axisLineVisible = altAxis.options.line.visible;\n        var majorUnit = majorGridLines.visible ? options.majorUnit : 0;\n        var lineBox = altAxis.lineBox();\n        var linePos = lineBox[vertical ? \"y1\" : \"x1\"];\n        var lineOptions = {\n            lineStart: lineBox[vertical ? \"x1\" : \"y1\"],\n            lineEnd: lineBox[vertical ? \"x2\" : \"y2\"],\n            vertical: vertical\n        };\n        var majorTicks = [];\n\n        var container = this.gridLinesVisual();\n\n        function render(tickPositions, gridLine, skipUnit) {\n            var count = tickPositions.length;\n            var step = Math.max(1, gridLine.step);\n\n            if (gridLine.visible) {\n                for (var i = gridLine.skip; i < count; i += step) {\n                    var pos = round(tickPositions[i]);\n                    if (!inArray(pos, majorTicks)) {\n                        if (i % skipUnit !== 0 && (!axisLineVisible || linePos !== pos)) {\n                            lineOptions.position = pos;\n                            container.append(createAxisGridLine(lineOptions, gridLine));\n\n                            majorTicks.push(pos);\n                        }\n                    }\n                }\n            }\n        }\n\n        render(this.getMajorTickPositions(), majorGridLines);\n        render(this.getMinorTickPositions(), minorGridLines, majorUnit / minorUnit);\n\n        return container.children;\n    };\n\n    Axis.prototype.reflow = function reflow (box) {\n        var ref = this;\n        var options = ref.options;\n        var labels = ref.labels;\n        var title = ref.title;\n        var vertical = options.vertical;\n        var count = labels.length;\n        var sizeFn = vertical ? WIDTH : HEIGHT;\n        var titleSize = title ? title.box[sizeFn]() : 0;\n        var space = this.getActualTickSize() + options.margin + titleSize;\n        var rootBox = (this.getRoot() || {}).box || box;\n        var boxSize = rootBox[sizeFn]();\n        var maxLabelSize = 0;\n\n        for (var i = 0; i < count; i++) {\n            var labelSize = labels[i].box[sizeFn]();\n            if (labelSize + space <= boxSize) {\n                maxLabelSize = Math.max(maxLabelSize, labelSize);\n            }\n        }\n\n        if (vertical) {\n            this.box = new Box(\n                box.x1, box.y1,\n                box.x1 + maxLabelSize + space, box.y2\n            );\n        } else {\n            this.box = new Box(\n                box.x1, box.y1,\n                box.x2, box.y1 + maxLabelSize + space\n            );\n        }\n\n        this.arrangeTitle();\n        this.arrangeLabels();\n        this.arrangeNotes();\n    };\n\n    Axis.prototype.getLabelsTickPositions = function getLabelsTickPositions () {\n        return this.getMajorTickPositions();\n    };\n\n    Axis.prototype.labelTickIndex = function labelTickIndex (label) {\n        return label.index;\n    };\n\n    Axis.prototype.arrangeLabels = function arrangeLabels () {\n        var this$1 = this;\n\n        var ref = this;\n        var options = ref.options;\n        var labels = ref.labels;\n        var labelsBetweenTicks = this.labelsBetweenTicks();\n        var vertical = options.vertical;\n        var mirror = options.labels.mirror;\n        var tickPositions = this.getLabelsTickPositions();\n\n        for (var idx = 0; idx < labels.length; idx++) {\n            var label = labels[idx];\n            var tickIx = this$1.labelTickIndex(label);\n            var labelSize = vertical ? label.box.height() : label.box.width();\n            var firstTickPosition = tickPositions[tickIx];\n            var nextTickPosition = tickPositions[tickIx + 1];\n            var positionStart = (void 0), positionEnd = (void 0);\n\n            if (vertical) {\n                if (labelsBetweenTicks) {\n                    var middle = firstTickPosition + (nextTickPosition - firstTickPosition) / 2;\n                    positionStart = middle - (labelSize / 2);\n                } else {\n                    positionStart = firstTickPosition - (labelSize / 2);\n                }\n\n                positionEnd = positionStart;\n            } else {\n                if (labelsBetweenTicks) {\n                    positionStart = firstTickPosition;\n                    positionEnd = nextTickPosition;\n                } else {\n                    positionStart = firstTickPosition - (labelSize / 2);\n                    positionEnd = positionStart + labelSize;\n                }\n            }\n\n            this$1.positionLabel(label, mirror, positionStart, positionEnd);\n        }\n    };\n\n    Axis.prototype.positionLabel = function positionLabel (label, mirror, positionStart, positionEnd) {\n        if ( positionEnd === void 0 ) positionEnd = positionStart;\n\n        var options = this.options;\n        var vertical = options.vertical;\n        var lineBox = this.lineBox();\n        var labelOffset = this.getActualTickSize() + options.margin;\n        var labelBox;\n\n        if (vertical) {\n            var labelX = lineBox.x2;\n\n            if (mirror) {\n                labelX += labelOffset;\n                label.options.rotationOrigin = LEFT;\n            } else {\n                labelX -= labelOffset + label.box.width();\n                label.options.rotationOrigin = RIGHT;\n            }\n\n            labelBox = label.box.move(labelX, positionStart);\n        } else {\n            var labelY = lineBox.y1;\n\n            if (mirror) {\n                labelY -= labelOffset + label.box.height();\n                label.options.rotationOrigin = BOTTOM;\n            } else {\n                labelY += labelOffset;\n                label.options.rotationOrigin = TOP;\n            }\n\n            labelBox = new Box(\n                positionStart, labelY,\n                positionEnd, labelY + label.box.height()\n            );\n        }\n\n        label.reflow(labelBox);\n    };\n\n    Axis.prototype.autoRotateLabelAngle = function autoRotateLabelAngle (labelBox, slotWidth) {\n        if (labelBox.width() < slotWidth) {\n            return 0;\n        }\n\n        if (labelBox.height() > slotWidth) {\n            return -90;\n        }\n\n        return -45;\n    };\n\n    Axis.prototype.autoRotateLabels = function autoRotateLabels () {\n        var this$1 = this;\n\n        if (!this.options.autoRotateLabels || this.options.vertical) {\n            return false;\n        }\n\n        var tickPositions = this.getMajorTickPositions();\n        var labels = this.labels;\n        var limit = Math.min(labels.length, tickPositions.length - 1);\n        var angle = 0;\n\n        for (var idx = 0; idx < limit; idx++) {\n            var width = Math.abs(tickPositions[idx + 1] - tickPositions[idx]);\n            var labelBox = labels[idx].box;\n            var labelAngle = this$1.autoRotateLabelAngle(labelBox, width);\n\n            if (labelAngle !== 0) {\n                angle = labelAngle;\n            }\n\n            if (angle === -90) {\n                break;\n            }\n        }\n\n        if (angle !== 0) {\n            for (var idx$1 = 0; idx$1 < labels.length; idx$1++) {\n                labels[idx$1].options.rotation = angle;\n                labels[idx$1].reflow(new Box());\n            }\n\n            return true;\n        }\n    };\n\n    Axis.prototype.arrangeTitle = function arrangeTitle () {\n        var ref = this;\n        var options = ref.options;\n        var title = ref.title;\n        var mirror = options.labels.mirror;\n        var vertical = options.vertical;\n\n        if (title) {\n            if (vertical) {\n                title.options.align = mirror ? RIGHT : LEFT;\n                title.options.vAlign = title.options.position;\n            } else {\n                title.options.align = title.options.position;\n                title.options.vAlign = mirror ? TOP : BOTTOM;\n            }\n\n            title.reflow(this.box);\n        }\n    };\n\n    Axis.prototype.arrangeNotes = function arrangeNotes () {\n        var this$1 = this;\n\n        for (var idx = 0; idx < this.notes.length; idx++) {\n            var item = this$1.notes[idx];\n            var value = item.options.value;\n            var slot = (void 0);\n\n            if (defined(value)) {\n                if (this$1.shouldRenderNote(value)) {\n                    item.show();\n                } else {\n                    item.hide();\n                }\n\n                slot = this$1.noteSlot(value);\n            } else {\n                item.hide();\n            }\n\n            item.reflow(slot || this$1.lineBox());\n        }\n    };\n\n    Axis.prototype.noteSlot = function noteSlot (value) {\n        return this.getSlot(value);\n    };\n\n    Axis.prototype.alignTo = function alignTo (secondAxis) {\n        var lineBox = secondAxis.lineBox();\n        var vertical = this.options.vertical;\n        var pos = vertical ? Y : X;\n\n        this.box.snapTo(lineBox, pos);\n        if (vertical) {\n            this.box.shrink(0, this.lineBox().height() - lineBox.height());\n        } else {\n            this.box.shrink(this.lineBox().width() - lineBox.width(), 0);\n        }\n        this.box[pos + 1] -= this.lineBox()[pos + 1] - lineBox[pos + 1];\n        this.box[pos + 2] -= this.lineBox()[pos + 2] - lineBox[pos + 2];\n    };\n\n    Axis.prototype.axisLabelText = function axisLabelText (value, options, context) {\n        var this$1 = this;\n\n        var text;\n        var tmpl = getTemplate(options);\n        var defaultText = function () {\n            if (!options.format) {\n                return value;\n            }\n\n            return this$1.chartService.format.localeAuto(\n                options.format, [ value ], options.culture\n            );\n        };\n\n        if (tmpl) {\n            var templateContext = Object.assign({}, context, {\n                get text() { return defaultText(); },\n                value: value,\n                format: options.format,\n                culture: options.culture\n            });\n\n            text = tmpl(templateContext);\n        } else {\n            text = defaultText();\n        }\n\n        return text;\n    };\n\n    Axis.prototype.slot = function slot (from , to, limit) {\n        var slot = this.getSlot(from, to, limit);\n        if (slot) {\n            return slot.toRect();\n        }\n    };\n\n    Axis.prototype.contentBox = function contentBox () {\n        var box = this.box.clone();\n        var labels = this.labels;\n        if (labels.length) {\n            var axis = this.options.vertical ? Y : X;\n            if (this.chartService.isPannable(axis)) {\n                var offset = this.maxLabelOffset();\n                box[axis + 1] -= offset.start;\n                box[axis + 2] += offset.end;\n            } else {\n                if (labels[0].options.visible) {\n                    box.wrap(labels[0].box);\n                }\n                var lastLabel = labels[labels.length - 1];\n                if (lastLabel.options.visible) {\n                    box.wrap(lastLabel.box);\n                }\n            }\n        }\n\n        return box;\n    };\n\n    Axis.prototype.maxLabelOffset = function maxLabelOffset () {\n        var this$1 = this;\n\n        var ref = this.options;\n        var vertical = ref.vertical;\n        var reverse = ref.reverse;\n        var labelsBetweenTicks = this.labelsBetweenTicks();\n        var tickPositions = this.getLabelsTickPositions();\n        var offsetField = vertical ? Y : X;\n        var labels = this.labels;\n        var startPosition = reverse ? 1 : 0;\n        var endPosition = reverse ? 0 : 1;\n        var maxStartOffset = 0;\n        var maxEndOffset = 0;\n\n        for (var idx = 0; idx < labels.length; idx++) {\n            var label = labels[idx];\n            var tickIx = this$1.labelTickIndex(label);\n            var startTick = (void 0), endTick = (void 0);\n\n            if (labelsBetweenTicks) {\n                startTick = tickPositions[tickIx + startPosition];\n                endTick = tickPositions[tickIx + endPosition];\n            } else {\n                startTick = endTick = tickPositions[tickIx];\n            }\n\n            maxStartOffset = Math.max(maxStartOffset, startTick - label.box[offsetField + 1]);\n            maxEndOffset = Math.max(maxEndOffset, label.box[offsetField + 2] - endTick);\n        }\n\n        return {\n            start: maxStartOffset,\n            end: maxEndOffset\n        };\n    };\n\n    Axis.prototype.limitRange = function limitRange (from, to, min, max, offset) {\n        var options = this.options;\n\n        if ((from < min && offset < 0 && (!defined(options.min) || options.min <= min)) || (max < to && offset > 0 && (!defined(options.max) || max <= options.max))) {\n            return null;\n        }\n\n        if ((to < min && offset > 0) || (max < from && offset < 0)) {\n            return {\n                min: from,\n                max: to\n            };\n        }\n\n        var rangeSize = to - from;\n        var minValue = from;\n        var maxValue = to;\n\n        if (from < min && offset < 0) {\n            minValue = limitValue(from, min, max);\n            maxValue = limitValue(from + rangeSize, min + rangeSize, max);\n        } else if (to > max && offset > 0) {\n            maxValue = limitValue(to, min, max);\n            minValue = limitValue(to - rangeSize, min, max - rangeSize);\n        }\n\n        return {\n            min: minValue,\n            max: maxValue\n        };\n    };\n\n    Axis.prototype.valueRange = function valueRange () {\n        return {\n            min: this.seriesMin,\n            max: this.seriesMax\n        };\n    };\n\n    Axis.prototype.lineDir = function lineDir () {\n        /*\n         * Axis line direction:\n         *   * Vertical: up.\n         *   * Horizontal: right.\n         */\n\n        var ref = this.options;\n        var vertical = ref.vertical;\n        var reverse = ref.reverse;\n        return (vertical ? -1 : 1) * (reverse ? -1 : 1);\n    };\n\n    Axis.prototype.lineInfo = function lineInfo () {\n        var ref = this.options;\n        var vertical = ref.vertical;\n        var lineBox = this.lineBox();\n        var lineSize = vertical ? lineBox.height() : lineBox.width();\n        var axis = vertical ? Y : X;\n        var axisDir = this.lineDir();\n        var startEdge = axisDir === 1 ? 1 : 2;\n        var axisOrigin = axis + startEdge.toString();\n        var lineStart = lineBox[axisOrigin];\n\n        return {\n            axis: axis,\n            axisOrigin: axisOrigin,\n            axisDir: axisDir,\n            lineBox: lineBox,\n            lineSize: lineSize,\n            lineStart: lineStart\n        };\n    };\n\n    Axis.prototype.pointOffset = function pointOffset (point) {\n        var ref = this.lineInfo();\n        var axis = ref.axis;\n        var axisDir = ref.axisDir;\n        var axisOrigin = ref.axisOrigin;\n        var lineBox = ref.lineBox;\n        var lineSize = ref.lineSize;\n        var relative = axisDir > 0 ? point[axis] - lineBox[axisOrigin] : lineBox[axisOrigin] - point[axis];\n        var offset = relative / lineSize;\n\n        return offset;\n    };\n\n    // Computes the axis range change (delta) for a given scale factor.\n    // The delta is subtracted from the axis range:\n    //   * delta > 0 reduces the axis range (zoom-in)\n    //   * delta < 0 expands the axis range (zoom-out)\n    Axis.prototype.scaleToDelta = function scaleToDelta (rawScale, range) {\n        // Scale >= 1 would result in axis range of 0.\n        // Scale <= -1 would reverse the scale direction.\n        var MAX_SCALE = 0.999;\n        var scale = limitValue(rawScale, -MAX_SCALE, MAX_SCALE);\n\n        var delta;\n        if (scale > 0) {\n            delta = range * Math.min(1, scale);\n        } else {\n            delta = range - (range / (1 + scale));\n        }\n\n        return delta;\n    };\n\n    Axis.prototype.labelsBetweenTicks = function labelsBetweenTicks () {\n        return !this.options.justified;\n    };\n\n    //add legacy fields to the options that are no longer generated by default\n    Axis.prototype.prepareUserOptions = function prepareUserOptions () {\n    };\n\n    return Axis;\n}(ChartElement));\n\nsetDefaultOptions(Axis, {\n    labels: {\n        visible: true,\n        rotation: 0,\n        mirror: false,\n        step: 1,\n        skip: 0\n    },\n    line: {\n        width: 1,\n        color: BLACK,\n        visible: true\n    },\n    title: {\n        visible: true,\n        position: CENTER\n    },\n    majorTicks: {\n        align: OUTSIDE,\n        size: 4,\n        skip: 0,\n        step: 1\n    },\n    minorTicks: {\n        align: OUTSIDE,\n        size: 3,\n        skip: 0,\n        step: 1\n    },\n    axisCrossingValue: 0,\n    majorTickType: OUTSIDE,\n    minorTickType: NONE,\n    majorGridLines: {\n        skip: 0,\n        step: 1\n    },\n    minorGridLines: {\n        visible: false,\n        width: 1,\n        color: BLACK,\n        skip: 0,\n        step: 1\n    },\n    // TODO: Move to line or labels options\n    margin: 5,\n    visible: true,\n    reverse: false,\n    justified: true,\n    notes: {\n        label: {\n            text: \"\"\n        }\n    },\n\n    _alignLines: true,\n    _deferLabels: false\n});\n\nexport default Axis;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}