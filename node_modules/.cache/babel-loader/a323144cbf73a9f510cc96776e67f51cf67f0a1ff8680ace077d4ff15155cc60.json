{"ast":null,"code":"import Axis from './axis';\nimport AxisLabel from './axis-label';\nimport { BLACK, COORD_PRECISION, DEFAULT_PRECISION, X, Y } from '../common/constants';\nimport { defined, isNumber, last, limitValue, round, setDefaultOptions, valueOrDefault, HashMap } from '../common';\nimport { dateEquals } from '../date-utils';\nvar MIN_CATEGORY_POINTS_RANGE = 0.01;\nvar MIN_CATEGORY_RANGE = 0.1;\nfunction indexOf(value, arr) {\n  if (value instanceof Date) {\n    var length = arr.length;\n    for (var idx = 0; idx < length; idx++) {\n      if (dateEquals(arr[idx], value)) {\n        return idx;\n      }\n    }\n    return -1;\n  }\n  return arr.indexOf(value);\n}\nvar CategoryAxis = function (Axis) {\n  function CategoryAxis() {\n    Axis.apply(this, arguments);\n  }\n  if (Axis) CategoryAxis.__proto__ = Axis;\n  CategoryAxis.prototype = Object.create(Axis && Axis.prototype);\n  CategoryAxis.prototype.constructor = CategoryAxis;\n  CategoryAxis.prototype.initFields = function initFields() {\n    this._ticks = {};\n  };\n  CategoryAxis.prototype.categoriesHash = function categoriesHash() {\n    return \"\";\n  };\n  CategoryAxis.prototype.clone = function clone() {\n    var copy = new CategoryAxis(Object.assign({}, this.options, {\n      categories: this.options.srcCategories\n    }), this.chartService);\n    copy.createLabels();\n    return copy;\n  };\n  CategoryAxis.prototype.initUserOptions = function initUserOptions(options) {\n    var categories = options.categories || [];\n    var definedMin = defined(options.min);\n    var definedMax = defined(options.max);\n    options.srcCategories = options.categories = categories;\n    if ((definedMin || definedMax) && categories.length) {\n      var min = definedMin ? Math.floor(options.min) : 0;\n      var max;\n      if (definedMax) {\n        max = options.justified ? Math.floor(options.max) + 1 : Math.ceil(options.max);\n      } else {\n        max = categories.length;\n      }\n      options.categories = options.categories.slice(min, max);\n    }\n    return options;\n  };\n  CategoryAxis.prototype.rangeIndices = function rangeIndices() {\n    var options = this.options;\n    var length = options.categories.length || 1;\n    var min = isNumber(options.min) ? options.min % 1 : 0;\n    var max;\n    if (isNumber(options.max) && options.max % 1 !== 0 && options.max < this.totalRange().max) {\n      max = length - (1 - options.max % 1);\n    } else {\n      max = length - (options.justified ? 1 : 0);\n    }\n    return {\n      min: min,\n      max: max\n    };\n  };\n  CategoryAxis.prototype.totalRangeIndices = function totalRangeIndices(limit) {\n    var options = this.options;\n    var min = isNumber(options.min) ? options.min : 0;\n    var max;\n    if (isNumber(options.max)) {\n      max = options.max;\n    } else if (isNumber(options.min)) {\n      max = min + options.categories.length;\n    } else {\n      max = this.totalRange().max || 1;\n    }\n    if (limit) {\n      var totalRange = this.totalRange();\n      min = limitValue(min, 0, totalRange.max);\n      max = limitValue(max, 0, totalRange.max);\n    }\n    return {\n      min: min,\n      max: max\n    };\n  };\n  CategoryAxis.prototype.range = function range() {\n    var options = this.options;\n    var min = isNumber(options.min) ? options.min : 0;\n    var max = isNumber(options.max) ? options.max : this.totalRange().max;\n    return {\n      min: min,\n      max: max\n    };\n  };\n  CategoryAxis.prototype.roundedRange = function roundedRange() {\n    return this.range();\n  };\n  CategoryAxis.prototype.totalRange = function totalRange() {\n    var options = this.options;\n    return {\n      min: 0,\n      max: Math.max(this._seriesMax || 0, options.srcCategories.length) - (options.justified ? 1 : 0)\n    };\n  };\n  CategoryAxis.prototype.scaleOptions = function scaleOptions() {\n    var ref = this.rangeIndices();\n    var min = ref.min;\n    var max = ref.max;\n    var lineBox = this.lineBox();\n    var size = this.options.vertical ? lineBox.height() : lineBox.width();\n    var scale = size / (max - min || 1);\n    return {\n      scale: scale * (this.options.reverse ? -1 : 1),\n      box: lineBox,\n      min: min,\n      max: max\n    };\n  };\n  CategoryAxis.prototype.arrangeLabels = function arrangeLabels() {\n    Axis.prototype.arrangeLabels.call(this);\n    this.hideOutOfRangeLabels();\n  };\n  CategoryAxis.prototype.hideOutOfRangeLabels = function hideOutOfRangeLabels() {\n    var ref = this;\n    var box = ref.box;\n    var labels = ref.labels;\n    if (labels.length > 0) {\n      var valueAxis = this.options.vertical ? Y : X;\n      var start = box[valueAxis + 1];\n      var end = box[valueAxis + 2];\n      var firstLabel = labels[0];\n      var lastLabel = last(labels);\n      if (firstLabel.box[valueAxis + 1] > end || firstLabel.box[valueAxis + 2] < start) {\n        firstLabel.options.visible = false;\n      }\n      if (lastLabel.box[valueAxis + 1] > end || lastLabel.box[valueAxis + 2] < start) {\n        lastLabel.options.visible = false;\n      }\n    }\n  };\n  CategoryAxis.prototype.getMajorTickPositions = function getMajorTickPositions() {\n    return this.getTicks().majorTicks;\n  };\n  CategoryAxis.prototype.getMinorTickPositions = function getMinorTickPositions() {\n    return this.getTicks().minorTicks;\n  };\n  CategoryAxis.prototype.getLabelsTickPositions = function getLabelsTickPositions() {\n    return this.getTicks().labelTicks;\n  };\n  CategoryAxis.prototype.tickIndices = function tickIndices(stepSize) {\n    var ref = this.rangeIndices();\n    var min = ref.min;\n    var max = ref.max;\n    var limit = Math.ceil(max);\n    var current = Math.floor(min);\n    var indices = [];\n    while (current <= limit) {\n      indices.push(current);\n      current += stepSize;\n    }\n    return indices;\n  };\n  CategoryAxis.prototype.getTickPositions = function getTickPositions(stepSize) {\n    var ref = this.options;\n    var vertical = ref.vertical;\n    var reverse = ref.reverse;\n    var ref$1 = this.scaleOptions();\n    var scale = ref$1.scale;\n    var box = ref$1.box;\n    var min = ref$1.min;\n    var pos = box[(vertical ? Y : X) + (reverse ? 2 : 1)];\n    var indices = this.tickIndices(stepSize);\n    var positions = [];\n    for (var idx = 0; idx < indices.length; idx++) {\n      positions.push(pos + round(scale * (indices[idx] - min), COORD_PRECISION));\n    }\n    return positions;\n  };\n  CategoryAxis.prototype.getTicks = function getTicks() {\n    var options = this.options;\n    var cache = this._ticks;\n    var range = this.rangeIndices();\n    var lineBox = this.lineBox();\n    var hash = lineBox.getHash() + range.min + \",\" + range.max + options.reverse + options.justified;\n    if (cache._hash !== hash) {\n      var hasMinor = options.minorTicks.visible || options.minorGridLines.visible;\n      cache._hash = hash;\n      cache.labelTicks = this.getTickPositions(1);\n      cache.majorTicks = this.filterOutOfRangePositions(cache.labelTicks, lineBox);\n      cache.minorTicks = hasMinor ? this.filterOutOfRangePositions(this.getTickPositions(0.5), lineBox) : [];\n    }\n    return cache;\n  };\n  CategoryAxis.prototype.filterOutOfRangePositions = function filterOutOfRangePositions(positions, lineBox) {\n    if (!positions.length) {\n      return positions;\n    }\n    var axis = this.options.vertical ? Y : X;\n    var inRange = function (position) {\n      return lineBox[axis + 1] <= position && position <= lineBox[axis + 2];\n    };\n    var end = positions.length - 1;\n    var startIndex = 0;\n    while (!inRange(positions[startIndex]) && startIndex <= end) {\n      startIndex++;\n    }\n    var endIndex = end;\n    while (!inRange(positions[endIndex]) && endIndex >= 0) {\n      endIndex--;\n    }\n    return positions.slice(startIndex, endIndex + 1);\n  };\n  CategoryAxis.prototype.lineInfo = function lineInfo() {\n    var ref = this.options;\n    var vertical = ref.vertical;\n    var reverse = ref.reverse;\n    var lineBox = this.lineBox();\n    var lineSize = vertical ? lineBox.height() : lineBox.width();\n    var axis = vertical ? Y : X;\n    var axisDir = reverse ? -1 : 1;\n    var startEdge = axisDir === 1 ? 1 : 2;\n    var axisOrigin = axis + startEdge.toString();\n    var lineStart = lineBox[axisOrigin];\n    return {\n      axis: axis,\n      axisOrigin: axisOrigin,\n      axisDir: axisDir,\n      lineBox: lineBox,\n      lineSize: lineSize,\n      lineStart: lineStart\n    };\n  };\n  CategoryAxis.prototype.lineDir = function lineDir() {\n    /*\n     *  Category axis line direction:\n     *    * Vertical: down.\n     *    * Horizontal: right.\n     */\n\n    var ref = this.options;\n    var reverse = ref.reverse;\n    return reverse ? -1 : 1;\n  };\n\n  // TODO: Rename to slotBox, valueSlot, slotByIndex?\n  CategoryAxis.prototype.getSlot = function getSlot(from, to, limit) {\n    var options = this.options;\n    var reverse = options.reverse;\n    var justified = options.justified;\n    var ref = this.scaleOptions();\n    var scale = ref.scale;\n    var box = ref.box;\n    var min = ref.min;\n    var ref$1 = this.lineInfo();\n    var valueAxis = ref$1.axis;\n    var lineStart = ref$1.lineStart;\n    var slotBox = box.clone();\n    var singleSlot = !defined(to);\n    var start = valueOrDefault(from, 0);\n    var end = valueOrDefault(to, start);\n    end = Math.max(end - 1, start);\n\n    // Fixes transient bug caused by iOS 6.0 JIT\n    // (one can never be too sure)\n    end = Math.max(start, end);\n    var p1 = lineStart + (start - min) * scale;\n    var p2 = lineStart + (end + 1 - min) * scale;\n    if (singleSlot && justified) {\n      p2 = p1;\n    }\n    if (limit) {\n      p1 = limitValue(p1, box[valueAxis + 1], box[valueAxis + 2]);\n      p2 = limitValue(p2, box[valueAxis + 1], box[valueAxis + 2]);\n    }\n    slotBox[valueAxis + 1] = reverse ? p2 : p1;\n    slotBox[valueAxis + 2] = reverse ? p1 : p2;\n    return slotBox;\n  };\n  CategoryAxis.prototype.limitSlot = function limitSlot(slot) {\n    var vertical = this.options.vertical;\n    var valueAxis = vertical ? Y : X;\n    var lineBox = this.lineBox();\n    var limittedSlot = slot.clone();\n    limittedSlot[valueAxis + 1] = limitValue(slot[valueAxis + 1], lineBox[valueAxis + 1], lineBox[valueAxis + 2]);\n    limittedSlot[valueAxis + 2] = limitValue(slot[valueAxis + 2], lineBox[valueAxis + 1], lineBox[valueAxis + 2]);\n    return limittedSlot;\n  };\n  CategoryAxis.prototype.slot = function slot(from, to, limit) {\n    var min = Math.floor(this.options.min || 0);\n    var start = from;\n    var end = to;\n    if (typeof start === \"string\") {\n      start = this.categoryIndex(start);\n    } else if (isNumber(start)) {\n      start -= min;\n    }\n    if (typeof end === \"string\") {\n      end = this.categoryIndex(end);\n    } else if (isNumber(end)) {\n      end -= min;\n    }\n    return Axis.prototype.slot.call(this, start, end, limit);\n  };\n  CategoryAxis.prototype.pointCategoryIndex = function pointCategoryIndex(point) {\n    var ref = this.options;\n    var reverse = ref.reverse;\n    var justified = ref.justified;\n    var vertical = ref.vertical;\n    var valueAxis = vertical ? Y : X;\n    var ref$1 = this.scaleOptions();\n    var scale = ref$1.scale;\n    var box = ref$1.box;\n    var min = ref$1.min;\n    var max = ref$1.max;\n    var startValue = reverse ? max : min;\n    var lineStart = box[valueAxis + 1];\n    var lineEnd = box[valueAxis + 2];\n    var pos = point[valueAxis];\n    if (pos < lineStart || pos > lineEnd) {\n      return null;\n    }\n    var value = startValue + (pos - lineStart) / scale;\n    var diff = value % 1;\n    if (justified) {\n      value = Math.round(value);\n    } else if (diff === 0 && value > 0) {\n      value--;\n    }\n    return Math.floor(value);\n  };\n  CategoryAxis.prototype.getCategory = function getCategory(point) {\n    var index = this.pointCategoryIndex(point);\n    if (index === null) {\n      return null;\n    }\n    return this.options.categories[index];\n  };\n  CategoryAxis.prototype.categoryIndex = function categoryIndex(value) {\n    return this.totalIndex(value) - Math.floor(this.options.min || 0);\n  };\n  CategoryAxis.prototype.categoryAt = function categoryAt(index, total) {\n    var options = this.options;\n    return (total ? options.srcCategories : options.categories)[index];\n  };\n  CategoryAxis.prototype.categoriesCount = function categoriesCount() {\n    return (this.options.categories || []).length;\n  };\n  CategoryAxis.prototype.translateRange = function translateRange(delta) {\n    var options = this.options;\n    var lineBox = this.lineBox();\n    var size = options.vertical ? lineBox.height() : lineBox.width();\n    var range = options.categories.length;\n    var scale = size / range;\n    var offset = round(delta / scale, DEFAULT_PRECISION);\n    return {\n      min: offset,\n      max: range + offset\n    };\n  };\n  CategoryAxis.prototype.scaleRange = function scaleRange(scale, cursor) {\n    var position = Math.abs(this.pointOffset(cursor));\n    var rangeIndices = this.totalRangeIndices();\n    var range = rangeIndices.max - rangeIndices.min;\n    var delta = this.scaleToDelta(scale, range);\n    var minDelta = position * delta;\n    var maxDelta = (1 - position) * delta;\n    var min = rangeIndices.min + minDelta;\n    var max = rangeIndices.max - maxDelta;\n    if (max - min < MIN_CATEGORY_RANGE) {\n      max = min + MIN_CATEGORY_RANGE;\n    }\n    return {\n      min: min,\n      max: max\n    };\n  };\n  CategoryAxis.prototype.zoomRange = function zoomRange(scale, cursor) {\n    var ref = this.totalRange();\n    var totalMin = ref.min;\n    var totalMax = ref.max;\n    var range = this.scaleRange(scale, cursor);\n    return {\n      min: limitValue(range.min, totalMin, totalMax),\n      max: limitValue(range.max, totalMin, totalMax)\n    };\n  };\n  CategoryAxis.prototype.labelsCount = function labelsCount() {\n    var labelsRange = this.labelsRange();\n    return labelsRange.max - labelsRange.min;\n  };\n  CategoryAxis.prototype.labelsRange = function labelsRange() {\n    var options = this.options;\n    var justified = options.justified;\n    var labelOptions = options.labels;\n    var ref = this.totalRangeIndices(true);\n    var min = ref.min;\n    var max = ref.max;\n    var start = Math.floor(min);\n    if (!justified) {\n      min = Math.floor(min);\n      max = Math.ceil(max);\n    } else {\n      min = Math.ceil(min);\n      max = Math.floor(max);\n    }\n    var skip;\n    if (min > labelOptions.skip) {\n      skip = labelOptions.skip + labelOptions.step * Math.ceil((min - labelOptions.skip) / labelOptions.step);\n    } else {\n      skip = labelOptions.skip;\n    }\n    return {\n      min: skip - start,\n      max: (options.categories.length ? max + (justified ? 1 : 0) : 0) - start\n    };\n  };\n  CategoryAxis.prototype.createAxisLabel = function createAxisLabel(index, labelOptions, labelContext) {\n    var options = this.options;\n    var dataItem = options.dataItems ? options.dataItems[index] : null;\n    var category = valueOrDefault(options.categories[index], \"\");\n    labelContext.dataItem = dataItem;\n    var text = this.axisLabelText(category, labelOptions, labelContext);\n    return new AxisLabel(category, text, index, dataItem, labelOptions);\n  };\n  CategoryAxis.prototype.shouldRenderNote = function shouldRenderNote(value) {\n    var range = this.totalRangeIndices();\n    return Math.floor(range.min) <= value && value <= Math.ceil(range.max);\n  };\n  CategoryAxis.prototype.noteSlot = function noteSlot(value) {\n    var options = this.options;\n    var index = value - Math.floor(options.min || 0);\n    return this.getSlot(index);\n  };\n  CategoryAxis.prototype.arrangeNotes = function arrangeNotes() {\n    Axis.prototype.arrangeNotes.call(this);\n    this.hideOutOfRangeNotes();\n  };\n  CategoryAxis.prototype.hideOutOfRangeNotes = function hideOutOfRangeNotes() {\n    var ref = this;\n    var notes = ref.notes;\n    var box = ref.box;\n    if (notes && notes.length) {\n      var valueAxis = this.options.vertical ? Y : X;\n      var start = box[valueAxis + 1];\n      var end = box[valueAxis + 2];\n      for (var idx = 0; idx < notes.length; idx++) {\n        var note = notes[idx];\n        if (note.box && (end < note.box[valueAxis + 1] || note.box[valueAxis + 2] < start)) {\n          note.hide();\n        }\n      }\n    }\n  };\n  CategoryAxis.prototype.pan = function pan(delta) {\n    var range = this.totalRangeIndices(true);\n    var ref = this.scaleOptions();\n    var scale = ref.scale;\n    var offset = round(delta / scale, DEFAULT_PRECISION);\n    var totalRange = this.totalRange();\n    var min = range.min + offset;\n    var max = range.max + offset;\n    return this.limitRange(min, max, 0, totalRange.max, offset);\n  };\n  CategoryAxis.prototype.pointsRange = function pointsRange(start, end) {\n    var ref = this.options;\n    var reverse = ref.reverse;\n    var vertical = ref.vertical;\n    var valueAxis = vertical ? Y : X;\n    var range = this.totalRangeIndices(true);\n    var ref$1 = this.scaleOptions();\n    var scale = ref$1.scale;\n    var box = ref$1.box;\n    var lineStart = box[valueAxis + (reverse ? 2 : 1)];\n    var diffStart = start[valueAxis] - lineStart;\n    var diffEnd = end[valueAxis] - lineStart;\n    var min = range.min + diffStart / scale;\n    var max = range.min + diffEnd / scale;\n    var rangeMin = Math.min(min, max);\n    var rangeMax = Math.max(min, max);\n    if (rangeMax - rangeMin >= MIN_CATEGORY_POINTS_RANGE) {\n      return {\n        min: rangeMin,\n        max: rangeMax\n      };\n    }\n  };\n  CategoryAxis.prototype.valueRange = function valueRange() {\n    return this.range();\n  };\n  CategoryAxis.prototype.totalIndex = function totalIndex(value) {\n    var options = this.options;\n    var index = this._categoriesMap ? this._categoriesMap.get(value) : indexOf(value, options.srcCategories);\n    return index;\n  };\n  CategoryAxis.prototype.currentRangeIndices = function currentRangeIndices() {\n    var options = this.options;\n    var min = 0;\n    if (isNumber(options.min)) {\n      min = Math.floor(options.min);\n    }\n    var max;\n    if (isNumber(options.max)) {\n      max = options.justified ? Math.floor(options.max) : Math.ceil(options.max) - 1;\n    } else {\n      max = this.totalCount() - 1;\n    }\n    return {\n      min: min,\n      max: max\n    };\n  };\n  CategoryAxis.prototype.mapCategories = function mapCategories() {\n    if (!this._categoriesMap) {\n      var map = this._categoriesMap = new HashMap();\n      var srcCategories = this.options.srcCategories;\n      for (var idx = 0; idx < srcCategories.length; idx++) {\n        map.set(srcCategories[idx], idx);\n      }\n    }\n  };\n  CategoryAxis.prototype.totalCount = function totalCount() {\n    return Math.max(this.options.srcCategories.length, this._seriesMax || 0);\n  };\n  return CategoryAxis;\n}(Axis);\nsetDefaultOptions(CategoryAxis, {\n  type: \"category\",\n  vertical: false,\n  majorGridLines: {\n    visible: false,\n    width: 1,\n    color: BLACK\n  },\n  labels: {\n    zIndex: 1\n  },\n  justified: false,\n  _deferLabels: true\n});\nexport default CategoryAxis;","map":{"version":3,"names":["Axis","AxisLabel","BLACK","COORD_PRECISION","DEFAULT_PRECISION","X","Y","defined","isNumber","last","limitValue","round","setDefaultOptions","valueOrDefault","HashMap","dateEquals","MIN_CATEGORY_POINTS_RANGE","MIN_CATEGORY_RANGE","indexOf","value","arr","Date","length","idx","CategoryAxis","apply","arguments","__proto__","prototype","Object","create","constructor","initFields","_ticks","categoriesHash","clone","copy","assign","options","categories","srcCategories","chartService","createLabels","initUserOptions","definedMin","min","definedMax","max","Math","floor","justified","ceil","slice","rangeIndices","totalRange","totalRangeIndices","limit","range","roundedRange","_seriesMax","scaleOptions","ref","lineBox","size","vertical","height","width","scale","reverse","box","arrangeLabels","call","hideOutOfRangeLabels","labels","valueAxis","start","end","firstLabel","lastLabel","visible","getMajorTickPositions","getTicks","majorTicks","getMinorTickPositions","minorTicks","getLabelsTickPositions","labelTicks","tickIndices","stepSize","current","indices","push","getTickPositions","ref$1","pos","positions","cache","hash","getHash","_hash","hasMinor","minorGridLines","filterOutOfRangePositions","axis","inRange","position","startIndex","endIndex","lineInfo","lineSize","axisDir","startEdge","axisOrigin","toString","lineStart","lineDir","getSlot","from","to","slotBox","singleSlot","p1","p2","limitSlot","slot","limittedSlot","categoryIndex","pointCategoryIndex","point","startValue","lineEnd","diff","getCategory","index","totalIndex","categoryAt","total","categoriesCount","translateRange","delta","offset","scaleRange","cursor","abs","pointOffset","scaleToDelta","minDelta","maxDelta","zoomRange","totalMin","totalMax","labelsCount","labelsRange","labelOptions","skip","step","createAxisLabel","labelContext","dataItem","dataItems","category","text","axisLabelText","shouldRenderNote","noteSlot","arrangeNotes","hideOutOfRangeNotes","notes","note","hide","pan","limitRange","pointsRange","diffStart","diffEnd","rangeMin","rangeMax","valueRange","_categoriesMap","get","currentRangeIndices","totalCount","mapCategories","map","set","type","majorGridLines","color","zIndex","_deferLabels"],"sources":["C:/Users/Павел/Desktop/react humster/my-app/node_modules/@progress/kendo-charts/dist/es/core/category-axis.js"],"sourcesContent":["import Axis from './axis';\nimport AxisLabel from './axis-label';\n\nimport { BLACK, COORD_PRECISION, DEFAULT_PRECISION, X, Y } from '../common/constants';\nimport { defined, isNumber, last, limitValue, round, setDefaultOptions, valueOrDefault, HashMap } from '../common';\nimport { dateEquals } from '../date-utils';\n\nvar MIN_CATEGORY_POINTS_RANGE = 0.01;\nvar MIN_CATEGORY_RANGE = 0.1;\n\nfunction indexOf(value, arr) {\n    if (value instanceof Date) {\n        var length = arr.length;\n        for (var idx = 0; idx < length; idx++) {\n            if (dateEquals(arr[idx], value)) {\n                return idx;\n            }\n        }\n\n        return -1;\n    }\n\n    return arr.indexOf(value);\n}\n\nvar CategoryAxis = (function (Axis) {\n    function CategoryAxis () {\n        Axis.apply(this, arguments);\n    }\n\n    if ( Axis ) CategoryAxis.__proto__ = Axis;\n    CategoryAxis.prototype = Object.create( Axis && Axis.prototype );\n    CategoryAxis.prototype.constructor = CategoryAxis;\n\n    CategoryAxis.prototype.initFields = function initFields () {\n        this._ticks = {};\n    };\n\n    CategoryAxis.prototype.categoriesHash = function categoriesHash () {\n        return \"\";\n    };\n\n    CategoryAxis.prototype.clone = function clone () {\n        var copy = new CategoryAxis(Object.assign({}, this.options, {\n            categories: this.options.srcCategories\n        }), this.chartService);\n        copy.createLabels();\n\n        return copy;\n    };\n\n    CategoryAxis.prototype.initUserOptions = function initUserOptions (options) {\n        var categories = options.categories || [];\n        var definedMin = defined(options.min);\n        var definedMax = defined(options.max);\n        options.srcCategories = options.categories = categories;\n\n        if ((definedMin || definedMax) && categories.length) {\n            var min = definedMin ? Math.floor(options.min) : 0;\n            var max;\n\n            if (definedMax) {\n                max = options.justified ? Math.floor(options.max) + 1 : Math.ceil(options.max);\n            } else {\n                max = categories.length;\n            }\n\n            options.categories = options.categories.slice(min, max);\n        }\n\n        return options;\n    };\n\n    CategoryAxis.prototype.rangeIndices = function rangeIndices () {\n        var options = this.options;\n        var length = options.categories.length || 1;\n        var min = isNumber(options.min) ? options.min % 1 : 0;\n        var max;\n\n        if (isNumber(options.max) && options.max % 1 !== 0 && options.max < this.totalRange().max) {\n            max = length - (1 - options.max % 1);\n        } else {\n            max = length - (options.justified ? 1 : 0);\n        }\n\n        return {\n            min: min,\n            max: max\n        };\n    };\n\n    CategoryAxis.prototype.totalRangeIndices = function totalRangeIndices (limit) {\n        var options = this.options;\n        var min = isNumber(options.min) ? options.min : 0;\n        var max;\n\n        if (isNumber(options.max)) {\n            max = options.max;\n        } else if (isNumber(options.min)) {\n            max = min + options.categories.length;\n        } else {\n            max = this.totalRange().max || 1;\n        }\n\n        if (limit) {\n            var totalRange = this.totalRange();\n            min = limitValue(min, 0, totalRange.max);\n            max = limitValue(max, 0, totalRange.max);\n        }\n\n        return {\n            min: min,\n            max: max\n        };\n    };\n\n    CategoryAxis.prototype.range = function range () {\n        var options = this.options;\n        var min = isNumber(options.min) ? options.min : 0;\n        var max = isNumber(options.max) ? options.max : this.totalRange().max;\n\n        return {\n            min: min,\n            max: max\n        };\n    };\n\n    CategoryAxis.prototype.roundedRange = function roundedRange () {\n        return this.range();\n    };\n\n    CategoryAxis.prototype.totalRange = function totalRange () {\n        var options = this.options;\n        return { min: 0, max: Math.max(this._seriesMax || 0, options.srcCategories.length) - (options.justified ? 1 : 0) };\n    };\n\n    CategoryAxis.prototype.scaleOptions = function scaleOptions () {\n        var ref = this.rangeIndices();\n        var min = ref.min;\n        var max = ref.max;\n        var lineBox = this.lineBox();\n        var size = this.options.vertical ? lineBox.height() : lineBox.width();\n        var scale = size / ((max - min) || 1);\n\n        return {\n            scale: scale * (this.options.reverse ? -1 : 1),\n            box: lineBox,\n            min: min,\n            max: max\n        };\n    };\n\n    CategoryAxis.prototype.arrangeLabels = function arrangeLabels () {\n        Axis.prototype.arrangeLabels.call(this);\n        this.hideOutOfRangeLabels();\n    };\n\n    CategoryAxis.prototype.hideOutOfRangeLabels = function hideOutOfRangeLabels () {\n        var ref = this;\n        var box = ref.box;\n        var labels = ref.labels;\n\n        if (labels.length > 0) {\n            var valueAxis = this.options.vertical ? Y : X;\n            var start = box[valueAxis + 1];\n            var end = box[valueAxis + 2];\n            var firstLabel = labels[0];\n            var lastLabel = last(labels);\n\n            if (firstLabel.box[valueAxis + 1] > end || firstLabel.box[valueAxis + 2] < start) {\n                firstLabel.options.visible = false;\n            }\n            if (lastLabel.box[valueAxis + 1] > end || lastLabel.box[valueAxis + 2] < start) {\n                lastLabel.options.visible = false;\n            }\n        }\n    };\n\n    CategoryAxis.prototype.getMajorTickPositions = function getMajorTickPositions () {\n        return this.getTicks().majorTicks;\n    };\n\n    CategoryAxis.prototype.getMinorTickPositions = function getMinorTickPositions () {\n        return this.getTicks().minorTicks;\n    };\n\n    CategoryAxis.prototype.getLabelsTickPositions = function getLabelsTickPositions () {\n        return this.getTicks().labelTicks;\n    };\n\n    CategoryAxis.prototype.tickIndices = function tickIndices (stepSize) {\n        var ref = this.rangeIndices();\n        var min = ref.min;\n        var max = ref.max;\n        var limit = Math.ceil(max);\n        var current = Math.floor(min);\n        var indices = [];\n\n        while (current <= limit) {\n            indices.push(current);\n            current += stepSize;\n        }\n\n        return indices;\n    };\n\n    CategoryAxis.prototype.getTickPositions = function getTickPositions (stepSize) {\n        var ref = this.options;\n        var vertical = ref.vertical;\n        var reverse = ref.reverse;\n        var ref$1 = this.scaleOptions();\n        var scale = ref$1.scale;\n        var box = ref$1.box;\n        var min = ref$1.min;\n        var pos = box[(vertical ? Y : X) + (reverse ? 2 : 1)];\n        var indices = this.tickIndices(stepSize);\n        var positions = [];\n\n        for (var idx = 0; idx < indices.length; idx++) {\n            positions.push(pos + round(scale * (indices[idx] - min), COORD_PRECISION));\n        }\n\n        return positions;\n    };\n\n    CategoryAxis.prototype.getTicks = function getTicks () {\n        var options = this.options;\n        var cache = this._ticks;\n        var range = this.rangeIndices();\n        var lineBox = this.lineBox();\n        var hash = lineBox.getHash() + range.min + \",\" + range.max + options.reverse + options.justified;\n\n        if (cache._hash !== hash) {\n            var hasMinor = options.minorTicks.visible || options.minorGridLines.visible;\n            cache._hash = hash;\n            cache.labelTicks = this.getTickPositions(1);\n            cache.majorTicks = this.filterOutOfRangePositions(cache.labelTicks, lineBox);\n            cache.minorTicks = hasMinor ? this.filterOutOfRangePositions(this.getTickPositions(0.5), lineBox) : [];\n        }\n\n        return cache;\n    };\n\n    CategoryAxis.prototype.filterOutOfRangePositions = function filterOutOfRangePositions (positions, lineBox) {\n        if (!positions.length) {\n            return positions;\n        }\n\n        var axis = this.options.vertical ? Y : X;\n        var inRange = function (position) { return lineBox[axis + 1] <= position && position <= lineBox[axis + 2]; };\n\n        var end = positions.length - 1;\n        var startIndex = 0;\n        while (!inRange(positions[startIndex]) && startIndex <= end) {\n            startIndex++;\n        }\n\n        var endIndex = end;\n\n        while (!inRange(positions[endIndex]) && endIndex >= 0) {\n            endIndex--;\n        }\n\n        return positions.slice(startIndex, endIndex + 1);\n    };\n\n    CategoryAxis.prototype.lineInfo = function lineInfo () {\n        var ref = this.options;\n        var vertical = ref.vertical;\n        var reverse = ref.reverse;\n        var lineBox = this.lineBox();\n        var lineSize = vertical ? lineBox.height() : lineBox.width();\n        var axis = vertical ? Y : X;\n        var axisDir = reverse ? -1 : 1;\n        var startEdge = axisDir === 1 ? 1 : 2;\n        var axisOrigin = axis + startEdge.toString();\n        var lineStart = lineBox[axisOrigin];\n\n        return {\n            axis: axis,\n            axisOrigin: axisOrigin,\n            axisDir: axisDir,\n            lineBox: lineBox,\n            lineSize: lineSize,\n            lineStart: lineStart\n        };\n    };\n\n    CategoryAxis.prototype.lineDir = function lineDir () {\n        /*\n         *  Category axis line direction:\n         *    * Vertical: down.\n         *    * Horizontal: right.\n         */\n\n        var ref = this.options;\n        var reverse = ref.reverse;\n        return reverse ? -1 : 1;\n    };\n\n    // TODO: Rename to slotBox, valueSlot, slotByIndex?\n    CategoryAxis.prototype.getSlot = function getSlot (from, to, limit) {\n        var options = this.options;\n        var reverse = options.reverse;\n        var justified = options.justified;\n        var ref = this.scaleOptions();\n        var scale = ref.scale;\n        var box = ref.box;\n        var min = ref.min;\n        var ref$1 = this.lineInfo();\n        var valueAxis = ref$1.axis;\n        var lineStart = ref$1.lineStart;\n\n        var slotBox = box.clone();\n        var singleSlot = !defined(to);\n\n        var start = valueOrDefault(from, 0);\n        var end = valueOrDefault(to, start);\n        end = Math.max(end - 1, start);\n\n        // Fixes transient bug caused by iOS 6.0 JIT\n        // (one can never be too sure)\n        end = Math.max(start, end);\n\n        var p1 = lineStart + (start - min) * scale;\n        var p2 = lineStart + (end + 1 - min) * scale;\n\n        if (singleSlot && justified) {\n            p2 = p1;\n        }\n\n        if (limit) {\n            p1 = limitValue(p1, box[valueAxis + 1], box[valueAxis + 2]);\n            p2 = limitValue(p2, box[valueAxis + 1], box[valueAxis + 2]);\n        }\n\n        slotBox[valueAxis + 1] = reverse ? p2 : p1;\n        slotBox[valueAxis + 2] = reverse ? p1 : p2;\n\n        return slotBox;\n    };\n\n    CategoryAxis.prototype.limitSlot = function limitSlot (slot) {\n        var vertical = this.options.vertical;\n        var valueAxis = vertical ? Y : X;\n        var lineBox = this.lineBox();\n        var limittedSlot = slot.clone();\n\n        limittedSlot[valueAxis + 1] = limitValue(slot[valueAxis + 1], lineBox[valueAxis + 1], lineBox[valueAxis + 2]);\n        limittedSlot[valueAxis + 2] = limitValue(slot[valueAxis + 2], lineBox[valueAxis + 1], lineBox[valueAxis + 2]);\n\n        return limittedSlot;\n    };\n\n    CategoryAxis.prototype.slot = function slot (from, to, limit) {\n        var min = Math.floor(this.options.min || 0);\n        var start = from;\n        var end = to;\n\n        if (typeof start === \"string\") {\n            start = this.categoryIndex(start);\n        } else if (isNumber(start)) {\n            start -= min;\n        }\n\n        if (typeof end === \"string\") {\n            end = this.categoryIndex(end);\n        } else if (isNumber(end)) {\n            end -= min;\n        }\n\n        return Axis.prototype.slot.call(this, start, end, limit);\n    };\n\n    CategoryAxis.prototype.pointCategoryIndex = function pointCategoryIndex (point) {\n        var ref = this.options;\n        var reverse = ref.reverse;\n        var justified = ref.justified;\n        var vertical = ref.vertical;\n        var valueAxis = vertical ? Y : X;\n        var ref$1 = this.scaleOptions();\n        var scale = ref$1.scale;\n        var box = ref$1.box;\n        var min = ref$1.min;\n        var max = ref$1.max;\n        var startValue = reverse ? max : min;\n        var lineStart = box[valueAxis + 1];\n        var lineEnd = box[valueAxis + 2];\n        var pos = point[valueAxis];\n\n        if (pos < lineStart || pos > lineEnd) {\n            return null;\n        }\n\n        var value = startValue + (pos - lineStart) / scale;\n        var diff = value % 1;\n\n        if (justified) {\n            value = Math.round(value);\n        } else if (diff === 0 && value > 0) {\n            value--;\n        }\n\n        return Math.floor(value);\n    };\n\n    CategoryAxis.prototype.getCategory = function getCategory (point) {\n        var index = this.pointCategoryIndex(point);\n\n        if (index === null) {\n            return null;\n        }\n\n        return this.options.categories[index];\n    };\n\n    CategoryAxis.prototype.categoryIndex = function categoryIndex (value) {\n        return this.totalIndex(value) - Math.floor(this.options.min || 0);\n    };\n\n    CategoryAxis.prototype.categoryAt = function categoryAt (index, total) {\n        var options = this.options;\n\n        return (total ? options.srcCategories : options.categories)[index];\n    };\n\n    CategoryAxis.prototype.categoriesCount = function categoriesCount () {\n        return (this.options.categories || []).length;\n    };\n\n    CategoryAxis.prototype.translateRange = function translateRange (delta) {\n        var options = this.options;\n        var lineBox = this.lineBox();\n        var size = options.vertical ? lineBox.height() : lineBox.width();\n        var range = options.categories.length;\n        var scale = size / range;\n        var offset = round(delta / scale, DEFAULT_PRECISION);\n\n        return {\n            min: offset,\n            max: range + offset\n        };\n    };\n\n    CategoryAxis.prototype.scaleRange = function scaleRange (scale, cursor) {\n        var position = Math.abs(this.pointOffset(cursor));\n        var rangeIndices = this.totalRangeIndices();\n        var range = rangeIndices.max - rangeIndices.min;\n        var delta = this.scaleToDelta(scale, range);\n        var minDelta = position * delta;\n        var maxDelta = (1 - position) * delta;\n        var min = rangeIndices.min + minDelta;\n        var max = rangeIndices.max - maxDelta;\n\n        if (max - min < MIN_CATEGORY_RANGE) {\n            max = min + MIN_CATEGORY_RANGE;\n        }\n\n        return {\n            min: min,\n            max: max\n        };\n    };\n\n    CategoryAxis.prototype.zoomRange = function zoomRange (scale, cursor) {\n        var ref = this.totalRange();\n        var totalMin = ref.min;\n        var totalMax = ref.max;\n        var range = this.scaleRange(scale, cursor);\n\n        return {\n            min: limitValue(range.min, totalMin, totalMax),\n            max: limitValue(range.max, totalMin, totalMax)\n        };\n    };\n\n    CategoryAxis.prototype.labelsCount = function labelsCount () {\n        var labelsRange = this.labelsRange();\n\n        return labelsRange.max - labelsRange.min;\n    };\n\n    CategoryAxis.prototype.labelsRange = function labelsRange () {\n        var options = this.options;\n        var justified = options.justified;\n        var labelOptions = options.labels;\n        var ref = this.totalRangeIndices(true);\n        var min = ref.min;\n        var max = ref.max;\n        var start = Math.floor(min);\n\n        if (!justified) {\n            min = Math.floor(min);\n            max = Math.ceil(max);\n        } else {\n            min = Math.ceil(min);\n            max = Math.floor(max);\n        }\n\n        var skip;\n\n        if (min > labelOptions.skip) {\n            skip = labelOptions.skip + labelOptions.step * Math.ceil((min - labelOptions.skip) / labelOptions.step);\n        } else {\n            skip = labelOptions.skip;\n        }\n\n        return {\n            min: skip - start,\n            max: (options.categories.length ? max + (justified ? 1 : 0) : 0) - start\n        };\n    };\n\n    CategoryAxis.prototype.createAxisLabel = function createAxisLabel (index, labelOptions, labelContext) {\n        var options = this.options;\n        var dataItem = options.dataItems ? options.dataItems[index] : null;\n        var category = valueOrDefault(options.categories[index], \"\");\n\n        labelContext.dataItem = dataItem;\n        var text = this.axisLabelText(category, labelOptions, labelContext);\n\n        return new AxisLabel(category, text, index, dataItem, labelOptions);\n    };\n\n    CategoryAxis.prototype.shouldRenderNote = function shouldRenderNote (value) {\n        var range = this.totalRangeIndices();\n\n        return Math.floor(range.min) <= value && value <= Math.ceil(range.max);\n    };\n\n    CategoryAxis.prototype.noteSlot = function noteSlot (value) {\n        var options = this.options;\n        var index = value - Math.floor(options.min || 0);\n        return this.getSlot(index);\n    };\n\n    CategoryAxis.prototype.arrangeNotes = function arrangeNotes () {\n        Axis.prototype.arrangeNotes.call(this);\n        this.hideOutOfRangeNotes();\n    };\n\n    CategoryAxis.prototype.hideOutOfRangeNotes = function hideOutOfRangeNotes () {\n        var ref = this;\n        var notes = ref.notes;\n        var box = ref.box;\n        if (notes && notes.length) {\n            var valueAxis = this.options.vertical ? Y : X;\n            var start = box[valueAxis + 1];\n            var end = box[valueAxis + 2];\n\n            for (var idx = 0; idx < notes.length; idx++) {\n                var note = notes[idx];\n                if (note.box && (end < note.box[valueAxis + 1] || note.box[valueAxis + 2] < start)) {\n                    note.hide();\n                }\n            }\n        }\n    };\n\n    CategoryAxis.prototype.pan = function pan (delta) {\n        var range = this.totalRangeIndices(true);\n        var ref = this.scaleOptions();\n        var scale = ref.scale;\n        var offset = round(delta / scale, DEFAULT_PRECISION);\n        var totalRange = this.totalRange();\n        var min = range.min + offset;\n        var max = range.max + offset;\n\n        return this.limitRange(min, max, 0, totalRange.max, offset);\n    };\n\n    CategoryAxis.prototype.pointsRange = function pointsRange (start, end) {\n        var ref = this.options;\n        var reverse = ref.reverse;\n        var vertical = ref.vertical;\n        var valueAxis = vertical ? Y : X;\n        var range = this.totalRangeIndices(true);\n        var ref$1 = this.scaleOptions();\n        var scale = ref$1.scale;\n        var box = ref$1.box;\n        var lineStart = box[valueAxis + (reverse ? 2 : 1)];\n\n        var diffStart = start[valueAxis] - lineStart;\n        var diffEnd = end[valueAxis] - lineStart;\n\n        var min = range.min + diffStart / scale;\n        var max = range.min + diffEnd / scale;\n        var rangeMin = Math.min(min, max);\n        var rangeMax = Math.max(min, max);\n\n        if (rangeMax - rangeMin >= MIN_CATEGORY_POINTS_RANGE) {\n            return {\n                min: rangeMin,\n                max: rangeMax\n            };\n        }\n    };\n\n    CategoryAxis.prototype.valueRange = function valueRange () {\n        return this.range();\n    };\n\n    CategoryAxis.prototype.totalIndex = function totalIndex (value) {\n        var options = this.options;\n        var index = this._categoriesMap ?\n            this._categoriesMap.get(value) : indexOf(value, options.srcCategories);\n\n        return index;\n    };\n\n    CategoryAxis.prototype.currentRangeIndices = function currentRangeIndices () {\n        var options = this.options;\n        var min = 0;\n\n        if (isNumber(options.min)) {\n            min = Math.floor(options.min);\n        }\n\n        var max;\n        if (isNumber(options.max)) {\n            max = options.justified ? Math.floor(options.max) : Math.ceil(options.max) - 1;\n        } else {\n            max = this.totalCount() - 1;\n        }\n\n        return {\n            min: min,\n            max: max\n        };\n    };\n\n    CategoryAxis.prototype.mapCategories = function mapCategories () {\n        if (!this._categoriesMap) {\n            var map = this._categoriesMap = new HashMap();\n            var srcCategories = this.options.srcCategories;\n            for (var idx = 0; idx < srcCategories.length; idx++) {\n                map.set(srcCategories[idx], idx);\n            }\n        }\n    };\n\n    CategoryAxis.prototype.totalCount = function totalCount () {\n        return Math.max(this.options.srcCategories.length, this._seriesMax || 0);\n    };\n\n    return CategoryAxis;\n}(Axis));\n\nsetDefaultOptions(CategoryAxis, {\n    type: \"category\",\n    vertical: false,\n    majorGridLines: {\n        visible: false,\n        width: 1,\n        color: BLACK\n    },\n    labels: {\n        zIndex: 1\n    },\n    justified: false,\n    _deferLabels: true\n});\n\nexport default CategoryAxis;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}