{"ast":null,"code":"import { drawing as draw, geometry } from '@progress/kendo-drawing';\nimport PieSegment from './pie-segment';\nimport PieChartMixin from '../mixins/pie-chart-mixin';\nimport { ChartElement, Ring, Box, Point } from '../../core';\nimport { OUTSIDE_END, FADEIN, COLUMN } from '../constants';\nimport { bindSegments, evalOptions } from '../utils';\nimport { CIRCLE, RIGHT, CENTER } from '../../common/constants';\nimport { deepExtend, defined, find, isFunction, last, round, setDefaultOptions, valueOrDefault } from '../../common';\nvar PIE_SECTOR_ANIM_DELAY = 70;\nvar PieChart = function (ChartElement) {\n  function PieChart(plotArea, options) {\n    ChartElement.call(this, options);\n    this.plotArea = plotArea;\n    this.chartService = plotArea.chartService;\n    this.points = [];\n    this.legendItems = [];\n    this.render();\n  }\n  if (ChartElement) PieChart.__proto__ = ChartElement;\n  PieChart.prototype = Object.create(ChartElement && ChartElement.prototype);\n  PieChart.prototype.constructor = PieChart;\n  PieChart.prototype.render = function render() {\n    this.traverseDataPoints(this.addValue.bind(this));\n  };\n  PieChart.prototype.traverseDataPoints = function traverseDataPoints(callback) {\n    var this$1 = this;\n    var ref = this;\n    var options = ref.options;\n    var seriesColors = ref.plotArea.options.seriesColors;\n    if (seriesColors === void 0) seriesColors = [];\n    var colorsCount = seriesColors.length;\n    var series = options.series;\n    var seriesCount = series.length;\n    for (var seriesIx = 0; seriesIx < seriesCount; seriesIx++) {\n      var currentSeries = series[seriesIx];\n      var data = currentSeries.data;\n      var ref$1 = bindSegments(currentSeries);\n      var total = ref$1.total;\n      var points = ref$1.points;\n      var count = ref$1.count;\n      var anglePerValue = 360 / total;\n      var constantAngle = void 0;\n      if (!isFinite(anglePerValue)) {\n        constantAngle = 360 / count;\n      }\n      var currentAngle = void 0;\n      if (defined(currentSeries.startAngle)) {\n        currentAngle = currentSeries.startAngle;\n      } else {\n        currentAngle = options.startAngle;\n      }\n      if (seriesIx !== seriesCount - 1) {\n        if (currentSeries.labels.position === OUTSIDE_END) {\n          currentSeries.labels.position = CENTER;\n        }\n      }\n      for (var i = 0; i < points.length; i++) {\n        var pointData = points[i];\n        if (!pointData) {\n          continue;\n        }\n        var fields = pointData.fields;\n        var value = pointData.value;\n        var visible = pointData.visible;\n        var angle = value !== 0 ? constantAngle || value * anglePerValue : 0;\n        var explode = data.length !== 1 && Boolean(fields.explode);\n        if (!isFunction(currentSeries.color)) {\n          currentSeries.color = fields.color || seriesColors[i % colorsCount];\n        }\n        callback(value, new Ring(null, 0, 0, currentAngle, angle), {\n          owner: this$1,\n          category: defined(fields.category) ? fields.category : \"\",\n          index: i,\n          series: currentSeries,\n          seriesIx: seriesIx,\n          dataItem: data[i],\n          percentage: total !== 0 ? value / total : 0,\n          explode: explode,\n          visibleInLegend: fields.visibleInLegend,\n          visible: visible,\n          zIndex: seriesCount - seriesIx,\n          animationDelay: this$1.animationDelay(i, seriesIx, seriesCount)\n        });\n        if (visible !== false) {\n          currentAngle += angle;\n        }\n      }\n    }\n  };\n  PieChart.prototype.evalSegmentOptions = function evalSegmentOptions(options, value, fields) {\n    var series = fields.series;\n    evalOptions(options, {\n      value: value,\n      series: series,\n      dataItem: fields.dataItem,\n      category: fields.category,\n      percentage: fields.percentage\n    }, {\n      defaults: series._defaults,\n      excluded: [\"data\", \"content\", \"template\", \"visual\", \"toggle\"]\n    });\n  };\n  PieChart.prototype.addValue = function addValue(value, sector, fields) {\n    var segmentOptions = deepExtend({}, fields.series, {\n      index: fields.index\n    });\n    this.evalSegmentOptions(segmentOptions, value, fields);\n    this.createLegendItem(value, segmentOptions, fields);\n    if (fields.visible === false) {\n      return;\n    }\n    var segment = new PieSegment(value, sector, segmentOptions);\n    Object.assign(segment, fields);\n    this.append(segment);\n    this.points.push(segment);\n  };\n  PieChart.prototype.reflow = function reflow(targetBox) {\n    var ref = this;\n    var options = ref.options;\n    var points = ref.points;\n    var seriesConfigs = ref.seriesConfigs;\n    if (seriesConfigs === void 0) seriesConfigs = [];\n    var count = points.length;\n    var box = targetBox.clone();\n    var space = 5;\n    var minWidth = Math.min(box.width(), box.height());\n    var halfMinWidth = minWidth / 2;\n    var defaultPadding = minWidth - minWidth * 0.85;\n    var newBox = new Box(box.x1, box.y1, box.x1 + minWidth, box.y1 + minWidth);\n    var newBoxCenter = newBox.center();\n    var boxCenter = box.center();\n    var seriesCount = options.series.length;\n    var leftSideLabels = [];\n    var rightSideLabels = [];\n    var padding = valueOrDefault(options.padding, defaultPadding);\n    this.targetBox = targetBox;\n    padding = padding > halfMinWidth - space ? halfMinWidth - space : padding;\n    newBox.translate(boxCenter.x - newBoxCenter.x, boxCenter.y - newBoxCenter.y);\n    var radius = halfMinWidth - padding;\n    var center = new Point(radius + newBox.x1 + padding, radius + newBox.y1 + padding);\n    for (var i = 0; i < count; i++) {\n      var segment = points[i];\n      var sector = segment.sector;\n      var seriesIndex = segment.seriesIx;\n      sector.radius = radius;\n      sector.center = center;\n      if (seriesConfigs.length) {\n        var seriesConfig = seriesConfigs[seriesIndex];\n        sector.innerRadius = seriesConfig.innerRadius;\n        sector.radius = seriesConfig.radius;\n      }\n      if (seriesIndex === seriesCount - 1 && segment.explode) {\n        sector.center = sector.clone().setRadius(sector.radius * 0.15).point(sector.middle());\n      }\n      segment.reflow(newBox);\n      var label = segment.label;\n      if (label) {\n        if (label.options.position === OUTSIDE_END) {\n          if (seriesIndex === seriesCount - 1) {\n            if (label.orientation === RIGHT) {\n              rightSideLabels.push(label);\n            } else {\n              leftSideLabels.push(label);\n            }\n          }\n        }\n      }\n    }\n    if (leftSideLabels.length > 0) {\n      leftSideLabels.sort(this.labelComparator(true));\n      this.leftLabelsReflow(leftSideLabels);\n    }\n    if (rightSideLabels.length > 0) {\n      rightSideLabels.sort(this.labelComparator(false));\n      this.rightLabelsReflow(rightSideLabels);\n    }\n    this.box = newBox;\n  };\n  PieChart.prototype.leftLabelsReflow = function leftLabelsReflow(labels) {\n    var distances = this.distanceBetweenLabels(labels);\n    this.distributeLabels(distances, labels);\n  };\n  PieChart.prototype.rightLabelsReflow = function rightLabelsReflow(labels) {\n    var distances = this.distanceBetweenLabels(labels);\n    this.distributeLabels(distances, labels);\n  };\n  PieChart.prototype.distanceBetweenLabels = function distanceBetweenLabels(labels) {\n    var segment = last(this.points);\n    var sector = segment.sector;\n    var count = labels.length - 1;\n    var lr = sector.radius + segment.options.labels.distance;\n    var distances = [];\n    var firstBox = labels[0].box;\n    var distance = round(firstBox.y1 - (sector.center.y - lr - firstBox.height() - firstBox.height() / 2));\n    distances.push(distance);\n    for (var i = 0; i < count; i++) {\n      var secondBox = labels[i + 1].box;\n      firstBox = labels[i].box;\n      distance = round(secondBox.y1 - firstBox.y2);\n      distances.push(distance);\n    }\n    distance = round(sector.center.y + lr - labels[count].box.y2 - labels[count].box.height() / 2);\n    distances.push(distance);\n    return distances;\n  };\n  PieChart.prototype.distributeLabels = function distributeLabels(distances, labels) {\n    var this$1 = this;\n    var count = distances.length;\n    var left, right, remaining;\n    for (var i = 0; i < count; i++) {\n      remaining = -distances[i];\n      left = right = i;\n      while (remaining > 0 && (left >= 0 || right < count)) {\n        remaining = this$1._takeDistance(distances, i, --left, remaining);\n        remaining = this$1._takeDistance(distances, i, ++right, remaining);\n      }\n    }\n    this.reflowLabels(distances, labels);\n  };\n  PieChart.prototype._takeDistance = function _takeDistance(distances, anchor, position, amount) {\n    var result = amount;\n    if (distances[position] > 0) {\n      var available = Math.min(distances[position], result);\n      result -= available;\n      distances[position] -= available;\n      distances[anchor] += available;\n    }\n    return result;\n  };\n  PieChart.prototype.reflowLabels = function reflowLabels(distances, labels) {\n    var this$1 = this;\n    var segment = last(this.points);\n    var sector = segment.sector;\n    var labelOptions = segment.options.labels;\n    var labelsCount = labels.length;\n    var labelDistance = labelOptions.distance;\n    var boxY = sector.center.y - (sector.radius + labelDistance) - labels[0].box.height();\n    var boxX;\n    distances[0] += 2;\n    for (var i = 0; i < labelsCount; i++) {\n      var label = labels[i];\n      var box = label.box;\n      boxY += distances[i];\n      boxX = this$1.hAlignLabel(box.x2, sector.clone().expand(labelDistance), boxY, boxY + box.height(), label.orientation === RIGHT);\n      if (label.orientation === RIGHT) {\n        if (labelOptions.align !== CIRCLE) {\n          boxX = sector.radius + sector.center.x + labelDistance;\n        }\n        label.reflow(new Box(boxX + box.width(), boxY, boxX, boxY));\n      } else {\n        if (labelOptions.align !== CIRCLE) {\n          boxX = sector.center.x - sector.radius - labelDistance;\n        }\n        label.reflow(new Box(boxX - box.width(), boxY, boxX, boxY));\n      }\n      boxY += box.height();\n    }\n  };\n  PieChart.prototype.createVisual = function createVisual() {\n    var this$1 = this;\n    var ref = this;\n    var connectors = ref.options.connectors;\n    var points = ref.points;\n    var count = points.length;\n    var space = 4;\n    ChartElement.prototype.createVisual.call(this);\n    this._connectorLines = [];\n    for (var i = 0; i < count; i++) {\n      var segment = points[i];\n      var sector = segment.sector;\n      var label = segment.label;\n      var angle = sector.middle();\n      var connectorsColor = (segment.options.connectors || {}).color || connectors.color;\n      if (label) {\n        var connectorLine = new draw.Path({\n          stroke: {\n            color: connectorsColor,\n            width: connectors.width\n          },\n          animation: {\n            type: FADEIN,\n            delay: segment.animationDelay\n          }\n        });\n        if (label.options.position === OUTSIDE_END) {\n          var box = label.box;\n          var centerPoint = sector.center;\n          var start = sector.point(angle);\n          var middle = new Point(box.x1, box.center().y);\n          var sr = void 0,\n            end = void 0,\n            crossing = void 0;\n          start = sector.clone().expand(connectors.padding).point(angle);\n          connectorLine.moveTo(start.x, start.y);\n          // TODO: Extract into a method to remove duplication\n          if (label.orientation === RIGHT) {\n            end = new Point(box.x1 - connectors.padding, box.center().y);\n            crossing = intersection(centerPoint, start, middle, end);\n            middle = new Point(end.x - space, end.y);\n            crossing = crossing || middle;\n            crossing.x = Math.min(crossing.x, middle.x);\n            if (this$1.pointInCircle(crossing, sector.center, sector.radius + space) || crossing.x < sector.center.x) {\n              sr = sector.center.x + sector.radius + space;\n              if (segment.options.labels.align !== COLUMN) {\n                if (sr < middle.x) {\n                  connectorLine.lineTo(sr, start.y);\n                } else {\n                  connectorLine.lineTo(start.x + space * 2, start.y);\n                }\n              } else {\n                connectorLine.lineTo(sr, start.y);\n              }\n              connectorLine.lineTo(middle.x, end.y);\n            } else {\n              crossing.y = end.y;\n              connectorLine.lineTo(crossing.x, crossing.y);\n            }\n          } else {\n            end = new Point(box.x2 + connectors.padding, box.center().y);\n            crossing = intersection(centerPoint, start, middle, end);\n            middle = new Point(end.x + space, end.y);\n            crossing = crossing || middle;\n            crossing.x = Math.max(crossing.x, middle.x);\n            if (this$1.pointInCircle(crossing, sector.center, sector.radius + space) || crossing.x > sector.center.x) {\n              sr = sector.center.x - sector.radius - space;\n              if (segment.options.labels.align !== COLUMN) {\n                if (sr > middle.x) {\n                  connectorLine.lineTo(sr, start.y);\n                } else {\n                  connectorLine.lineTo(start.x - space * 2, start.y);\n                }\n              } else {\n                connectorLine.lineTo(sr, start.y);\n              }\n              connectorLine.lineTo(middle.x, end.y);\n            } else {\n              crossing.y = end.y;\n              connectorLine.lineTo(crossing.x, crossing.y);\n            }\n          }\n          connectorLine.lineTo(end.x, end.y);\n          this$1._connectorLines.push(connectorLine);\n          this$1.visual.append(connectorLine);\n        }\n      }\n    }\n  };\n  PieChart.prototype.renderVisual = function renderVisual() {\n    ChartElement.prototype.renderVisual.call(this);\n    if (find(this.options.series, function (options) {\n      return options.autoFit;\n    })) {\n      var targetBox = this.targetBox;\n      var pieCenter = this.box.center();\n      var bbox = this.visual.bbox();\n      if (!bbox) {\n        return;\n      }\n      var bboxBottom = bbox.bottomRight();\n      var scale = Math.min((pieCenter.y - targetBox.y1) / (pieCenter.y - bbox.origin.y), (targetBox.y2 - pieCenter.y) / (bboxBottom.y - pieCenter.y), (pieCenter.x - targetBox.x1) / (pieCenter.x - bbox.origin.x), (targetBox.x2 - pieCenter.x) / (bboxBottom.x - pieCenter.x));\n      if (scale < 1) {\n        this.visual.transform(geometry.transform().scale(scale, scale, [pieCenter.x, pieCenter.y]));\n      }\n    }\n  };\n  PieChart.prototype.labelComparator = function labelComparator(reverse) {\n    var reverseValue = reverse ? -1 : 1;\n    return function (a, b) {\n      var first = (a.parent.sector.middle() + 270) % 360;\n      var second = (b.parent.sector.middle() + 270) % 360;\n      return (first - second) * reverseValue;\n    };\n  };\n  PieChart.prototype.hAlignLabel = function hAlignLabel(originalX, sector, y1, y2, direction) {\n    var radius = sector.radius;\n    var sector_center = sector.center;\n    var cx = sector_center.x;\n    var cy = sector_center.y;\n    var t = Math.min(Math.abs(cy - y1), Math.abs(cy - y2));\n    if (t > radius) {\n      return originalX;\n    }\n    return cx + Math.sqrt(radius * radius - t * t) * (direction ? 1 : -1);\n  };\n  PieChart.prototype.pointInCircle = function pointInCircle(point, center, radius) {\n    return Math.pow(center.x - point.x, 2) + Math.pow(center.y - point.y, 2) < Math.pow(radius, 2);\n  };\n  PieChart.prototype.formatPointValue = function formatPointValue(point, format) {\n    return this.chartService.format.auto(format, point.value);\n  };\n  PieChart.prototype.animationDelay = function animationDelay(categoryIndex) {\n    return categoryIndex * PIE_SECTOR_ANIM_DELAY;\n  };\n  PieChart.prototype.stackRoot = function stackRoot() {\n    return this;\n  };\n  return PieChart;\n}(ChartElement);\nfunction intersection(a1, a2, b1, b2) {\n  var uat = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);\n  var ub = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);\n  var result;\n  if (ub !== 0) {\n    var ua = uat / ub;\n    result = new Point(a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y));\n  }\n  return result;\n}\nsetDefaultOptions(PieChart, {\n  startAngle: 90,\n  connectors: {\n    width: 2,\n    color: \"#939393\",\n    padding: 8\n  },\n  inactiveItems: {\n    markers: {},\n    labels: {}\n  }\n});\ndeepExtend(PieChart.prototype, PieChartMixin);\nPieChart.prototype.isStackRoot = true;\nexport default PieChart;","map":{"version":3,"names":["drawing","draw","geometry","PieSegment","PieChartMixin","ChartElement","Ring","Box","Point","OUTSIDE_END","FADEIN","COLUMN","bindSegments","evalOptions","CIRCLE","RIGHT","CENTER","deepExtend","defined","find","isFunction","last","round","setDefaultOptions","valueOrDefault","PIE_SECTOR_ANIM_DELAY","PieChart","plotArea","options","call","chartService","points","legendItems","render","__proto__","prototype","Object","create","constructor","traverseDataPoints","addValue","bind","callback","this$1","ref","seriesColors","colorsCount","length","series","seriesCount","seriesIx","currentSeries","data","ref$1","total","count","anglePerValue","constantAngle","isFinite","currentAngle","startAngle","labels","position","i","pointData","fields","value","visible","angle","explode","Boolean","color","owner","category","index","dataItem","percentage","visibleInLegend","zIndex","animationDelay","evalSegmentOptions","defaults","_defaults","excluded","sector","segmentOptions","createLegendItem","segment","assign","append","push","reflow","targetBox","seriesConfigs","box","clone","space","minWidth","Math","min","width","height","halfMinWidth","defaultPadding","newBox","x1","y1","newBoxCenter","center","boxCenter","leftSideLabels","rightSideLabels","padding","translate","x","y","radius","seriesIndex","seriesConfig","innerRadius","setRadius","point","middle","label","orientation","sort","labelComparator","leftLabelsReflow","rightLabelsReflow","distances","distanceBetweenLabels","distributeLabels","lr","distance","firstBox","secondBox","y2","left","right","remaining","_takeDistance","reflowLabels","anchor","amount","result","available","labelOptions","labelsCount","labelDistance","boxY","boxX","hAlignLabel","x2","expand","align","createVisual","connectors","_connectorLines","connectorsColor","connectorLine","Path","stroke","animation","type","delay","centerPoint","start","sr","end","crossing","moveTo","intersection","pointInCircle","lineTo","max","visual","renderVisual","autoFit","pieCenter","bbox","bboxBottom","bottomRight","scale","origin","transform","reverse","reverseValue","a","b","first","parent","second","originalX","direction","sector_center","cx","cy","t","abs","sqrt","pow","formatPointValue","format","auto","categoryIndex","stackRoot","a1","a2","b1","b2","uat","ub","ua","inactiveItems","markers","isStackRoot"],"sources":["C:/Users/Павел/Desktop/react humster/my-app/node_modules/@progress/kendo-charts/dist/es/chart/pie-chart/pie-chart.js"],"sourcesContent":["import { drawing as draw, geometry } from '@progress/kendo-drawing';\n\nimport PieSegment from './pie-segment';\nimport PieChartMixin from '../mixins/pie-chart-mixin';\nimport { ChartElement, Ring, Box, Point } from '../../core';\n\nimport { OUTSIDE_END, FADEIN, COLUMN } from '../constants';\nimport { bindSegments, evalOptions } from '../utils';\n\nimport { CIRCLE, RIGHT, CENTER } from '../../common/constants';\nimport { deepExtend, defined, find, isFunction, last, round, setDefaultOptions, valueOrDefault } from '../../common';\n\nvar PIE_SECTOR_ANIM_DELAY = 70;\n\nvar PieChart = (function (ChartElement) {\n    function PieChart(plotArea, options) {\n        ChartElement.call(this, options);\n\n        this.plotArea = plotArea;\n        this.chartService = plotArea.chartService;\n        this.points = [];\n        this.legendItems = [];\n        this.render();\n    }\n\n    if ( ChartElement ) PieChart.__proto__ = ChartElement;\n    PieChart.prototype = Object.create( ChartElement && ChartElement.prototype );\n    PieChart.prototype.constructor = PieChart;\n\n    PieChart.prototype.render = function render () {\n        this.traverseDataPoints(this.addValue.bind(this));\n    };\n\n    PieChart.prototype.traverseDataPoints = function traverseDataPoints (callback) {\n        var this$1 = this;\n\n        var ref = this;\n        var options = ref.options;\n        var seriesColors = ref.plotArea.options.seriesColors; if ( seriesColors === void 0 ) seriesColors = [];\n        var colorsCount = seriesColors.length;\n        var series = options.series;\n        var seriesCount = series.length;\n\n        for (var seriesIx = 0; seriesIx < seriesCount; seriesIx++) {\n            var currentSeries = series[seriesIx];\n            var data = currentSeries.data;\n            var ref$1 = bindSegments(currentSeries);\n            var total = ref$1.total;\n            var points = ref$1.points;\n            var count = ref$1.count;\n            var anglePerValue = 360 / total;\n            var constantAngle = (void 0);\n            if (!isFinite(anglePerValue)) {\n                constantAngle = 360 / count;\n            }\n            var currentAngle = (void 0);\n\n            if (defined(currentSeries.startAngle)) {\n                currentAngle = currentSeries.startAngle;\n            } else {\n                currentAngle = options.startAngle;\n            }\n\n            if (seriesIx !== seriesCount - 1) {\n                if (currentSeries.labels.position === OUTSIDE_END) {\n                    currentSeries.labels.position = CENTER;\n                }\n            }\n\n            for (var i = 0; i < points.length; i++) {\n                var pointData = points[i];\n                if (!pointData) {\n                    continue;\n                }\n\n                var fields = pointData.fields;\n                var value = pointData.value;\n                var visible = pointData.visible;\n                var angle = value !== 0 ? (constantAngle || (value * anglePerValue)) : 0;\n                var explode = data.length !== 1 && Boolean(fields.explode);\n\n                if (!isFunction(currentSeries.color)) {\n                    currentSeries.color = fields.color || seriesColors[i % colorsCount];\n                }\n\n                callback(value, new Ring(null, 0, 0, currentAngle, angle), {\n                    owner: this$1,\n                    category: defined(fields.category) ? fields.category : \"\",\n                    index: i,\n                    series: currentSeries,\n                    seriesIx: seriesIx,\n                    dataItem: data[i],\n                    percentage: total !== 0 ? value / total : 0,\n                    explode: explode,\n                    visibleInLegend: fields.visibleInLegend,\n                    visible: visible,\n                    zIndex: seriesCount - seriesIx,\n                    animationDelay: this$1.animationDelay(i, seriesIx, seriesCount)\n                });\n\n                if (visible !== false) {\n                    currentAngle += angle;\n                }\n            }\n        }\n    };\n\n    PieChart.prototype.evalSegmentOptions = function evalSegmentOptions (options, value, fields) {\n        var series = fields.series;\n\n        evalOptions(options, {\n            value: value,\n            series: series,\n            dataItem: fields.dataItem,\n            category: fields.category,\n            percentage: fields.percentage\n        }, { defaults: series._defaults, excluded: [ \"data\", \"content\", \"template\", \"visual\", \"toggle\" ] });\n    };\n\n    PieChart.prototype.addValue = function addValue (value, sector, fields) {\n        var segmentOptions = deepExtend({}, fields.series, { index: fields.index });\n        this.evalSegmentOptions(segmentOptions, value, fields);\n\n        this.createLegendItem(value, segmentOptions, fields);\n\n        if (fields.visible === false) {\n            return;\n        }\n\n        var segment = new PieSegment(value, sector, segmentOptions);\n        Object.assign(segment, fields);\n        this.append(segment);\n        this.points.push(segment);\n    };\n\n    PieChart.prototype.reflow = function reflow (targetBox) {\n        var ref = this;\n        var options = ref.options;\n        var points = ref.points;\n        var seriesConfigs = ref.seriesConfigs; if ( seriesConfigs === void 0 ) seriesConfigs = [];\n        var count = points.length;\n        var box = targetBox.clone();\n        var space = 5;\n        var minWidth = Math.min(box.width(), box.height());\n        var halfMinWidth = minWidth / 2;\n        var defaultPadding = minWidth - minWidth * 0.85;\n        var newBox = new Box(box.x1, box.y1, box.x1 + minWidth, box.y1 + minWidth);\n        var newBoxCenter = newBox.center();\n        var boxCenter = box.center();\n        var seriesCount = options.series.length;\n        var leftSideLabels = [];\n        var rightSideLabels = [];\n        var padding = valueOrDefault(options.padding, defaultPadding);\n\n        this.targetBox = targetBox;\n\n        padding = padding > halfMinWidth - space ? halfMinWidth - space : padding;\n        newBox.translate(boxCenter.x - newBoxCenter.x, boxCenter.y - newBoxCenter.y);\n\n        var radius = halfMinWidth - padding;\n        var center = new Point(\n            radius + newBox.x1 + padding,\n            radius + newBox.y1 + padding\n        );\n\n        for (var i = 0; i < count; i++) {\n            var segment = points[i];\n            var sector = segment.sector;\n            var seriesIndex = segment.seriesIx;\n            sector.radius = radius;\n            sector.center = center;\n\n            if (seriesConfigs.length) {\n                var seriesConfig = seriesConfigs[seriesIndex];\n                sector.innerRadius = seriesConfig.innerRadius;\n                sector.radius = seriesConfig.radius;\n            }\n\n            if (seriesIndex === seriesCount - 1 && segment.explode) {\n                sector.center = sector.clone().setRadius(sector.radius * 0.15).point(sector.middle());\n            }\n\n            segment.reflow(newBox);\n\n            var label = segment.label;\n            if (label) {\n                if (label.options.position === OUTSIDE_END) {\n                    if (seriesIndex === seriesCount - 1) {\n                        if (label.orientation === RIGHT) {\n                            rightSideLabels.push(label);\n                        } else {\n                            leftSideLabels.push(label);\n                        }\n                    }\n                }\n            }\n        }\n\n        if (leftSideLabels.length > 0) {\n            leftSideLabels.sort(this.labelComparator(true));\n            this.leftLabelsReflow(leftSideLabels);\n        }\n\n        if (rightSideLabels.length > 0) {\n            rightSideLabels.sort(this.labelComparator(false));\n            this.rightLabelsReflow(rightSideLabels);\n        }\n\n        this.box = newBox;\n    };\n\n    PieChart.prototype.leftLabelsReflow = function leftLabelsReflow (labels) {\n        var distances = this.distanceBetweenLabels(labels);\n\n        this.distributeLabels(distances, labels);\n    };\n\n    PieChart.prototype.rightLabelsReflow = function rightLabelsReflow (labels) {\n        var distances = this.distanceBetweenLabels(labels);\n\n        this.distributeLabels(distances, labels);\n    };\n\n    PieChart.prototype.distanceBetweenLabels = function distanceBetweenLabels (labels) {\n        var segment = last(this.points);\n        var sector = segment.sector;\n        var count = labels.length - 1;\n        var lr = sector.radius + segment.options.labels.distance;\n        var distances = [];\n        var firstBox = labels[0].box;\n        var distance = round(firstBox.y1 - (sector.center.y - lr - firstBox.height() - firstBox.height() / 2));\n\n        distances.push(distance);\n\n        for (var i = 0; i < count; i++) {\n            var secondBox = labels[i + 1].box;\n\n            firstBox = labels[i].box;\n            distance = round(secondBox.y1 - firstBox.y2);\n            distances.push(distance);\n        }\n        distance = round(sector.center.y + lr - labels[count].box.y2 - labels[count].box.height() / 2);\n        distances.push(distance);\n\n        return distances;\n    };\n\n    PieChart.prototype.distributeLabels = function distributeLabels (distances, labels) {\n        var this$1 = this;\n\n        var count = distances.length;\n        var left, right, remaining;\n\n        for (var i = 0; i < count; i++) {\n            remaining = -distances[i];\n            left = right = i;\n\n            while (remaining > 0 && (left >= 0 || right < count)) {\n                remaining = this$1._takeDistance(distances, i, --left, remaining);\n                remaining = this$1._takeDistance(distances, i, ++right, remaining);\n            }\n        }\n\n        this.reflowLabels(distances, labels);\n    };\n\n    PieChart.prototype._takeDistance = function _takeDistance (distances, anchor, position, amount) {\n        var result = amount;\n        if (distances[position] > 0) {\n            var available = Math.min(distances[position], result);\n            result -= available;\n            distances[position] -= available;\n            distances[anchor] += available;\n        }\n\n        return result;\n    };\n\n    PieChart.prototype.reflowLabels = function reflowLabels (distances, labels) {\n        var this$1 = this;\n\n        var segment = last(this.points);\n        var sector = segment.sector;\n        var labelOptions = segment.options.labels;\n        var labelsCount = labels.length;\n        var labelDistance = labelOptions.distance;\n        var boxY = sector.center.y - (sector.radius + labelDistance) - labels[0].box.height();\n        var boxX;\n\n        distances[0] += 2;\n        for (var i = 0; i < labelsCount; i++) {\n            var label = labels[i];\n            var box = label.box;\n\n            boxY += distances[i];\n            boxX = this$1.hAlignLabel(\n                box.x2,\n                sector.clone().expand(labelDistance),\n                boxY,\n                boxY + box.height(),\n                label.orientation === RIGHT);\n\n            if (label.orientation === RIGHT) {\n                if (labelOptions.align !== CIRCLE) {\n                    boxX = sector.radius + sector.center.x + labelDistance;\n                }\n                label.reflow(new Box(boxX + box.width(), boxY, boxX, boxY));\n            } else {\n                if (labelOptions.align !== CIRCLE) {\n                    boxX = sector.center.x - sector.radius - labelDistance;\n                }\n                label.reflow(new Box(boxX - box.width(), boxY, boxX, boxY));\n            }\n\n            boxY += box.height();\n        }\n    };\n\n    PieChart.prototype.createVisual = function createVisual () {\n        var this$1 = this;\n\n        var ref = this;\n        var connectors = ref.options.connectors;\n        var points = ref.points;\n        var count = points.length;\n        var space = 4;\n\n        ChartElement.prototype.createVisual.call(this);\n\n        this._connectorLines = [];\n\n        for (var i = 0; i < count; i++) {\n            var segment = points[i];\n            var sector = segment.sector;\n            var label = segment.label;\n            var angle = sector.middle();\n            var connectorsColor = (segment.options.connectors || {}).color || connectors.color;\n\n            if (label) {\n                var connectorLine = new draw.Path({\n                    stroke: {\n                        color: connectorsColor,\n                        width: connectors.width\n                    },\n                    animation: {\n                        type: FADEIN,\n                        delay: segment.animationDelay\n                    }\n                });\n\n                if (label.options.position === OUTSIDE_END) {\n                    var box = label.box;\n                    var centerPoint = sector.center;\n                    var start = sector.point(angle);\n                    var middle = new Point(box.x1, box.center().y);\n                    var sr = (void 0), end = (void 0), crossing = (void 0);\n\n                    start = sector.clone().expand(connectors.padding).point(angle);\n                    connectorLine.moveTo(start.x, start.y);\n                    // TODO: Extract into a method to remove duplication\n                    if (label.orientation === RIGHT) {\n                        end = new Point(box.x1 - connectors.padding, box.center().y);\n                        crossing = intersection(centerPoint, start, middle, end);\n                        middle = new Point(end.x - space, end.y);\n                        crossing = crossing || middle;\n                        crossing.x = Math.min(crossing.x, middle.x);\n\n                        if (this$1.pointInCircle(crossing, sector.center, sector.radius + space) ||\n                            crossing.x < sector.center.x) {\n                            sr = sector.center.x + sector.radius + space;\n                            if (segment.options.labels.align !== COLUMN) {\n                                if (sr < middle.x) {\n                                    connectorLine.lineTo(sr, start.y);\n                                } else {\n                                    connectorLine.lineTo(start.x + space * 2, start.y);\n                                }\n                            } else {\n                                connectorLine.lineTo(sr, start.y);\n                            }\n                            connectorLine.lineTo(middle.x, end.y);\n                        } else {\n                            crossing.y = end.y;\n                            connectorLine.lineTo(crossing.x, crossing.y);\n                        }\n                    } else {\n                        end = new Point(box.x2 + connectors.padding, box.center().y);\n                        crossing = intersection(centerPoint, start, middle, end);\n                        middle = new Point(end.x + space, end.y);\n                        crossing = crossing || middle;\n                        crossing.x = Math.max(crossing.x, middle.x);\n\n                        if (this$1.pointInCircle(crossing, sector.center, sector.radius + space) ||\n                            crossing.x > sector.center.x) {\n                            sr = sector.center.x - sector.radius - space;\n                            if (segment.options.labels.align !== COLUMN) {\n                                if (sr > middle.x) {\n                                    connectorLine.lineTo(sr, start.y);\n                                } else {\n                                    connectorLine.lineTo(start.x - space * 2, start.y);\n                                }\n                            } else {\n                                connectorLine.lineTo(sr, start.y);\n                            }\n                            connectorLine.lineTo(middle.x, end.y);\n                        } else {\n                            crossing.y = end.y;\n                            connectorLine.lineTo(crossing.x, crossing.y);\n                        }\n                    }\n\n                    connectorLine.lineTo(end.x, end.y);\n\n                    this$1._connectorLines.push(connectorLine);\n                    this$1.visual.append(connectorLine);\n                }\n            }\n        }\n    };\n\n    PieChart.prototype.renderVisual = function renderVisual () {\n        ChartElement.prototype.renderVisual.call(this);\n\n        if (find(this.options.series, function (options) { return options.autoFit; })) {\n            var targetBox = this.targetBox;\n            var pieCenter = this.box.center();\n            var bbox = this.visual.bbox();\n            if (!bbox) {\n                return;\n            }\n\n            var bboxBottom = bbox.bottomRight();\n\n            var scale = Math.min(\n                (pieCenter.y - targetBox.y1) / (pieCenter.y - bbox.origin.y),\n                (targetBox.y2 - pieCenter.y) / (bboxBottom.y - pieCenter.y),\n                (pieCenter.x - targetBox.x1) / (pieCenter.x - bbox.origin.x),\n                (targetBox.x2 - pieCenter.x) / (bboxBottom.x - pieCenter.x)\n            );\n\n            if (scale < 1) {\n                this.visual.transform(geometry.transform().scale(scale, scale, [ pieCenter.x, pieCenter.y ]));\n            }\n        }\n    };\n\n    PieChart.prototype.labelComparator = function labelComparator (reverse) {\n        var reverseValue = reverse ? -1 : 1;\n\n        return function(a, b) {\n            var first = (a.parent.sector.middle() + 270) % 360;\n            var second = (b.parent.sector.middle() + 270) % 360;\n            return (first - second) * reverseValue;\n        };\n    };\n\n    PieChart.prototype.hAlignLabel = function hAlignLabel (originalX, sector, y1, y2, direction) {\n        var radius = sector.radius;\n        var sector_center = sector.center;\n        var cx = sector_center.x;\n        var cy = sector_center.y;\n        var t = Math.min(Math.abs(cy - y1), Math.abs(cy - y2));\n\n        if (t > radius) {\n            return originalX;\n        }\n\n        return cx + Math.sqrt((radius * radius) - (t * t)) * (direction ? 1 : -1);\n    };\n\n    PieChart.prototype.pointInCircle = function pointInCircle (point, center, radius) {\n        return Math.pow(center.x - point.x, 2) + Math.pow(center.y - point.y, 2) < Math.pow(radius, 2);\n    };\n\n    PieChart.prototype.formatPointValue = function formatPointValue (point, format) {\n        return this.chartService.format.auto(format, point.value);\n    };\n\n    PieChart.prototype.animationDelay = function animationDelay (categoryIndex) {\n        return categoryIndex * PIE_SECTOR_ANIM_DELAY;\n    };\n\n    PieChart.prototype.stackRoot = function stackRoot () {\n        return this;\n    };\n\n    return PieChart;\n}(ChartElement));\n\nfunction intersection(a1, a2, b1, b2) {\n    var uat = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);\n    var ub = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);\n\n    var result;\n    if (ub !== 0) {\n        var ua = (uat / ub);\n\n        result = new Point(\n            a1.x + ua * (a2.x - a1.x),\n            a1.y + ua * (a2.y - a1.y)\n        );\n    }\n\n    return result;\n}\n\nsetDefaultOptions(PieChart, {\n    startAngle: 90,\n    connectors: {\n        width: 2,\n        color: \"#939393\",\n        padding: 8\n    },\n    inactiveItems: {\n        markers: {},\n        labels: {}\n    }\n});\n\ndeepExtend(PieChart.prototype, PieChartMixin);\n\nPieChart.prototype.isStackRoot = true;\n\nexport default PieChart;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}