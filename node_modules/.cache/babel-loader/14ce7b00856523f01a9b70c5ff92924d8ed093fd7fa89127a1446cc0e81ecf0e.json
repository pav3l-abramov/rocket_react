{"ast":null,"code":"import Box from './box';\nimport Point from './point';\nimport { COORD_PRECISION, MAX_VALUE, MIN_VALUE } from '../common/constants';\nimport { Class, clockwise, rad, round } from '../common';\nvar Ring = function (Class) {\n  function Ring(center, innerRadius, radius, startAngle, angle) {\n    Class.call(this);\n    this.center = center;\n    this.innerRadius = innerRadius;\n    this.radius = radius;\n    this.startAngle = startAngle;\n    this.angle = angle;\n  }\n  if (Class) Ring.__proto__ = Class;\n  Ring.prototype = Object.create(Class && Class.prototype);\n  Ring.prototype.constructor = Ring;\n  Ring.prototype.clone = function clone() {\n    return new Ring(this.center, this.innerRadius, this.radius, this.startAngle, this.angle);\n  };\n  Ring.prototype.middle = function middle() {\n    return this.startAngle + this.angle / 2;\n  };\n  Ring.prototype.setRadius = function setRadius(newRadius, innerRadius) {\n    if (innerRadius) {\n      this.innerRadius = newRadius;\n    } else {\n      this.radius = newRadius;\n    }\n    return this;\n  };\n\n  // TODO: Remove and replace with Point.onCircle\n  Ring.prototype.point = function point(angle, innerRadius) {\n    var radianAngle = rad(angle);\n    var ax = Math.cos(radianAngle);\n    var ay = Math.sin(radianAngle);\n    var radius = innerRadius ? this.innerRadius : this.radius;\n    var x = round(this.center.x - ax * radius, COORD_PRECISION);\n    var y = round(this.center.y - ay * radius, COORD_PRECISION);\n    return new Point(x, y);\n  };\n  Ring.prototype.adjacentBox = function adjacentBox(distance, width, height) {\n    var sector = this.clone().expand(distance);\n    var midAndle = sector.middle();\n    var midPoint = sector.point(midAndle);\n    var hw = width / 2;\n    var hh = height / 2;\n    var sa = Math.sin(rad(midAndle));\n    var ca = Math.cos(rad(midAndle));\n    var x = midPoint.x - hw;\n    var y = midPoint.y - hh;\n    if (Math.abs(sa) < 0.9) {\n      x += hw * -ca / Math.abs(ca);\n    }\n    if (Math.abs(ca) < 0.9) {\n      y += hh * -sa / Math.abs(sa);\n    }\n    return new Box(x, y, x + width, y + height);\n  };\n  Ring.prototype.containsPoint = function containsPoint(p) {\n    var center = this.center;\n    var innerRadius = this.innerRadius;\n    var radius = this.radius;\n    var startAngle = this.startAngle;\n    var endAngle = this.startAngle + this.angle;\n    var dx = p.x - center.x;\n    var dy = p.y - center.y;\n    var vector = new Point(dx, dy);\n    var startPoint = this.point(startAngle);\n    var startVector = new Point(startPoint.x - center.x, startPoint.y - center.y);\n    var endPoint = this.point(endAngle);\n    var endVector = new Point(endPoint.x - center.x, endPoint.y - center.y);\n    var dist = round(dx * dx + dy * dy, COORD_PRECISION);\n    return (startVector.equals(vector) || clockwise(startVector, vector)) && !clockwise(endVector, vector) && dist >= innerRadius * innerRadius && dist <= radius * radius;\n  };\n  Ring.prototype.getBBox = function getBBox() {\n    var this$1 = this;\n    var box = new Box(MAX_VALUE, MAX_VALUE, MIN_VALUE, MIN_VALUE);\n    var startAngle = round(this.startAngle % 360);\n    var endAngle = round((startAngle + this.angle) % 360);\n    var innerRadius = this.innerRadius;\n    var allAngles = [0, 90, 180, 270, startAngle, endAngle].sort(numericComparer);\n    var startAngleIndex = allAngles.indexOf(startAngle);\n    var endAngleIndex = allAngles.indexOf(endAngle);\n    var angles;\n    if (startAngle === endAngle) {\n      angles = allAngles;\n    } else {\n      if (startAngleIndex < endAngleIndex) {\n        angles = allAngles.slice(startAngleIndex, endAngleIndex + 1);\n      } else {\n        angles = [].concat(allAngles.slice(0, endAngleIndex + 1), allAngles.slice(startAngleIndex, allAngles.length));\n      }\n    }\n    for (var i = 0; i < angles.length; i++) {\n      var point = this$1.point(angles[i]);\n      box.wrapPoint(point);\n      box.wrapPoint(point, innerRadius);\n    }\n    if (!innerRadius) {\n      box.wrapPoint(this.center);\n    }\n    return box;\n  };\n  Ring.prototype.expand = function expand(value) {\n    this.radius += value;\n    return this;\n  };\n  return Ring;\n}(Class);\nfunction numericComparer(a, b) {\n  return a - b;\n}\nexport default Ring;","map":{"version":3,"names":["Box","Point","COORD_PRECISION","MAX_VALUE","MIN_VALUE","Class","clockwise","rad","round","Ring","center","innerRadius","radius","startAngle","angle","call","__proto__","prototype","Object","create","constructor","clone","middle","setRadius","newRadius","point","radianAngle","ax","Math","cos","ay","sin","x","y","adjacentBox","distance","width","height","sector","expand","midAndle","midPoint","hw","hh","sa","ca","abs","containsPoint","p","endAngle","dx","dy","vector","startPoint","startVector","endPoint","endVector","dist","equals","getBBox","this$1","box","allAngles","sort","numericComparer","startAngleIndex","indexOf","endAngleIndex","angles","slice","concat","length","i","wrapPoint","value","a","b"],"sources":["C:/Users/Павел/Desktop/react humster/my-app/node_modules/@progress/kendo-charts/dist/es/core/ring.js"],"sourcesContent":["import Box from './box';\nimport Point from './point';\nimport { COORD_PRECISION, MAX_VALUE, MIN_VALUE } from '../common/constants';\nimport { Class, clockwise, rad, round } from '../common';\n\nvar Ring = (function (Class) {\n    function Ring(center, innerRadius, radius, startAngle, angle) {\n        Class.call(this);\n\n        this.center = center;\n        this.innerRadius = innerRadius;\n        this.radius = radius;\n        this.startAngle = startAngle;\n        this.angle = angle;\n    }\n\n    if ( Class ) Ring.__proto__ = Class;\n    Ring.prototype = Object.create( Class && Class.prototype );\n    Ring.prototype.constructor = Ring;\n\n    Ring.prototype.clone = function clone () {\n        return new Ring(this.center, this.innerRadius, this.radius, this.startAngle, this.angle);\n    };\n\n    Ring.prototype.middle = function middle () {\n        return this.startAngle + this.angle / 2;\n    };\n\n    Ring.prototype.setRadius = function setRadius (newRadius, innerRadius) {\n        if (innerRadius) {\n            this.innerRadius = newRadius;\n        } else {\n            this.radius = newRadius;\n        }\n\n        return this;\n    };\n\n    // TODO: Remove and replace with Point.onCircle\n    Ring.prototype.point = function point (angle, innerRadius) {\n        var radianAngle = rad(angle);\n        var ax = Math.cos(radianAngle);\n        var ay = Math.sin(radianAngle);\n        var radius = innerRadius ? this.innerRadius : this.radius;\n        var x = round(this.center.x - (ax * radius), COORD_PRECISION);\n        var y = round(this.center.y - (ay * radius), COORD_PRECISION);\n\n        return new Point(x, y);\n    };\n\n    Ring.prototype.adjacentBox = function adjacentBox (distance, width, height) {\n        var sector = this.clone().expand(distance);\n        var midAndle = sector.middle();\n        var midPoint = sector.point(midAndle);\n        var hw = width / 2;\n        var hh = height / 2;\n        var sa = Math.sin(rad(midAndle));\n        var ca = Math.cos(rad(midAndle));\n        var x = midPoint.x - hw;\n        var y = midPoint.y - hh;\n\n        if (Math.abs(sa) < 0.9) {\n            x += hw * -ca / Math.abs(ca);\n        }\n\n        if (Math.abs(ca) < 0.9) {\n            y += hh * -sa / Math.abs(sa);\n        }\n\n        return new Box(x, y, x + width, y + height);\n    };\n\n    Ring.prototype.containsPoint = function containsPoint (p) {\n        var center = this.center;\n        var innerRadius = this.innerRadius;\n        var radius = this.radius;\n        var startAngle = this.startAngle;\n        var endAngle = this.startAngle + this.angle;\n        var dx = p.x - center.x;\n        var dy = p.y - center.y;\n        var vector = new Point(dx, dy);\n        var startPoint = this.point(startAngle);\n        var startVector = new Point(startPoint.x - center.x, startPoint.y - center.y);\n        var endPoint = this.point(endAngle);\n        var endVector = new Point(endPoint.x - center.x, endPoint.y - center.y);\n        var dist = round(dx * dx + dy * dy, COORD_PRECISION);\n\n        return (startVector.equals(vector) || clockwise(startVector, vector)) &&\n               !clockwise(endVector, vector) &&\n               dist >= innerRadius * innerRadius && dist <= radius * radius;\n    };\n\n    Ring.prototype.getBBox = function getBBox () {\n        var this$1 = this;\n\n        var box = new Box(MAX_VALUE, MAX_VALUE, MIN_VALUE, MIN_VALUE);\n        var startAngle = round(this.startAngle % 360);\n        var endAngle = round((startAngle + this.angle) % 360);\n        var innerRadius = this.innerRadius;\n        var allAngles = [ 0, 90, 180, 270, startAngle, endAngle ].sort(numericComparer);\n        var startAngleIndex = allAngles.indexOf(startAngle);\n        var endAngleIndex = allAngles.indexOf(endAngle);\n        var angles;\n\n        if (startAngle === endAngle) {\n            angles = allAngles;\n        } else {\n            if (startAngleIndex < endAngleIndex) {\n                angles = allAngles.slice(startAngleIndex, endAngleIndex + 1);\n            } else {\n                angles = [].concat(\n                    allAngles.slice(0, endAngleIndex + 1),\n                    allAngles.slice(startAngleIndex, allAngles.length)\n                );\n            }\n        }\n\n        for (var i = 0; i < angles.length; i++) {\n            var point = this$1.point(angles[i]);\n            box.wrapPoint(point);\n            box.wrapPoint(point, innerRadius);\n        }\n\n        if (!innerRadius) {\n            box.wrapPoint(this.center);\n        }\n\n        return box;\n    };\n\n    Ring.prototype.expand = function expand (value) {\n        this.radius += value;\n        return this;\n    };\n\n    return Ring;\n}(Class));\n\nfunction numericComparer(a, b) {\n    return a - b;\n}\n\nexport default Ring;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}