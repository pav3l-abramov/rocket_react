{"ast":null,"code":"import LineChart from '../line-chart/line-chart';\nimport LinePoint from '../line-chart/line-point';\nimport AreaSegment from './area-segment';\nimport StepAreaSegment from './step-area-segment';\nimport SplineAreaSegment from './spline-area-segment';\nimport { STEP, SMOOTH, ZERO } from '../constants';\nvar AreaChart = function (LineChart) {\n  function AreaChart() {\n    LineChart.apply(this, arguments);\n  }\n  if (LineChart) AreaChart.__proto__ = LineChart;\n  AreaChart.prototype = Object.create(LineChart && LineChart.prototype);\n  AreaChart.prototype.constructor = AreaChart;\n  AreaChart.prototype.createSegment = function createSegment(linePoints, currentSeries, seriesIx, prevSegment) {\n    var isStacked = this.options.isStacked;\n    var style = (currentSeries.line || {}).style;\n    var previousSegment;\n    var stackPoints;\n    if (isStacked && seriesIx > 0 && prevSegment) {\n      var missingValues = this.seriesMissingValues(currentSeries);\n      if (missingValues !== \"gap\") {\n        stackPoints = prevSegment.linePoints;\n        previousSegment = prevSegment;\n      } else {\n        stackPoints = this._gapStackPoints(linePoints, seriesIx, style);\n      }\n    }\n    var pointType;\n    if (style === STEP) {\n      pointType = StepAreaSegment;\n    } else if (style === SMOOTH) {\n      pointType = SplineAreaSegment;\n    } else {\n      pointType = AreaSegment;\n    }\n    return new pointType(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);\n  };\n  AreaChart.prototype.reflow = function reflow(targetBox) {\n    var this$1 = this;\n    LineChart.prototype.reflow.call(this, targetBox);\n    var stackPoints = this._stackPoints;\n    if (stackPoints) {\n      for (var idx = 0; idx < stackPoints.length; idx++) {\n        var stackPoint = stackPoints[idx];\n        var pointSlot = this$1.categoryAxis.getSlot(stackPoint.categoryIx);\n        stackPoint.reflow(pointSlot);\n      }\n    }\n  };\n  AreaChart.prototype._gapStackPoints = function _gapStackPoints(linePoints, seriesIx, style) {\n    var this$1 = this;\n    var seriesPoints = this.seriesPoints;\n    var startIdx = linePoints[0].categoryIx;\n    var length = linePoints.length;\n    if (startIdx < 0) {\n      startIdx = 0;\n      length--;\n    }\n    var endIdx = startIdx + length;\n    var pointOffset = this.seriesOptions[0]._outOfRangeMinPoint ? 1 : 0;\n    var stackPoints = [];\n    this._stackPoints = this._stackPoints || [];\n    for (var categoryIx = startIdx; categoryIx < endIdx; categoryIx++) {\n      var pointIx = categoryIx + pointOffset;\n      var currentSeriesIx = seriesIx;\n      var point = void 0;\n      do {\n        currentSeriesIx--;\n        point = seriesPoints[currentSeriesIx][pointIx];\n      } while (currentSeriesIx > 0 && !point);\n      if (point) {\n        if (style !== STEP && categoryIx > startIdx && !seriesPoints[currentSeriesIx][pointIx - 1]) {\n          stackPoints.push(this$1._previousSegmentPoint(categoryIx, pointIx, pointIx - 1, currentSeriesIx));\n        }\n        stackPoints.push(point);\n        if (style !== STEP && categoryIx + 1 < endIdx && !seriesPoints[currentSeriesIx][pointIx + 1]) {\n          stackPoints.push(this$1._previousSegmentPoint(categoryIx, pointIx, pointIx + 1, currentSeriesIx));\n        }\n      } else {\n        var gapStackPoint = this$1._createGapStackPoint(categoryIx);\n        this$1._stackPoints.push(gapStackPoint);\n        stackPoints.push(gapStackPoint);\n      }\n    }\n    return stackPoints;\n  };\n  AreaChart.prototype._previousSegmentPoint = function _previousSegmentPoint(categoryIx, pointIx, segmentIx, seriesIdx) {\n    var seriesPoints = this.seriesPoints;\n    var index = seriesIdx;\n    var point;\n    while (index > 0 && !point) {\n      index--;\n      point = seriesPoints[index][segmentIx];\n    }\n    if (!point) {\n      point = this._createGapStackPoint(categoryIx);\n      this._stackPoints.push(point);\n    } else {\n      point = seriesPoints[index][pointIx];\n    }\n    return point;\n  };\n  AreaChart.prototype._createGapStackPoint = function _createGapStackPoint(categoryIx) {\n    var options = this.pointOptions({}, 0);\n    var point = new LinePoint(0, options);\n    point.categoryIx = categoryIx;\n    point.series = {};\n    return point;\n  };\n  AreaChart.prototype.seriesMissingValues = function seriesMissingValues(series) {\n    return series.missingValues || ZERO;\n  };\n  AreaChart.prototype.supportsPointInactiveOpacity = function supportsPointInactiveOpacity() {\n    return false;\n  };\n  return AreaChart;\n}(LineChart);\nexport default AreaChart;","map":{"version":3,"names":["LineChart","LinePoint","AreaSegment","StepAreaSegment","SplineAreaSegment","STEP","SMOOTH","ZERO","AreaChart","apply","arguments","__proto__","prototype","Object","create","constructor","createSegment","linePoints","currentSeries","seriesIx","prevSegment","isStacked","options","style","line","previousSegment","stackPoints","missingValues","seriesMissingValues","_gapStackPoints","pointType","reflow","targetBox","this$1","call","_stackPoints","idx","length","stackPoint","pointSlot","categoryAxis","getSlot","categoryIx","seriesPoints","startIdx","endIdx","pointOffset","seriesOptions","_outOfRangeMinPoint","pointIx","currentSeriesIx","point","push","_previousSegmentPoint","gapStackPoint","_createGapStackPoint","segmentIx","seriesIdx","index","pointOptions","series","supportsPointInactiveOpacity"],"sources":["C:/Users/Павел/Desktop/react humster/my-app/node_modules/@progress/kendo-charts/dist/es/chart/area-chart/area-chart.js"],"sourcesContent":["import LineChart from '../line-chart/line-chart';\nimport LinePoint from '../line-chart/line-point';\n\nimport AreaSegment from './area-segment';\nimport StepAreaSegment from './step-area-segment';\nimport SplineAreaSegment from './spline-area-segment';\n\nimport { STEP, SMOOTH, ZERO } from '../constants';\n\nvar AreaChart = (function (LineChart) {\n    function AreaChart () {\n        LineChart.apply(this, arguments);\n    }\n\n    if ( LineChart ) AreaChart.__proto__ = LineChart;\n    AreaChart.prototype = Object.create( LineChart && LineChart.prototype );\n    AreaChart.prototype.constructor = AreaChart;\n\n    AreaChart.prototype.createSegment = function createSegment (linePoints, currentSeries, seriesIx, prevSegment) {\n        var isStacked = this.options.isStacked;\n        var style = (currentSeries.line || {}).style;\n        var previousSegment;\n\n        var stackPoints;\n        if (isStacked && seriesIx > 0 && prevSegment) {\n            var missingValues = this.seriesMissingValues(currentSeries);\n            if (missingValues !== \"gap\") {\n                stackPoints = prevSegment.linePoints;\n                previousSegment = prevSegment;\n            } else {\n                stackPoints = this._gapStackPoints(linePoints, seriesIx, style);\n            }\n        }\n\n        var pointType;\n        if (style === STEP) {\n            pointType = StepAreaSegment;\n        } else if (style === SMOOTH) {\n            pointType = SplineAreaSegment;\n        } else {\n            pointType = AreaSegment;\n        }\n\n        return new pointType(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);\n    };\n\n    AreaChart.prototype.reflow = function reflow (targetBox) {\n        var this$1 = this;\n\n        LineChart.prototype.reflow.call(this, targetBox);\n\n        var stackPoints = this._stackPoints;\n        if (stackPoints) {\n            for (var idx = 0; idx < stackPoints.length; idx++) {\n                var stackPoint = stackPoints[idx];\n                var pointSlot = this$1.categoryAxis.getSlot(stackPoint.categoryIx);\n                stackPoint.reflow(pointSlot);\n            }\n        }\n    };\n\n    AreaChart.prototype._gapStackPoints = function _gapStackPoints (linePoints, seriesIx, style) {\n        var this$1 = this;\n\n        var seriesPoints = this.seriesPoints;\n        var startIdx = linePoints[0].categoryIx;\n        var length = linePoints.length;\n        if (startIdx < 0) {\n            startIdx = 0;\n            length--;\n        }\n\n        var endIdx = startIdx + length;\n        var pointOffset = this.seriesOptions[0]._outOfRangeMinPoint ? 1 : 0;\n        var stackPoints = [];\n\n        this._stackPoints = this._stackPoints || [];\n        for (var categoryIx = startIdx; categoryIx < endIdx; categoryIx++) {\n            var pointIx = categoryIx + pointOffset;\n            var currentSeriesIx = seriesIx;\n            var point = (void 0);\n\n            do {\n                currentSeriesIx--;\n                point = seriesPoints[currentSeriesIx][pointIx];\n            } while (currentSeriesIx > 0 && !point);\n\n            if (point) {\n                if (style !== STEP && categoryIx > startIdx && !seriesPoints[currentSeriesIx][pointIx - 1]) {\n                    stackPoints.push(this$1._previousSegmentPoint(categoryIx, pointIx, pointIx - 1, currentSeriesIx));\n                }\n\n                stackPoints.push(point);\n\n                if (style !== STEP && categoryIx + 1 < endIdx && !seriesPoints[currentSeriesIx][pointIx + 1]) {\n                    stackPoints.push(this$1._previousSegmentPoint(categoryIx, pointIx, pointIx + 1, currentSeriesIx));\n                }\n            } else {\n                var gapStackPoint = this$1._createGapStackPoint(categoryIx);\n                this$1._stackPoints.push(gapStackPoint);\n                stackPoints.push(gapStackPoint);\n            }\n        }\n\n        return stackPoints;\n    };\n\n    AreaChart.prototype._previousSegmentPoint = function _previousSegmentPoint (categoryIx, pointIx, segmentIx, seriesIdx) {\n        var seriesPoints = this.seriesPoints;\n        var index = seriesIdx;\n        var point;\n\n        while (index > 0 && !point) {\n            index--;\n            point = seriesPoints[index][segmentIx];\n        }\n\n        if (!point) {\n            point = this._createGapStackPoint(categoryIx);\n            this._stackPoints.push(point);\n        } else {\n            point = seriesPoints[index][pointIx];\n        }\n\n        return point;\n    };\n\n    AreaChart.prototype._createGapStackPoint = function _createGapStackPoint (categoryIx) {\n        var options = this.pointOptions({}, 0);\n        var point = new LinePoint(0, options);\n        point.categoryIx = categoryIx;\n        point.series = {};\n\n        return point;\n    };\n\n    AreaChart.prototype.seriesMissingValues = function seriesMissingValues (series) {\n        return series.missingValues || ZERO;\n    };\n\n    AreaChart.prototype.supportsPointInactiveOpacity = function supportsPointInactiveOpacity () {\n        return false;\n    };\n\n    return AreaChart;\n}(LineChart));\n\nexport default AreaChart;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}