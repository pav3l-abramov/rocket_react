{"ast":null,"code":"import Axis from './axis';\nimport AxisLabel from './axis-label';\nimport Box from './box';\nimport createAxisTick from './utils/create-axis-tick';\nimport createAxisGridLine from './utils/create-axis-grid-line';\nimport limitCoordinate from './utils/limit-coordinate';\nimport { DEFAULT_PRECISION, BLACK } from '../common/constants';\nimport { deepExtend, defined, inArray, limitValue, round, setDefaultOptions, valueOrDefault } from '../common';\nvar DEFAULT_MAJOR_UNIT = 10;\nvar MIN_VALUE_RANGE = 1e-6;\nvar LogarithmicAxis = function (Axis) {\n  function LogarithmicAxis(seriesMin, seriesMax, options, chartService) {\n    var axisOptions = deepExtend({\n      majorUnit: DEFAULT_MAJOR_UNIT,\n      min: seriesMin,\n      max: seriesMax\n    }, options);\n    var base = axisOptions.majorUnit;\n    var autoMax = autoAxisMax(seriesMax, base);\n    var autoMin = autoAxisMin(seriesMin, seriesMax, axisOptions);\n    var range = initRange(autoMin, autoMax, axisOptions, options);\n    axisOptions.max = range.max;\n    axisOptions.min = range.min;\n    axisOptions.minorUnit = options.minorUnit || round(base - 1, DEFAULT_PRECISION);\n    Axis.call(this, axisOptions, chartService);\n    this.totalMin = defined(options.min) ? Math.min(autoMin, options.min) : autoMin;\n    this.totalMax = defined(options.max) ? Math.max(autoMax, options.max) : autoMax;\n    this.logMin = round(log(range.min, base), DEFAULT_PRECISION);\n    this.logMax = round(log(range.max, base), DEFAULT_PRECISION);\n    this.seriesMin = seriesMin;\n    this.seriesMax = seriesMax;\n    this.createLabels();\n  }\n  if (Axis) LogarithmicAxis.__proto__ = Axis;\n  LogarithmicAxis.prototype = Object.create(Axis && Axis.prototype);\n  LogarithmicAxis.prototype.constructor = LogarithmicAxis;\n  LogarithmicAxis.prototype.clone = function clone() {\n    return new LogarithmicAxis(this.seriesMin, this.seriesMax, Object.assign({}, this.options), this.chartService);\n  };\n  LogarithmicAxis.prototype.startValue = function startValue() {\n    return this.options.min;\n  };\n  LogarithmicAxis.prototype.getSlot = function getSlot(a, b, limit) {\n    var ref = this;\n    var options = ref.options;\n    var logMin = ref.logMin;\n    var logMax = ref.logMax;\n    var base = options.majorUnit;\n    var min = options.min;\n    var max = options.max;\n    var ref$1 = this.lineInfo();\n    var axis = ref$1.axis;\n    var axisDir = ref$1.axisDir;\n    var lineBox = ref$1.lineBox;\n    var lineSize = ref$1.lineSize;\n    var lineStart = ref$1.lineStart;\n    var step = axisDir * (lineSize / (logMax - logMin));\n    var start = valueOrDefault(a, b || 1);\n    var end = valueOrDefault(b, a || 1);\n    if (start <= 0 || end <= 0) {\n      return null;\n    }\n    if (limit) {\n      start = limitValue(start, min, max);\n      end = limitValue(end, min, max);\n    }\n    start = log(start, base);\n    end = log(end, base);\n    var p1 = Math.min(start, end) - logMin;\n    var p2 = Math.max(start, end) - logMin;\n    var slotBox = new Box(lineBox.x1, lineBox.y1, lineBox.x1, lineBox.y1);\n    slotBox[axis + 1] = limitCoordinate(lineStart + step * (axisDir > 0 ? p1 : p2));\n    slotBox[axis + 2] = limitCoordinate(lineStart + step * (axisDir > 0 ? p2 : p1));\n    return slotBox;\n  };\n  LogarithmicAxis.prototype.getValue = function getValue(point) {\n    var ref = this;\n    var options = ref.options;\n    var logMin = ref.logMin;\n    var logMax = ref.logMax;\n    var base = options.majorUnit;\n    var ref$1 = this.lineInfo();\n    var axis = ref$1.axis;\n    var axisDir = ref$1.axisDir;\n    var lineStart = ref$1.lineStart;\n    var lineSize = ref$1.lineSize;\n    var step = (logMax - logMin) / lineSize;\n    var offset = axisDir * (point[axis] - lineStart);\n    var valueOffset = offset * step;\n    if (offset < 0 || offset > lineSize) {\n      return null;\n    }\n    var value = logMin + valueOffset;\n    return round(Math.pow(base, value), DEFAULT_PRECISION);\n  };\n  LogarithmicAxis.prototype.range = function range() {\n    var options = this.options;\n    return {\n      min: options.min,\n      max: options.max\n    };\n  };\n  LogarithmicAxis.prototype.translateRange = function translateRange(delta) {\n    var ref = this;\n    var options = ref.options;\n    var logMin = ref.logMin;\n    var logMax = ref.logMax;\n    var reverse = options.reverse;\n    var vertical = options.vertical;\n    var base = options.majorUnit;\n    var lineBox = this.lineBox();\n    var size = vertical ? lineBox.height() : lineBox.width();\n    var scale = size / (logMax - logMin);\n    var offset = round(delta / scale, DEFAULT_PRECISION);\n    if ((vertical || reverse) && !(vertical && reverse)) {\n      offset = -offset;\n    }\n    return {\n      min: Math.pow(base, logMin + offset),\n      max: Math.pow(base, logMax + offset),\n      offset: offset\n    };\n  };\n  LogarithmicAxis.prototype.labelsCount = function labelsCount() {\n    var floorMax = Math.floor(this.logMax);\n    var count = Math.floor(floorMax - this.logMin) + 1;\n    return count;\n  };\n  LogarithmicAxis.prototype.getMajorTickPositions = function getMajorTickPositions() {\n    var ticks = [];\n    this.traverseMajorTicksPositions(function (position) {\n      ticks.push(position);\n    }, {\n      step: 1,\n      skip: 0\n    });\n    return ticks;\n  };\n  LogarithmicAxis.prototype.createTicks = function createTicks(lineGroup) {\n    var options = this.options;\n    var majorTicks = options.majorTicks;\n    var minorTicks = options.minorTicks;\n    var vertical = options.vertical;\n    var mirror = options.labels.mirror;\n    var lineBox = this.lineBox();\n    var ticks = [];\n    var tickLineOptions = {\n      // TODO\n      // _alignLines: options._alignLines,\n      vertical: vertical\n    };\n    function render(tickPosition, tickOptions) {\n      tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\n      tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\n      tickLineOptions.position = tickPosition;\n      lineGroup.append(createAxisTick(tickLineOptions, tickOptions));\n    }\n    if (majorTicks.visible) {\n      this.traverseMajorTicksPositions(render, majorTicks);\n    }\n    if (minorTicks.visible) {\n      this.traverseMinorTicksPositions(render, minorTicks);\n    }\n    return ticks;\n  };\n  LogarithmicAxis.prototype.createGridLines = function createGridLines(altAxis) {\n    var options = this.options;\n    var minorGridLines = options.minorGridLines;\n    var majorGridLines = options.majorGridLines;\n    var vertical = options.vertical;\n    var lineBox = altAxis.lineBox();\n    var lineOptions = {\n      lineStart: lineBox[vertical ? \"x1\" : \"y1\"],\n      lineEnd: lineBox[vertical ? \"x2\" : \"y2\"],\n      vertical: vertical\n    };\n    var majorTicks = [];\n    var container = this.gridLinesVisual();\n    function render(tickPosition, gridLine) {\n      if (!inArray(tickPosition, majorTicks)) {\n        lineOptions.position = tickPosition;\n        container.append(createAxisGridLine(lineOptions, gridLine));\n        majorTicks.push(tickPosition);\n      }\n    }\n    if (majorGridLines.visible) {\n      this.traverseMajorTicksPositions(render, majorGridLines);\n    }\n    if (minorGridLines.visible) {\n      this.traverseMinorTicksPositions(render, minorGridLines);\n    }\n    return container.children;\n  };\n  LogarithmicAxis.prototype.traverseMajorTicksPositions = function traverseMajorTicksPositions(callback, tickOptions) {\n    var ref = this.lineInfo();\n    var lineStart = ref.lineStart;\n    var step = ref.step;\n    var ref$1 = this;\n    var logMin = ref$1.logMin;\n    var logMax = ref$1.logMax;\n    for (var power = Math.ceil(logMin) + tickOptions.skip; power <= logMax; power += tickOptions.step) {\n      var position = round(lineStart + step * (power - logMin), DEFAULT_PRECISION);\n      callback(position, tickOptions);\n    }\n  };\n  LogarithmicAxis.prototype.traverseMinorTicksPositions = function traverseMinorTicksPositions(callback, tickOptions) {\n    var this$1 = this;\n    var ref = this.options;\n    var min = ref.min;\n    var max = ref.max;\n    var minorUnit = ref.minorUnit;\n    var base = ref.majorUnit;\n    var ref$1 = this.lineInfo();\n    var lineStart = ref$1.lineStart;\n    var step = ref$1.step;\n    var ref$2 = this;\n    var logMin = ref$2.logMin;\n    var logMax = ref$2.logMax;\n    var start = Math.floor(logMin);\n    for (var power = start; power < logMax; power++) {\n      var minorOptions = this$1._minorIntervalOptions(power);\n      for (var idx = tickOptions.skip; idx < minorUnit; idx += tickOptions.step) {\n        var value = minorOptions.value + idx * minorOptions.minorStep;\n        if (value > max) {\n          break;\n        }\n        if (value >= min) {\n          var position = round(lineStart + step * (log(value, base) - logMin), DEFAULT_PRECISION);\n          callback(position, tickOptions);\n        }\n      }\n    }\n  };\n  LogarithmicAxis.prototype.createAxisLabel = function createAxisLabel(index, labelOptions, labelContext) {\n    var power = Math.ceil(this.logMin + index);\n    var value = Math.pow(this.options.majorUnit, power);\n    var text = this.axisLabelText(value, labelOptions, labelContext);\n    return new AxisLabel(value, text, index, null, labelOptions);\n  };\n  LogarithmicAxis.prototype.shouldRenderNote = function shouldRenderNote(value) {\n    var range = this.range();\n    return range.min <= value && value <= range.max;\n  };\n  LogarithmicAxis.prototype.pan = function pan(delta) {\n    var range = this.translateRange(delta);\n    return this.limitRange(range.min, range.max, this.totalMin, this.totalMax, range.offset);\n  };\n  LogarithmicAxis.prototype.pointsRange = function pointsRange(start, end) {\n    var startValue = this.getValue(start);\n    var endValue = this.getValue(end);\n    var min = Math.min(startValue, endValue);\n    var max = Math.max(startValue, endValue);\n    return {\n      min: min,\n      max: max\n    };\n  };\n  LogarithmicAxis.prototype.scaleRange = function scaleRange(scale, cursor) {\n    var ref = this.options;\n    var base = ref.majorUnit;\n    var logMin = log(this.options.min, base);\n    var logMax = log(this.options.max, base);\n    var position = Math.abs(this.pointOffset(cursor));\n    var range = logMax - logMin;\n    var delta = this.scaleToDelta(scale, range);\n    var min = Math.pow(base, logMin + position * delta);\n    var max = Math.pow(base, logMax - (1 - position) * delta);\n    if (max - min < MIN_VALUE_RANGE) {\n      max = min + MIN_VALUE_RANGE;\n    }\n    return {\n      min: min,\n      max: max\n    };\n  };\n  LogarithmicAxis.prototype.zoomRange = function zoomRange(scale, cursor) {\n    var range = this.scaleRange(scale, cursor);\n    var ref = this;\n    var totalMin = ref.totalMin;\n    var totalMax = ref.totalMax;\n    return {\n      min: limitValue(range.min, totalMin, totalMax),\n      max: limitValue(range.max, totalMin, totalMax)\n    };\n  };\n  LogarithmicAxis.prototype._minorIntervalOptions = function _minorIntervalOptions(power) {\n    var ref = this.options;\n    var minorUnit = ref.minorUnit;\n    var base = ref.majorUnit;\n    var value = Math.pow(base, power);\n    var nextValue = Math.pow(base, power + 1);\n    var difference = nextValue - value;\n    var minorStep = difference / minorUnit;\n    return {\n      value: value,\n      minorStep: minorStep\n    };\n  };\n  LogarithmicAxis.prototype.lineInfo = function lineInfo() {\n    var info = Axis.prototype.lineInfo.call(this);\n    info.step = info.axisDir * (info.lineSize / (this.logMax - this.logMin));\n    return info;\n  };\n  return LogarithmicAxis;\n}(Axis);\nfunction initRange(autoMin, autoMax, axisOptions, options) {\n  var min = axisOptions.min;\n  var max = axisOptions.max;\n  if (defined(axisOptions.axisCrossingValue) && axisOptions.axisCrossingValue <= 0) {\n    throwNegativeValuesError();\n  }\n  if (!defined(options.max)) {\n    max = autoMax;\n  } else if (options.max <= 0) {\n    throwNegativeValuesError();\n  }\n  if (!defined(options.min)) {\n    min = autoMin;\n  } else if (options.min <= 0) {\n    throwNegativeValuesError();\n  }\n  return {\n    min: min,\n    max: max\n  };\n}\nfunction autoAxisMin(min, max, options) {\n  var base = options.majorUnit;\n  var autoMin = min;\n  if (min <= 0) {\n    autoMin = max <= 1 ? Math.pow(base, -2) : 1;\n  } else if (!options.narrowRange) {\n    autoMin = Math.pow(base, Math.floor(log(min, base)));\n  }\n  return autoMin;\n}\nfunction autoAxisMax(max, base) {\n  var logMaxRemainder = round(log(max, base), DEFAULT_PRECISION) % 1;\n  var autoMax;\n  if (max <= 0) {\n    autoMax = base;\n  } else if (logMaxRemainder !== 0 && (logMaxRemainder < 0.3 || logMaxRemainder > 0.9)) {\n    autoMax = Math.pow(base, log(max, base) + 0.2);\n  } else {\n    autoMax = Math.pow(base, Math.ceil(log(max, base)));\n  }\n  return autoMax;\n}\nfunction throwNegativeValuesError() {\n  throw new Error(\"Non positive values cannot be used for a logarithmic axis\");\n}\nfunction log(x, base) {\n  return Math.log(x) / Math.log(base);\n}\nsetDefaultOptions(LogarithmicAxis, {\n  type: \"log\",\n  majorUnit: DEFAULT_MAJOR_UNIT,\n  minorUnit: 1,\n  axisCrossingValue: 1,\n  vertical: true,\n  majorGridLines: {\n    visible: true,\n    width: 1,\n    color: BLACK\n  },\n  zIndex: 1,\n  _deferLabels: true\n});\nexport default LogarithmicAxis;","map":{"version":3,"names":["Axis","AxisLabel","Box","createAxisTick","createAxisGridLine","limitCoordinate","DEFAULT_PRECISION","BLACK","deepExtend","defined","inArray","limitValue","round","setDefaultOptions","valueOrDefault","DEFAULT_MAJOR_UNIT","MIN_VALUE_RANGE","LogarithmicAxis","seriesMin","seriesMax","options","chartService","axisOptions","majorUnit","min","max","base","autoMax","autoAxisMax","autoMin","autoAxisMin","range","initRange","minorUnit","call","totalMin","Math","totalMax","logMin","log","logMax","createLabels","__proto__","prototype","Object","create","constructor","clone","assign","startValue","getSlot","a","b","limit","ref","ref$1","lineInfo","axis","axisDir","lineBox","lineSize","lineStart","step","start","end","p1","p2","slotBox","x1","y1","getValue","point","offset","valueOffset","value","pow","translateRange","delta","reverse","vertical","size","height","width","scale","labelsCount","floorMax","floor","count","getMajorTickPositions","ticks","traverseMajorTicksPositions","position","push","skip","createTicks","lineGroup","majorTicks","minorTicks","mirror","labels","tickLineOptions","render","tickPosition","tickOptions","tickX","x2","tickY","append","visible","traverseMinorTicksPositions","createGridLines","altAxis","minorGridLines","majorGridLines","lineOptions","lineEnd","container","gridLinesVisual","gridLine","children","callback","power","ceil","this$1","ref$2","minorOptions","_minorIntervalOptions","idx","minorStep","createAxisLabel","index","labelOptions","labelContext","text","axisLabelText","shouldRenderNote","pan","limitRange","pointsRange","endValue","scaleRange","cursor","abs","pointOffset","scaleToDelta","zoomRange","nextValue","difference","info","axisCrossingValue","throwNegativeValuesError","narrowRange","logMaxRemainder","Error","x","type","color","zIndex","_deferLabels"],"sources":["C:/Users/Павел/Desktop/react humster/my-app/node_modules/@progress/kendo-charts/dist/es/core/logarithmic-axis.js"],"sourcesContent":["\nimport Axis from './axis';\nimport AxisLabel from './axis-label';\nimport Box from './box';\n\nimport createAxisTick from './utils/create-axis-tick';\nimport createAxisGridLine from './utils/create-axis-grid-line';\nimport limitCoordinate from './utils/limit-coordinate';\n\nimport { DEFAULT_PRECISION, BLACK } from '../common/constants';\nimport { deepExtend, defined, inArray, limitValue, round, setDefaultOptions, valueOrDefault } from '../common';\n\nvar DEFAULT_MAJOR_UNIT = 10;\nvar MIN_VALUE_RANGE = 1e-6;\n\nvar LogarithmicAxis = (function (Axis) {\n    function LogarithmicAxis(seriesMin, seriesMax, options, chartService) {\n\n        var axisOptions = deepExtend({ majorUnit: DEFAULT_MAJOR_UNIT, min: seriesMin, max: seriesMax }, options);\n        var base = axisOptions.majorUnit;\n        var autoMax = autoAxisMax(seriesMax, base);\n        var autoMin = autoAxisMin(seriesMin, seriesMax, axisOptions);\n        var range = initRange(autoMin, autoMax, axisOptions, options);\n\n        axisOptions.max = range.max;\n        axisOptions.min = range.min;\n        axisOptions.minorUnit = options.minorUnit || round(base - 1, DEFAULT_PRECISION);\n\n        Axis.call(this, axisOptions, chartService);\n\n        this.totalMin = defined(options.min) ? Math.min(autoMin, options.min) : autoMin;\n        this.totalMax = defined(options.max) ? Math.max(autoMax, options.max) : autoMax;\n        this.logMin = round(log(range.min, base), DEFAULT_PRECISION);\n        this.logMax = round(log(range.max, base), DEFAULT_PRECISION);\n        this.seriesMin = seriesMin;\n        this.seriesMax = seriesMax;\n\n        this.createLabels();\n    }\n\n    if ( Axis ) LogarithmicAxis.__proto__ = Axis;\n    LogarithmicAxis.prototype = Object.create( Axis && Axis.prototype );\n    LogarithmicAxis.prototype.constructor = LogarithmicAxis;\n\n    LogarithmicAxis.prototype.clone = function clone () {\n        return new LogarithmicAxis(\n            this.seriesMin,\n            this.seriesMax,\n            Object.assign({}, this.options),\n            this.chartService\n        );\n    };\n\n    LogarithmicAxis.prototype.startValue = function startValue () {\n        return this.options.min;\n    };\n\n    LogarithmicAxis.prototype.getSlot = function getSlot (a, b, limit) {\n        var ref = this;\n        var options = ref.options;\n        var logMin = ref.logMin;\n        var logMax = ref.logMax;\n        var base = options.majorUnit;\n        var min = options.min;\n        var max = options.max;\n        var ref$1 = this.lineInfo();\n        var axis = ref$1.axis;\n        var axisDir = ref$1.axisDir;\n        var lineBox = ref$1.lineBox;\n        var lineSize = ref$1.lineSize;\n        var lineStart = ref$1.lineStart;\n        var step = axisDir * (lineSize / (logMax - logMin));\n        var start = valueOrDefault(a, b || 1);\n        var end = valueOrDefault(b, a || 1);\n\n        if (start <= 0 || end <= 0) {\n            return null;\n        }\n\n        if (limit) {\n            start = limitValue(start, min, max);\n            end = limitValue(end, min, max);\n        }\n\n        start = log(start, base);\n        end = log(end, base);\n\n        var p1 = Math.min(start, end) - logMin;\n        var p2 = Math.max(start, end) - logMin;\n\n        var slotBox = new Box(lineBox.x1, lineBox.y1, lineBox.x1, lineBox.y1);\n        slotBox[axis + 1] = limitCoordinate(lineStart + step * (axisDir > 0 ? p1 : p2));\n        slotBox[axis + 2] = limitCoordinate(lineStart + step * (axisDir > 0 ? p2 : p1));\n\n        return slotBox;\n    };\n\n    LogarithmicAxis.prototype.getValue = function getValue (point) {\n        var ref = this;\n        var options = ref.options;\n        var logMin = ref.logMin;\n        var logMax = ref.logMax;\n        var base = options.majorUnit;\n        var ref$1 = this.lineInfo();\n        var axis = ref$1.axis;\n        var axisDir = ref$1.axisDir;\n        var lineStart = ref$1.lineStart;\n        var lineSize = ref$1.lineSize;\n        var step = ((logMax - logMin) / lineSize);\n        var offset = axisDir * (point[axis] - lineStart);\n        var valueOffset = offset * step;\n\n        if (offset < 0 || offset > lineSize) {\n            return null;\n        }\n\n        var value = logMin + valueOffset;\n\n        return round(Math.pow(base, value), DEFAULT_PRECISION);\n    };\n\n    LogarithmicAxis.prototype.range = function range () {\n        var options = this.options;\n        return { min: options.min, max: options.max };\n    };\n\n    LogarithmicAxis.prototype.translateRange = function translateRange (delta) {\n        var ref = this;\n        var options = ref.options;\n        var logMin = ref.logMin;\n        var logMax = ref.logMax;\n        var reverse = options.reverse;\n        var vertical = options.vertical;\n        var base = options.majorUnit;\n        var lineBox = this.lineBox();\n        var size = vertical ? lineBox.height() : lineBox.width();\n        var scale = size / (logMax - logMin);\n        var offset = round(delta / scale, DEFAULT_PRECISION);\n\n        if ((vertical || reverse) && !(vertical && reverse )) {\n            offset = -offset;\n        }\n\n        return {\n            min: Math.pow(base, logMin + offset),\n            max: Math.pow(base, logMax + offset),\n            offset: offset\n        };\n    };\n\n    LogarithmicAxis.prototype.labelsCount = function labelsCount () {\n        var floorMax = Math.floor(this.logMax);\n        var count = Math.floor(floorMax - this.logMin) + 1;\n\n        return count;\n    };\n\n    LogarithmicAxis.prototype.getMajorTickPositions = function getMajorTickPositions () {\n        var ticks = [];\n\n        this.traverseMajorTicksPositions(function (position) {\n            ticks.push(position);\n        }, { step: 1, skip: 0 });\n\n        return ticks;\n    };\n\n    LogarithmicAxis.prototype.createTicks = function createTicks (lineGroup) {\n        var options = this.options;\n        var majorTicks = options.majorTicks;\n        var minorTicks = options.minorTicks;\n        var vertical = options.vertical;\n        var mirror = options.labels.mirror;\n        var lineBox = this.lineBox();\n        var ticks = [];\n        var tickLineOptions = {\n            // TODO\n            // _alignLines: options._alignLines,\n            vertical: vertical\n        };\n\n        function render(tickPosition, tickOptions) {\n            tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\n            tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\n            tickLineOptions.position = tickPosition;\n\n            lineGroup.append(createAxisTick(tickLineOptions, tickOptions));\n        }\n\n        if (majorTicks.visible) {\n            this.traverseMajorTicksPositions(render, majorTicks);\n        }\n\n        if (minorTicks.visible) {\n            this.traverseMinorTicksPositions(render, minorTicks);\n        }\n\n        return ticks;\n    };\n\n    LogarithmicAxis.prototype.createGridLines = function createGridLines (altAxis) {\n        var options = this.options;\n        var minorGridLines = options.minorGridLines;\n        var majorGridLines = options.majorGridLines;\n        var vertical = options.vertical;\n        var lineBox = altAxis.lineBox();\n        var lineOptions = {\n            lineStart: lineBox[vertical ? \"x1\" : \"y1\"],\n            lineEnd: lineBox[vertical ? \"x2\" : \"y2\"],\n            vertical: vertical\n        };\n        var majorTicks = [];\n\n        var container = this.gridLinesVisual();\n        function render(tickPosition, gridLine) {\n            if (!inArray(tickPosition, majorTicks)) {\n                lineOptions.position = tickPosition;\n                container.append(createAxisGridLine(lineOptions, gridLine));\n\n                majorTicks.push(tickPosition);\n            }\n        }\n\n        if (majorGridLines.visible) {\n            this.traverseMajorTicksPositions(render, majorGridLines);\n        }\n\n        if (minorGridLines.visible) {\n            this.traverseMinorTicksPositions(render, minorGridLines);\n        }\n\n        return container.children;\n    };\n\n    LogarithmicAxis.prototype.traverseMajorTicksPositions = function traverseMajorTicksPositions (callback, tickOptions) {\n        var ref = this.lineInfo();\n        var lineStart = ref.lineStart;\n        var step = ref.step;\n        var ref$1 = this;\n        var logMin = ref$1.logMin;\n        var logMax = ref$1.logMax;\n\n        for (var power = Math.ceil(logMin) + tickOptions.skip; power <= logMax; power += tickOptions.step) {\n            var position = round(lineStart + step * (power - logMin), DEFAULT_PRECISION);\n            callback(position, tickOptions);\n        }\n    };\n\n    LogarithmicAxis.prototype.traverseMinorTicksPositions = function traverseMinorTicksPositions (callback, tickOptions) {\n        var this$1 = this;\n\n        var ref = this.options;\n        var min = ref.min;\n        var max = ref.max;\n        var minorUnit = ref.minorUnit;\n        var base = ref.majorUnit;\n        var ref$1 = this.lineInfo();\n        var lineStart = ref$1.lineStart;\n        var step = ref$1.step;\n        var ref$2 = this;\n        var logMin = ref$2.logMin;\n        var logMax = ref$2.logMax;\n        var start = Math.floor(logMin);\n\n        for (var power = start; power < logMax; power++) {\n            var minorOptions = this$1._minorIntervalOptions(power);\n            for (var idx = tickOptions.skip; idx < minorUnit; idx += tickOptions.step) {\n                var value = minorOptions.value + idx * minorOptions.minorStep;\n                if (value > max) {\n                    break;\n                }\n                if (value >= min) {\n                    var position = round(lineStart + step * (log(value, base) - logMin), DEFAULT_PRECISION);\n                    callback(position, tickOptions);\n                }\n            }\n        }\n    };\n\n    LogarithmicAxis.prototype.createAxisLabel = function createAxisLabel (index, labelOptions, labelContext) {\n        var power = Math.ceil(this.logMin + index);\n        var value = Math.pow(this.options.majorUnit, power);\n        var text = this.axisLabelText(value, labelOptions, labelContext);\n\n        return new AxisLabel(value, text, index, null, labelOptions);\n    };\n\n    LogarithmicAxis.prototype.shouldRenderNote = function shouldRenderNote (value) {\n        var range = this.range();\n        return range.min <= value && value <= range.max;\n    };\n\n    LogarithmicAxis.prototype.pan = function pan (delta) {\n        var range = this.translateRange(delta);\n        return this.limitRange(range.min, range.max, this.totalMin, this.totalMax, range.offset);\n    };\n\n    LogarithmicAxis.prototype.pointsRange = function pointsRange (start, end) {\n        var startValue = this.getValue(start);\n        var endValue = this.getValue(end);\n        var min = Math.min(startValue, endValue);\n        var max = Math.max(startValue, endValue);\n\n        return {\n            min: min,\n            max: max\n        };\n    };\n\n    LogarithmicAxis.prototype.scaleRange = function scaleRange (scale, cursor) {\n        var ref = this.options;\n        var base = ref.majorUnit;\n        var logMin = log(this.options.min, base);\n        var logMax = log(this.options.max, base);\n        var position = Math.abs(this.pointOffset(cursor));\n        var range = logMax - logMin;\n        var delta = this.scaleToDelta(scale, range);\n        var min = Math.pow(base, logMin + position * delta);\n        var max = Math.pow(base, logMax - (1 - position) * delta);\n\n        if (max - min < MIN_VALUE_RANGE) {\n            max = min + MIN_VALUE_RANGE;\n        }\n\n        return {\n            min: min,\n            max: max\n        };\n    };\n\n    LogarithmicAxis.prototype.zoomRange = function zoomRange (scale, cursor) {\n        var range = this.scaleRange(scale, cursor);\n        var ref = this;\n        var totalMin = ref.totalMin;\n        var totalMax = ref.totalMax;\n\n        return {\n            min: limitValue(range.min, totalMin, totalMax),\n            max: limitValue(range.max, totalMin, totalMax)\n        };\n    };\n\n    LogarithmicAxis.prototype._minorIntervalOptions = function _minorIntervalOptions (power) {\n        var ref = this.options;\n        var minorUnit = ref.minorUnit;\n        var base = ref.majorUnit;\n        var value = Math.pow(base, power);\n        var nextValue = Math.pow(base, power + 1);\n        var difference = nextValue - value;\n        var minorStep = difference / minorUnit;\n\n        return {\n            value: value,\n            minorStep: minorStep\n        };\n    };\n\n    LogarithmicAxis.prototype.lineInfo = function lineInfo () {\n        var info = Axis.prototype.lineInfo.call(this);\n        info.step = info.axisDir * (info.lineSize / (this.logMax - this.logMin));\n\n        return info;\n    };\n\n    return LogarithmicAxis;\n}(Axis));\n\nfunction initRange(autoMin, autoMax, axisOptions, options) {\n    var min = axisOptions.min;\n    var max = axisOptions.max;\n\n    if (defined(axisOptions.axisCrossingValue) && axisOptions.axisCrossingValue <= 0) {\n        throwNegativeValuesError();\n    }\n\n    if (!defined(options.max)) {\n        max = autoMax;\n    } else if (options.max <= 0) {\n        throwNegativeValuesError();\n    }\n\n    if (!defined(options.min)) {\n        min = autoMin;\n    } else if (options.min <= 0) {\n        throwNegativeValuesError();\n    }\n\n    return {\n        min: min,\n        max: max\n    };\n}\n\nfunction autoAxisMin(min, max, options) {\n    var base = options.majorUnit;\n    var autoMin = min;\n    if (min <= 0) {\n        autoMin = max <= 1 ? Math.pow(base, -2) : 1;\n    } else if (!options.narrowRange) {\n        autoMin = Math.pow(base, Math.floor(log(min, base)));\n    }\n    return autoMin;\n}\n\nfunction autoAxisMax(max, base) {\n    var logMaxRemainder = round(log(max, base), DEFAULT_PRECISION) % 1;\n    var autoMax;\n    if (max <= 0) {\n        autoMax = base;\n    } else if (logMaxRemainder !== 0 && (logMaxRemainder < 0.3 || logMaxRemainder > 0.9)) {\n        autoMax = Math.pow(base, log(max, base) + 0.2);\n    } else {\n        autoMax = Math.pow(base, Math.ceil(log(max, base)));\n    }\n\n    return autoMax;\n}\n\nfunction throwNegativeValuesError() {\n    throw new Error(\"Non positive values cannot be used for a logarithmic axis\");\n}\n\nfunction log(x, base) {\n    return Math.log(x) / Math.log(base);\n}\n\nsetDefaultOptions(LogarithmicAxis, {\n    type: \"log\",\n    majorUnit: DEFAULT_MAJOR_UNIT,\n    minorUnit: 1,\n    axisCrossingValue: 1,\n    vertical: true,\n    majorGridLines: {\n        visible: true,\n        width: 1,\n        color: BLACK\n    },\n    zIndex: 1,\n    _deferLabels: true\n});\n\nexport default LogarithmicAxis;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}