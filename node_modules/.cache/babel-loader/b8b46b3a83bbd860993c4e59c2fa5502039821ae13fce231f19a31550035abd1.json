{"ast":null,"code":"import { toBitsString, toDecimal } from '../utils';\nimport { FreeCellVisitor } from './free-cell-visitor';\nimport { IsoEncoder } from './encoders/iso-encoder';\nimport { Utf8Encoder } from './encoders/utf8-encoder';\nimport { VersionsCodewordsInformation } from './version-codewords';\nimport { DataModeInstances } from './data-modes/data-mode-instances';\nvar terminator = \"0000\",\n  NUMERIC = \"numeric\",\n  ALPHA_NUMERIC = \"alphanumeric\",\n  BYTE = \"byte\",\n  powersOfTwo = {\n    \"1\": 0\n  },\n  powersOfTwoResult = {\n    \"0\": 1\n  },\n  irregularAlignmentPatternsStartDistance = {\n    15: 20,\n    16: 20,\n    18: 24,\n    19: 24,\n    22: 20,\n    24: 22,\n    26: 24,\n    28: 20,\n    30: 20,\n    31: 24,\n    32: 28,\n    33: 24,\n    36: 18,\n    37: 22,\n    39: 20,\n    40: 24\n  },\n  finderPattern = [1, 0, 1, 1, 1],\n  alignmentPattern = [1, 0, 1],\n  errorCorrectionPatterns = {\n    L: \"01\",\n    M: \"00\",\n    Q: \"11\",\n    H: \"10\"\n  },\n  formatMaskPattern = \"101010000010010\",\n  formatGeneratorPolynomial = \"10100110111\",\n  versionGeneratorPolynomial = \"1111100100101\",\n  paddingCodewords = [\"11101100\", \"00010001\"],\n  finderPatternValue = 93,\n  /* eslint-disable arrow-body-style */\n  /* eslint-disable no-unused-vars */\n  maskPatternConditions = [function (row, column) {\n    return (row + column) % 2 === 0;\n  }, function (row, column) {\n    return row % 2 === 0;\n  }, function (row, column) {\n    return column % 3 === 0;\n  }, function (row, column) {\n    return (row + column) % 3 === 0;\n  }, function (row, column) {\n    return (Math.floor(row / 2) + Math.floor(column / 3)) % 2 === 0;\n  }, function (row, column) {\n    return row * column % 2 + row * column % 3 === 0;\n  }, function (row, column) {\n    return (row * column % 2 + row * column % 3) % 2 === 0;\n  }, function (row, column) {\n    return ((row + column) % 2 + row * column % 3) % 2 === 0;\n  }],\n  /* eslint-enable no-unused-vars */\n  /* eslint-enable arrow-body-style */\n  numberRegex = /^\\d+/,\n  alphaPattern = \"A-Z0-9 $%*+./:-\",\n  alphaExclusiveSet = \"A-Z $%*+./:-\",\n  alphaRegex = new RegExp(\"^[\" + alphaExclusiveSet + \"]+\"),\n  alphaNumericRegex = new RegExp(\"^[\" + alphaPattern + \"]+\"),\n  byteRegex = new RegExp(\"^[^\" + alphaPattern + \"]+\"),\n  initMinNumericBeforeAlpha = 8,\n  initMinNumericBeforeByte = 5,\n  initMinAlphaBeforeByte = 8,\n  minNumericBeforeAlpha = 17,\n  minNumericBeforeByte = 9,\n  minAlphaBeforeByte = 16;\nexport var generatorPolynomials = [[1, 0], [1, 25, 0]];\nexport function fillFunctionCell(matrices, bit, x, y) {\n  for (var i = 0; i < matrices.length; i++) {\n    matrices[i][x][y] = bit;\n  }\n}\nexport function fillDataCell(matrices, bit, x, y) {\n  for (var i = 0; i < maskPatternConditions.length; i++) {\n    matrices[i][x][y] = maskPatternConditions[i](x, y) ? bit ^ 1 : parseInt(bit, 10);\n  }\n}\nexport function fillData(matrices, blocks) {\n  var cellVisitor = new FreeCellVisitor(matrices[0]),\n    block,\n    codewordIdx,\n    cell;\n  for (var blockIdx = 0; blockIdx < blocks.length; blockIdx++) {\n    block = blocks[blockIdx];\n    codewordIdx = 0;\n    while (block.length > 0) {\n      for (var i = 0; i < block.length; i++) {\n        for (var j = 0; j < 8; j++) {\n          cell = cellVisitor.getNextCell();\n          fillDataCell(matrices, block[i][codewordIdx].charAt(j), cell.row, cell.column);\n        }\n      }\n      codewordIdx++;\n      while (block[0] && codewordIdx === block[0].length) {\n        block.splice(0, 1);\n      }\n    }\n  }\n  while (cell = cellVisitor.getNextRemainderCell()) {\n    fillDataCell(matrices, 0, cell.row, cell.column);\n  }\n}\nexport function padDataString(initialDataString, totalDataCodewords) {\n  var dataBitsCount = totalDataCodewords * 8,\n    terminatorIndex = 0,\n    paddingCodewordIndex = 0;\n  var dataString = initialDataString;\n  while (dataString.length < dataBitsCount && terminatorIndex < terminator.length) {\n    dataString += terminator.charAt(terminatorIndex++);\n  }\n  if (dataString.length % 8 !== 0) {\n    dataString += new Array(9 - dataString.length % 8).join(\"0\");\n  }\n  while (dataString.length < dataBitsCount) {\n    dataString += paddingCodewords[paddingCodewordIndex];\n    paddingCodewordIndex ^= 1;\n  }\n  return dataString;\n}\nexport function generatePowersOfTwo() {\n  var result;\n  var power;\n  for (power = 1; power < 255; power++) {\n    result = powersOfTwoResult[power - 1] * 2;\n    if (result > 255) {\n      result = result ^ 285;\n    }\n    powersOfTwoResult[power] = result;\n    powersOfTwo[result] = power;\n  }\n  result = powersOfTwoResult[power - 1] * 2 ^ 285;\n  powersOfTwoResult[power] = result;\n  powersOfTwoResult[-1] = 0;\n}\nexport function xorPolynomials(x, y) {\n  var result = [],\n    idx = x.length - 2;\n  for (var i = idx; i >= 0; i--) {\n    result[i] = x[i] ^ y[i];\n  }\n  return result;\n}\nexport function multiplyPolynomials(x, y) {\n  var result = [];\n  for (var i = 0; i < x.length; i++) {\n    for (var j = 0; j < y.length; j++) {\n      if (result[i + j] === undefined) {\n        result[i + j] = (x[i] + (y[j] >= 0 ? y[j] : 0)) % 255;\n      } else {\n        result[i + j] = powersOfTwo[powersOfTwoResult[result[i + j]] ^ powersOfTwoResult[(x[i] + y[j]) % 255]];\n      }\n    }\n  }\n  return result;\n}\nexport function generateGeneratorPolynomials() {\n  var maxErrorCorrectionCodeWordsCount = 68;\n  for (var idx = 2; idx <= maxErrorCorrectionCodeWordsCount; idx++) {\n    var firstPolynomial = generatorPolynomials[idx - 1],\n      secondPolynomial = [idx, 0];\n    generatorPolynomials[idx] = multiplyPolynomials(firstPolynomial, secondPolynomial);\n  }\n}\n\n//possibly generate on demand\ngeneratePowersOfTwo();\ngenerateGeneratorPolynomials();\nexport function multiplyByConstant(polynomial, power) {\n  var result = [],\n    idx = polynomial.length - 1;\n  do {\n    result[idx] = powersOfTwoResult[(polynomial[idx] + power) % 255];\n    idx--;\n  } while (polynomial[idx] !== undefined);\n  return result;\n}\nexport function generateErrorCodewords(data, errorCodewordsCount) {\n  var generator = generatorPolynomials[errorCodewordsCount - 1],\n    result = new Array(errorCodewordsCount).concat(data),\n    generatorPolynomial = new Array(result.length - generator.length).concat(generator),\n    steps = data.length,\n    errorCodewords = [],\n    divisor,\n    idx;\n  for (idx = 0; idx < steps; idx++) {\n    divisor = multiplyByConstant(generatorPolynomial, powersOfTwo[result[result.length - 1]]);\n    generatorPolynomial.splice(0, 1);\n    result = xorPolynomials(divisor, result);\n  }\n  for (idx = result.length - 1; idx >= 0; idx--) {\n    errorCodewords[errorCodewordsCount - 1 - idx] = toBitsString(result[idx], 8);\n  }\n  return errorCodewords;\n}\nexport function getBlocks(dataStream, versionCodewordsInformation) {\n  var codewordStart = 0,\n    dataBlocks = [],\n    errorBlocks = [],\n    dataBlock,\n    versionGroups = versionCodewordsInformation.groups,\n    blockCodewordsCount,\n    groupBlocksCount,\n    messagePolynomial,\n    codeword;\n  for (var groupIdx = 0; groupIdx < versionGroups.length; groupIdx++) {\n    groupBlocksCount = versionGroups[groupIdx][0];\n    for (var blockIdx = 0; blockIdx < groupBlocksCount; blockIdx++) {\n      blockCodewordsCount = versionGroups[groupIdx][1];\n      dataBlock = [];\n      messagePolynomial = [];\n      for (var codewordIdx = 1; codewordIdx <= blockCodewordsCount; codewordIdx++) {\n        codeword = dataStream.substring(codewordStart, codewordStart + 8);\n        dataBlock.push(codeword);\n        messagePolynomial[blockCodewordsCount - codewordIdx] = toDecimal(codeword);\n        codewordStart += 8;\n      }\n      dataBlocks.push(dataBlock);\n      errorBlocks.push(generateErrorCodewords(messagePolynomial, versionCodewordsInformation.errorCodewordsPerBlock));\n    }\n  }\n  return [dataBlocks, errorBlocks];\n}\nexport function chooseMode(str, minNumericBeforeAlpha, minNumericBeforeByte, minAlphaBeforeByte, previousMode) {\n  var numeric = numberRegex.exec(str),\n    numericMatch = numeric ? numeric[0] : \"\",\n    alpha = alphaRegex.exec(str),\n    alphaMatch = alpha ? alpha[0] : \"\",\n    alphaNumeric = alphaNumericRegex.exec(str),\n    alphaNumericMatch = alphaNumeric ? alphaNumeric[0] : \"\",\n    mode,\n    modeString;\n  if (numericMatch && (numericMatch.length >= minNumericBeforeAlpha || str.length === numericMatch.length || numericMatch.length >= minNumericBeforeByte && !alphaNumericRegex.test(str.charAt(numericMatch.length)))) {\n    mode = NUMERIC;\n    modeString = numericMatch;\n  } else if (alphaNumericMatch && (str.length === alphaNumericMatch.length || alphaNumericMatch.length >= minAlphaBeforeByte || previousMode === ALPHA_NUMERIC)) {\n    mode = ALPHA_NUMERIC;\n    modeString = numericMatch || alphaMatch;\n  } else {\n    mode = BYTE;\n    if (alphaNumericMatch) {\n      modeString = alphaNumericMatch + byteRegex.exec(str.substring(alphaNumericMatch.length))[0];\n    } else {\n      modeString = byteRegex.exec(str)[0];\n    }\n  }\n  return {\n    mode: mode,\n    modeString: modeString\n  };\n}\nexport function getModes(inputString) {\n  var modes = [],\n    previousMode,\n    idx = 0;\n  var str = inputString;\n  modes.push(chooseMode(str, initMinNumericBeforeAlpha, initMinNumericBeforeByte, initMinAlphaBeforeByte, previousMode));\n  previousMode = modes[0].mode;\n  str = str.substr(modes[0].modeString.length);\n  while (str.length > 0) {\n    var nextMode = chooseMode(str, minNumericBeforeAlpha, minNumericBeforeByte, minAlphaBeforeByte, previousMode);\n    if (nextMode.mode !== previousMode) {\n      previousMode = nextMode.mode;\n      modes.push(nextMode);\n      idx++;\n    } else {\n      modes[idx].modeString += nextMode.modeString;\n    }\n    str = str.substr(nextMode.modeString.length);\n  }\n  return modes;\n}\nexport function getDataCodewordsCount(modes) {\n  var length = 0,\n    mode;\n  for (var i = 0; i < modes.length; i++) {\n    mode = DataModeInstances[modes[i].mode];\n    length += mode.getStringBitsLength(modes[i].modeString.length);\n  }\n  return Math.ceil(length / 8);\n}\nexport function getVersion(dataCodewordsCount, errorCorrectionLevel) {\n  var x = 0,\n    y = VersionsCodewordsInformation.length - 1,\n    version = Math.floor(VersionsCodewordsInformation.length / 2);\n  do {\n    if (dataCodewordsCount < VersionsCodewordsInformation[version][errorCorrectionLevel].totalDataCodewords) {\n      y = version;\n    } else {\n      x = version;\n    }\n    version = x + Math.floor((y - x) / 2);\n  } while (y - x > 1);\n  if (dataCodewordsCount <= VersionsCodewordsInformation[x][errorCorrectionLevel].totalDataCodewords) {\n    return version + 1;\n  }\n  return y + 1;\n}\nexport function getDataString(modes, version) {\n  var dataString = \"\",\n    mode;\n  for (var i = 0; i < modes.length; i++) {\n    mode = DataModeInstances[modes[i].mode];\n    dataString += mode.encode(modes[i].modeString, version);\n  }\n  return dataString;\n}\n\n//fix case all zeros\nexport function encodeFormatInformation(format) {\n  var formatNumber = toDecimal(format),\n    encodedString,\n    result = \"\";\n  if (formatNumber === 0) {\n    return \"101010000010010\";\n  }\n  encodedString = encodeBCH(toDecimal(format), formatGeneratorPolynomial, 15);\n  for (var i = 0; i < encodedString.length; i++) {\n    result += encodedString.charAt(i) ^ formatMaskPattern.charAt(i);\n  }\n  return result;\n}\nexport function encodeBCH(value, generatorPolynomial, codeLength) {\n  var generatorNumber = toDecimal(generatorPolynomial),\n    polynomialLength = generatorPolynomial.length - 1,\n    valueNumber = value << polynomialLength,\n    length = codeLength - polynomialLength,\n    valueString = toBitsString(value, length),\n    result = dividePolynomials(valueNumber, generatorNumber);\n  result = valueString + toBitsString(result, polynomialLength);\n  return result;\n}\nexport function dividePolynomials(numberX, numberY) {\n  var yLength = numberY.toString(2).length,\n    xLength = numberX.toString(2).length;\n  var x = numberX;\n  do {\n    x ^= numberY << xLength - yLength;\n    xLength = x.toString(2).length;\n  } while (xLength >= yLength);\n  return x;\n}\nexport function getNumberAt(str, idx) {\n  return parseInt(str.charAt(idx), 10);\n}\nexport function initMatrices(version) {\n  var matrices = [],\n    modules = 17 + 4 * version;\n  for (var i = 0; i < maskPatternConditions.length; i++) {\n    matrices[i] = new Array(modules);\n    for (var j = 0; j < modules; j++) {\n      matrices[i][j] = new Array(modules);\n    }\n  }\n  return matrices;\n}\nexport function addFormatInformation(matrices, formatString) {\n  var matrix = matrices[0],\n    x,\n    y,\n    idx = 0,\n    length = formatString.length;\n  for (x = 0, y = 8; x <= 8; x++) {\n    if (x !== 6) {\n      fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x, y);\n    }\n  }\n  for (x = 8, y = 7; y >= 0; y--) {\n    if (y !== 6) {\n      fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x, y);\n    }\n  }\n  idx = 0;\n  for (y = matrix.length - 1, x = 8; y >= matrix.length - 8; y--) {\n    fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x, y);\n  }\n  fillFunctionCell(matrices, 1, matrix.length - 8, 8);\n  for (x = matrix.length - 7, y = 8; x < matrix.length; x++) {\n    fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x, y);\n  }\n}\nexport function encodeVersionInformation(version) {\n  return encodeBCH(version, versionGeneratorPolynomial, 18);\n}\nexport function addVersionInformation(matrices, dataString) {\n  var matrix = matrices[0],\n    modules = matrix.length,\n    x1 = 0,\n    y1 = modules - 11,\n    x2 = modules - 11,\n    y2 = 0,\n    quotient,\n    mod,\n    value;\n  for (var idx = 0; idx < dataString.length; idx++) {\n    quotient = Math.floor(idx / 3);\n    mod = idx % 3;\n    value = getNumberAt(dataString, dataString.length - idx - 1);\n    fillFunctionCell(matrices, value, x1 + quotient, y1 + mod);\n    fillFunctionCell(matrices, value, x2 + mod, y2 + quotient);\n  }\n}\nexport function addCentricPattern(matrices, pattern, x, y) {\n  var size = pattern.length + 2,\n    length = pattern.length + 1,\n    value;\n  for (var i = 0; i < pattern.length; i++) {\n    for (var j = i; j < size - i; j++) {\n      value = pattern[i];\n      fillFunctionCell(matrices, value, x + j, y + i);\n      fillFunctionCell(matrices, value, x + i, y + j);\n      fillFunctionCell(matrices, value, x + length - j, y + length - i);\n      fillFunctionCell(matrices, value, x + length - i, y + length - j);\n    }\n  }\n}\nexport function addFinderSeparator(matrices, direction, x, y) {\n  var nextX = x,\n    nextY = y,\n    matrix = matrices[0];\n  do {\n    fillFunctionCell(matrices, 0, nextX, y);\n    fillFunctionCell(matrices, 0, x, nextY);\n    nextX += direction[0];\n    nextY += direction[1];\n  } while (nextX >= 0 && nextX < matrix.length);\n}\nexport function addFinderPatterns(matrices) {\n  var modules = matrices[0].length;\n  addCentricPattern(matrices, finderPattern, 0, 0);\n  addFinderSeparator(matrices, [-1, -1], 7, 7);\n  addCentricPattern(matrices, finderPattern, modules - 7, 0);\n  addFinderSeparator(matrices, [1, -1], modules - 8, 7);\n  addCentricPattern(matrices, finderPattern, 0, modules - 7);\n  addFinderSeparator(matrices, [-1, 1], 7, modules - 8);\n}\nexport function addAlignmentPatterns(matrices, version) {\n  if (version < 2) {\n    return;\n  }\n  var matrix = matrices[0],\n    modules = matrix.length,\n    pointsCount = Math.floor(version / 7),\n    points = [6],\n    startDistance,\n    distance,\n    idx = 0;\n  if (startDistance = irregularAlignmentPatternsStartDistance[version]) {\n    distance = (modules - 13 - startDistance) / pointsCount;\n  } else {\n    startDistance = distance = (modules - 13) / (pointsCount + 1);\n  }\n  points.push(points[idx++] + startDistance);\n  while (points[idx] + distance < modules) {\n    points.push(points[idx++] + distance);\n  }\n  for (var i = 0; i < points.length; i++) {\n    for (var j = 0; j < points.length; j++) {\n      if (matrix[points[i]][points[j]] === undefined) {\n        addCentricPattern(matrices, alignmentPattern, points[i] - 2, points[j] - 2);\n      }\n    }\n  }\n}\nexport function addTimingFunctions(matrices) {\n  var row = 6,\n    column = 6,\n    value = 1,\n    modules = matrices[0].length;\n  for (var i = 8; i < modules - 8; i++) {\n    fillFunctionCell(matrices, value, row, i);\n    fillFunctionCell(matrices, value, i, column);\n    value ^= 1;\n  }\n}\nexport function scoreMaskMatrixes(matrices) {\n  var scores = [],\n    previousBits = [],\n    darkModules = [],\n    patterns = [],\n    adjacentSameBits = [],\n    matrix,\n    i,\n    row = 0,\n    column = 1,\n    modulesLength = matrices[0].length;\n  for (i = 0; i < matrices.length; i++) {\n    scores[i] = 0;\n    darkModules[i] = 0;\n    adjacentSameBits[i] = [0, 0];\n    patterns[i] = [0, 0];\n    previousBits[i] = [];\n  }\n  for (var rowIndex = 0; rowIndex < modulesLength; rowIndex++) {\n    for (var columnIndex = 0; columnIndex < modulesLength; columnIndex++) {\n      for (var matrixIndex = 0; matrixIndex < matrices.length; matrixIndex++) {\n        matrix = matrices[matrixIndex];\n        darkModules[matrixIndex] += parseInt(matrix[rowIndex][columnIndex], 10);\n        if (previousBits[matrixIndex][row] === matrix[rowIndex][columnIndex] && rowIndex + 1 < modulesLength && columnIndex - 1 >= 0 && matrix[rowIndex + 1][columnIndex] === previousBits[matrixIndex][row] && matrix[rowIndex + 1][columnIndex - 1] === previousBits[matrixIndex][row]) {\n          scores[matrixIndex] += 3;\n        }\n        scoreFinderPatternOccurance(matrixIndex, patterns, scores, row, matrix[rowIndex][columnIndex]);\n        scoreFinderPatternOccurance(matrixIndex, patterns, scores, column, matrix[columnIndex][rowIndex]);\n        scoreAdjacentSameBits(matrixIndex, scores, previousBits, matrix[rowIndex][columnIndex], adjacentSameBits, row);\n        scoreAdjacentSameBits(matrixIndex, scores, previousBits, matrix[columnIndex][rowIndex], adjacentSameBits, column);\n      }\n    }\n  }\n  var total = modulesLength * modulesLength,\n    minIdx,\n    min = Number.MAX_VALUE;\n  for (i = 0; i < scores.length; i++) {\n    scores[i] += calculateDarkModulesRatioScore(darkModules[i], total);\n    if (scores[i] < min) {\n      min = scores[i];\n      minIdx = i;\n    }\n  }\n  return minIdx;\n}\nexport function scoreFinderPatternOccurance(idx, patterns, scores, rowColumn, bit) {\n  patterns[idx][rowColumn] = (patterns[idx][rowColumn] << 1 ^ bit) % 128;\n  if (patterns[idx][rowColumn] === finderPatternValue) {\n    scores[idx] += 40;\n  }\n}\nexport function scoreAdjacentSameBits(idx, scores, previousBits, bit, adjacentBits, rowColumn) {\n  if (previousBits[idx][rowColumn] === bit) {\n    adjacentBits[idx][rowColumn]++;\n  } else {\n    previousBits[idx][rowColumn] = bit;\n    if (adjacentBits[idx][rowColumn] >= 5) {\n      scores[idx] += 3 + adjacentBits[idx][rowColumn] - 5;\n    }\n    adjacentBits[idx][rowColumn] = 1;\n  }\n}\nexport function calculateDarkModulesRatioScore(darkModules, total) {\n  var percent = Math.floor(darkModules / total * 100),\n    mod5 = percent % 5,\n    previous = Math.abs(percent - mod5 - 50),\n    next = Math.abs(percent + 5 - mod5 - 50),\n    score = 10 * Math.min(previous / 5, next / 5);\n  return score;\n}\nexport function createQRCodeDataEncoder(encoding) {\n  if (encoding && encoding.toLowerCase().indexOf(\"utf_8\") >= 0) {\n    return new Utf8Encoder();\n  }\n  return new IsoEncoder();\n}\nexport function encodeData(inputString, errorCorrectionLevel, encoding) {\n  var encoder = createQRCodeDataEncoder(encoding),\n    encodingResult = encoder.getEncodingResult(inputString, errorCorrectionLevel),\n    version = encodingResult.version,\n    versionInformation = VersionsCodewordsInformation[version - 1][errorCorrectionLevel],\n    dataString = padDataString(encodingResult.dataString, versionInformation.totalDataCodewords),\n    blocks = getBlocks(dataString, versionInformation),\n    matrices = initMatrices(version);\n  addFinderPatterns(matrices);\n  addAlignmentPatterns(matrices, version);\n  addTimingFunctions(matrices);\n  if (version >= 7) {\n    addVersionInformation(matrices, toBitsString(0, 18));\n  }\n  addFormatInformation(matrices, toBitsString(0, 15));\n  fillData(matrices, blocks);\n  var minIdx = scoreMaskMatrixes(matrices),\n    optimalMatrix = matrices[minIdx];\n  if (version >= 7) {\n    addVersionInformation([optimalMatrix], encodeVersionInformation(version));\n  }\n  var formatString = errorCorrectionPatterns[errorCorrectionLevel] + toBitsString(minIdx, 3);\n  addFormatInformation([optimalMatrix], encodeFormatInformation(formatString));\n  return optimalMatrix;\n}","map":{"version":3,"names":["toBitsString","toDecimal","FreeCellVisitor","IsoEncoder","Utf8Encoder","VersionsCodewordsInformation","DataModeInstances","terminator","NUMERIC","ALPHA_NUMERIC","BYTE","powersOfTwo","powersOfTwoResult","irregularAlignmentPatternsStartDistance","finderPattern","alignmentPattern","errorCorrectionPatterns","L","M","Q","H","formatMaskPattern","formatGeneratorPolynomial","versionGeneratorPolynomial","paddingCodewords","finderPatternValue","maskPatternConditions","row","column","Math","floor","numberRegex","alphaPattern","alphaExclusiveSet","alphaRegex","RegExp","alphaNumericRegex","byteRegex","initMinNumericBeforeAlpha","initMinNumericBeforeByte","initMinAlphaBeforeByte","minNumericBeforeAlpha","minNumericBeforeByte","minAlphaBeforeByte","generatorPolynomials","fillFunctionCell","matrices","bit","x","y","i","length","fillDataCell","parseInt","fillData","blocks","cellVisitor","block","codewordIdx","cell","blockIdx","j","getNextCell","charAt","splice","getNextRemainderCell","padDataString","initialDataString","totalDataCodewords","dataBitsCount","terminatorIndex","paddingCodewordIndex","dataString","Array","join","generatePowersOfTwo","result","power","xorPolynomials","idx","multiplyPolynomials","undefined","generateGeneratorPolynomials","maxErrorCorrectionCodeWordsCount","firstPolynomial","secondPolynomial","multiplyByConstant","polynomial","generateErrorCodewords","data","errorCodewordsCount","generator","concat","generatorPolynomial","steps","errorCodewords","divisor","getBlocks","dataStream","versionCodewordsInformation","codewordStart","dataBlocks","errorBlocks","dataBlock","versionGroups","groups","blockCodewordsCount","groupBlocksCount","messagePolynomial","codeword","groupIdx","substring","push","errorCodewordsPerBlock","chooseMode","str","previousMode","numeric","exec","numericMatch","alpha","alphaMatch","alphaNumeric","alphaNumericMatch","mode","modeString","test","getModes","inputString","modes","substr","nextMode","getDataCodewordsCount","getStringBitsLength","ceil","getVersion","dataCodewordsCount","errorCorrectionLevel","version","getDataString","encode","encodeFormatInformation","format","formatNumber","encodedString","encodeBCH","value","codeLength","generatorNumber","polynomialLength","valueNumber","valueString","dividePolynomials","numberX","numberY","yLength","toString","xLength","getNumberAt","initMatrices","modules","addFormatInformation","formatString","matrix","encodeVersionInformation","addVersionInformation","x1","y1","x2","y2","quotient","mod","addCentricPattern","pattern","size","addFinderSeparator","direction","nextX","nextY","addFinderPatterns","addAlignmentPatterns","pointsCount","points","startDistance","distance","addTimingFunctions","scoreMaskMatrixes","scores","previousBits","darkModules","patterns","adjacentSameBits","modulesLength","rowIndex","columnIndex","matrixIndex","scoreFinderPatternOccurance","scoreAdjacentSameBits","total","minIdx","min","Number","MAX_VALUE","calculateDarkModulesRatioScore","rowColumn","adjacentBits","percent","mod5","previous","abs","next","score","createQRCodeDataEncoder","encoding","toLowerCase","indexOf","encodeData","encoder","encodingResult","getEncodingResult","versionInformation","optimalMatrix"],"sources":["C:/Users/Павел/Desktop/react humster/my-app/node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/encoding.js"],"sourcesContent":["import {\n    toBitsString,\n    toDecimal\n} from '../utils';\nimport { FreeCellVisitor } from './free-cell-visitor';\nimport { IsoEncoder } from './encoders/iso-encoder';\nimport { Utf8Encoder } from './encoders/utf8-encoder';\nimport { VersionsCodewordsInformation } from './version-codewords';\nimport { DataModeInstances } from './data-modes/data-mode-instances';\n\nvar terminator = \"0000\",\n    NUMERIC = \"numeric\",\n    ALPHA_NUMERIC = \"alphanumeric\",\n    BYTE = \"byte\",\n    powersOfTwo = { \"1\": 0 },\n    powersOfTwoResult = { \"0\": 1 },\n    irregularAlignmentPatternsStartDistance = {\n        15: 20, 16: 20, 18: 24, 19: 24, 22: 20,\n        24: 22, 26: 24, 28: 20, 30: 20, 31: 24,\n        32: 28, 33: 24, 36: 18, 37: 22, 39: 20, 40: 24\n    },\n    finderPattern = [1, 0, 1, 1, 1],\n    alignmentPattern = [1, 0, 1],\n    errorCorrectionPatterns = { L: \"01\", M: \"00\", Q: \"11\", H: \"10\" },\n    formatMaskPattern = \"101010000010010\",\n    formatGeneratorPolynomial = \"10100110111\",\n    versionGeneratorPolynomial = \"1111100100101\",\n    paddingCodewords = [\"11101100\", \"00010001\"],\n    finderPatternValue = 93,\n    /* eslint-disable arrow-body-style */\n    /* eslint-disable no-unused-vars */\n    maskPatternConditions = [\n        function (row, column) { return (row + column) % 2 === 0; },\n        function (row, column) { return row % 2 === 0; },\n        function (row, column) { return column % 3 === 0; },\n        function (row, column) { return (row + column) % 3 === 0; },\n        function (row, column) { return (Math.floor(row / 2) + Math.floor(column / 3)) % 2 === 0; },\n        function (row, column) { return ((row * column) % 2) + ((row * column) % 3) === 0; },\n        function (row, column) { return (((row * column) % 2) + ((row * column) % 3)) % 2 === 0; },\n        function (row, column) { return (((row + column) % 2) + ((row * column) % 3)) % 2 === 0; }\n    ],\n    /* eslint-enable no-unused-vars */\n    /* eslint-enable arrow-body-style */\n    numberRegex = /^\\d+/,\n    alphaPattern = \"A-Z0-9 $%*+./:-\",\n    alphaExclusiveSet = \"A-Z $%*+./:-\",\n    alphaRegex = new RegExp(\"^[\" + alphaExclusiveSet + \"]+\"),\n    alphaNumericRegex = new RegExp(\"^[\" + alphaPattern + \"]+\"),\n    byteRegex = new RegExp(\"^[^\" + alphaPattern + \"]+\"),\n    initMinNumericBeforeAlpha = 8,\n    initMinNumericBeforeByte = 5,\n    initMinAlphaBeforeByte = 8,\n    minNumericBeforeAlpha = 17,\n    minNumericBeforeByte = 9,\n    minAlphaBeforeByte = 16;\n\nexport var generatorPolynomials = [[1, 0], [1, 25, 0]];\n\nexport function fillFunctionCell(matrices, bit, x, y) {\n    for (var i = 0; i < matrices.length; i++) {\n        matrices[i][x][y] = bit;\n    }\n}\n\nexport function fillDataCell(matrices, bit, x, y) {\n    for (var i = 0; i < maskPatternConditions.length; i++) {\n        matrices[i][x][y] = maskPatternConditions[i](x, y) ? bit ^ 1 : parseInt(bit, 10);\n    }\n}\n\nexport function fillData(matrices, blocks) {\n    var cellVisitor = new FreeCellVisitor(matrices[0]),\n        block,\n        codewordIdx,\n        cell;\n\n    for (var blockIdx = 0; blockIdx < blocks.length; blockIdx++) {\n        block = blocks[blockIdx];\n        codewordIdx = 0;\n\n        while (block.length > 0) {\n            for (var i = 0; i < block.length; i++) {\n                for (var j = 0; j < 8; j++) {\n                    cell = cellVisitor.getNextCell();\n                    fillDataCell(matrices, block[i][codewordIdx].charAt(j), cell.row, cell.column);\n                }\n            }\n\n            codewordIdx++;\n\n            while (block[0] && codewordIdx === block[0].length) {\n                block.splice(0, 1);\n            }\n        }\n    }\n\n    while ((cell = cellVisitor.getNextRemainderCell())) {\n        fillDataCell(matrices, 0, cell.row, cell.column);\n    }\n}\n\nexport function padDataString(initialDataString, totalDataCodewords) {\n    var dataBitsCount = totalDataCodewords * 8,\n        terminatorIndex = 0,\n        paddingCodewordIndex = 0;\n    var dataString = initialDataString;\n\n    while (dataString.length < dataBitsCount && terminatorIndex < terminator.length) {\n        dataString += terminator.charAt(terminatorIndex++);\n    }\n\n    if (dataString.length % 8 !== 0) {\n        dataString += new Array(9 - dataString.length % 8).join(\"0\");\n    }\n\n    while (dataString.length < dataBitsCount) {\n        dataString += paddingCodewords[paddingCodewordIndex];\n        paddingCodewordIndex ^= 1;\n    }\n\n    return dataString;\n}\n\nexport function generatePowersOfTwo() {\n    var result;\n    var power;\n\n    for (power = 1; power < 255; power++) {\n        result = powersOfTwoResult[power - 1] * 2;\n        if (result > 255) {\n            result = result ^ 285;\n        }\n\n        powersOfTwoResult[power] = result;\n        powersOfTwo[result] = power;\n    }\n\n    result = (powersOfTwoResult[power - 1] * 2) ^ 285;\n    powersOfTwoResult[power] = result;\n    powersOfTwoResult[-1] = 0;\n}\n\nexport function xorPolynomials(x, y) {\n    var result = [],\n        idx = x.length - 2;\n\n    for (var i = idx; i >= 0; i--) {\n        result[i] = x[i] ^ y[i];\n    }\n\n    return result;\n}\n\nexport function multiplyPolynomials(x, y) {\n    var result = [];\n\n    for (var i = 0; i < x.length; i++) {\n        for (var j = 0; j < y.length; j++) {\n            if (result[i + j] === undefined) {\n                result[i + j] = (x[i] + (y[j] >= 0 ? y[j] : 0)) % 255;\n            } else {\n                result[i + j] = powersOfTwo[powersOfTwoResult[result[i + j]] ^ powersOfTwoResult[(x[i] + y[j]) % 255]];\n            }\n        }\n    }\n\n    return result;\n}\n\nexport function generateGeneratorPolynomials() {\n    var maxErrorCorrectionCodeWordsCount = 68;\n\n    for (var idx = 2; idx <= maxErrorCorrectionCodeWordsCount; idx++) {\n        var firstPolynomial = generatorPolynomials[idx - 1],\n            secondPolynomial = [idx, 0];\n\n        generatorPolynomials[idx] = multiplyPolynomials(firstPolynomial, secondPolynomial);\n    }\n}\n\n//possibly generate on demand\ngeneratePowersOfTwo();\ngenerateGeneratorPolynomials();\n\nexport function multiplyByConstant(polynomial, power) {\n    var result = [],\n        idx = polynomial.length - 1;\n\n    do {\n        result[idx] = powersOfTwoResult[(polynomial[idx] + power) % 255];\n        idx--;\n    }\n    while (polynomial[idx] !== undefined);\n\n    return result;\n}\n\nexport function generateErrorCodewords(data, errorCodewordsCount) {\n    var generator = generatorPolynomials[errorCodewordsCount - 1],\n        result = new Array(errorCodewordsCount).concat(data),\n        generatorPolynomial = new Array(result.length - generator.length).concat(generator),\n        steps = data.length,\n        errorCodewords = [],\n        divisor,\n        idx;\n\n    for (idx = 0; idx < steps; idx++) {\n        divisor = multiplyByConstant(generatorPolynomial, powersOfTwo[result[result.length - 1]]);\n        generatorPolynomial.splice(0, 1);\n\n        result = xorPolynomials(divisor, result);\n    }\n\n    for (idx = result.length - 1; idx >= 0; idx--) {\n        errorCodewords[errorCodewordsCount - 1 - idx] = toBitsString(result[idx], 8);\n    }\n\n    return errorCodewords;\n}\n\nexport function getBlocks(dataStream, versionCodewordsInformation) {\n    var codewordStart = 0,\n        dataBlocks = [],\n        errorBlocks = [],\n        dataBlock,\n        versionGroups = versionCodewordsInformation.groups,\n        blockCodewordsCount,\n        groupBlocksCount,\n        messagePolynomial,\n        codeword;\n\n    for (var groupIdx = 0; groupIdx < versionGroups.length; groupIdx++) {\n        groupBlocksCount = versionGroups[groupIdx][0];\n\n        for (var blockIdx = 0; blockIdx < groupBlocksCount; blockIdx++) {\n            blockCodewordsCount = versionGroups[groupIdx][1];\n            dataBlock = [];\n            messagePolynomial = [];\n\n            for (var codewordIdx = 1; codewordIdx <= blockCodewordsCount; codewordIdx++) {\n                codeword = dataStream.substring(codewordStart, codewordStart + 8);\n                dataBlock.push(codeword);\n                messagePolynomial[blockCodewordsCount - codewordIdx] = toDecimal(codeword);\n                codewordStart += 8;\n            }\n\n            dataBlocks.push(dataBlock);\n            errorBlocks.push(generateErrorCodewords(messagePolynomial,\n                versionCodewordsInformation.errorCodewordsPerBlock));\n        }\n    }\n    return [dataBlocks, errorBlocks];\n}\n\nexport function chooseMode(str, minNumericBeforeAlpha, minNumericBeforeByte, minAlphaBeforeByte, previousMode) {\n    var numeric = numberRegex.exec(str),\n        numericMatch = numeric ? numeric[0] : \"\",\n        alpha = alphaRegex.exec(str),\n        alphaMatch = alpha ? alpha[0] : \"\",\n        alphaNumeric = alphaNumericRegex.exec(str),\n        alphaNumericMatch = alphaNumeric ? alphaNumeric[0] : \"\",\n        mode,\n        modeString;\n\n    if (numericMatch &&\n        (numericMatch.length >= minNumericBeforeAlpha || str.length === numericMatch.length ||\n        (numericMatch.length >= minNumericBeforeByte && !alphaNumericRegex.test(str.charAt(numericMatch.length))))) {\n        mode = NUMERIC;\n        modeString = numericMatch;\n    } else if (alphaNumericMatch && (str.length === alphaNumericMatch.length ||\n        alphaNumericMatch.length >= minAlphaBeforeByte || previousMode === ALPHA_NUMERIC)) {\n        mode = ALPHA_NUMERIC;\n        modeString = numericMatch || alphaMatch;\n    } else {\n        mode = BYTE;\n\n        if (alphaNumericMatch) {\n            modeString = alphaNumericMatch + byteRegex.exec(str.substring(alphaNumericMatch.length))[0];\n        } else {\n            modeString = byteRegex.exec(str)[0];\n        }\n    }\n\n    return {\n        mode: mode,\n        modeString: modeString\n    };\n}\n\nexport function getModes(inputString) {\n    var modes = [],\n        previousMode,\n        idx = 0;\n    var str = inputString;\n\n    modes.push(chooseMode(str, initMinNumericBeforeAlpha, initMinNumericBeforeByte, initMinAlphaBeforeByte, previousMode));\n    previousMode = modes[0].mode;\n    str = str.substr(modes[0].modeString.length);\n\n    while (str.length > 0) {\n        var nextMode = chooseMode(str, minNumericBeforeAlpha, minNumericBeforeByte, minAlphaBeforeByte, previousMode);\n\n        if (nextMode.mode !== previousMode) {\n            previousMode = nextMode.mode;\n            modes.push(nextMode);\n            idx++;\n        } else {\n            modes[idx].modeString += nextMode.modeString;\n        }\n\n        str = str.substr(nextMode.modeString.length);\n    }\n\n    return modes;\n}\n\nexport function getDataCodewordsCount(modes) {\n    var length = 0,\n        mode;\n\n    for (var i = 0; i < modes.length; i++) {\n        mode = DataModeInstances[modes[i].mode];\n        length += mode.getStringBitsLength(modes[i].modeString.length);\n    }\n\n    return Math.ceil(length / 8);\n}\n\nexport function getVersion(dataCodewordsCount, errorCorrectionLevel) {\n    var x = 0,\n        y = VersionsCodewordsInformation.length - 1,\n        version = Math.floor(VersionsCodewordsInformation.length / 2);\n\n    do {\n        if (dataCodewordsCount < VersionsCodewordsInformation[version][errorCorrectionLevel].totalDataCodewords) {\n            y = version;\n        } else {\n            x = version;\n        }\n\n        version = x + Math.floor((y - x) / 2);\n    } while (y - x > 1);\n\n    if (dataCodewordsCount <= VersionsCodewordsInformation[x][errorCorrectionLevel].totalDataCodewords) {\n        return version + 1;\n    }\n\n    return y + 1;\n}\n\nexport function getDataString(modes, version) {\n    var dataString = \"\",\n        mode;\n\n    for (var i = 0; i < modes.length; i++) {\n        mode = DataModeInstances[modes[i].mode];\n        dataString += mode.encode(modes[i].modeString, version);\n    }\n\n    return dataString;\n}\n\n//fix case all zeros\nexport function encodeFormatInformation(format) {\n    var formatNumber = toDecimal(format),\n        encodedString,\n        result = \"\";\n\n    if (formatNumber === 0) {\n        return \"101010000010010\";\n    }\n\n    encodedString = encodeBCH(toDecimal(format), formatGeneratorPolynomial, 15);\n\n    for (var i = 0; i < encodedString.length; i++) {\n        result += encodedString.charAt(i) ^ formatMaskPattern.charAt(i);\n    }\n\n    return result;\n}\n\nexport function encodeBCH(value, generatorPolynomial, codeLength) {\n    var generatorNumber = toDecimal(generatorPolynomial),\n        polynomialLength = generatorPolynomial.length - 1,\n        valueNumber = value << polynomialLength,\n        length = codeLength - polynomialLength,\n        valueString = toBitsString(value, length),\n        result = dividePolynomials(valueNumber, generatorNumber);\n\n    result = valueString + toBitsString(result, polynomialLength);\n\n    return result;\n}\n\nexport function dividePolynomials(numberX, numberY) {\n    var yLength = numberY.toString(2).length,\n        xLength = numberX.toString(2).length;\n    var x = numberX;\n\n    do {\n        x ^= numberY << xLength - yLength;\n        xLength = x.toString(2).length;\n    }\n    while (xLength >= yLength);\n\n    return x;\n}\n\nexport function getNumberAt(str, idx) {\n    return parseInt(str.charAt(idx), 10);\n}\n\nexport function initMatrices(version) {\n    var matrices = [],\n        modules = 17 + 4 * version;\n\n    for (var i = 0; i < maskPatternConditions.length; i++) {\n        matrices[i] = new Array(modules);\n\n        for (var j = 0; j < modules; j++) {\n            matrices[i][j] = new Array(modules);\n        }\n    }\n\n    return matrices;\n}\n\nexport function addFormatInformation(matrices, formatString) {\n    var matrix = matrices[0],\n        x,\n        y,\n        idx = 0,\n        length = formatString.length;\n\n    for (x = 0, y = 8; x <= 8; x++) {\n        if (x !== 6) {\n            fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x, y);\n        }\n    }\n\n    for (x = 8, y = 7; y >= 0; y--) {\n        if (y !== 6) {\n            fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x, y);\n        }\n    }\n\n    idx = 0;\n\n    for (y = matrix.length - 1, x = 8; y >= matrix.length - 8; y--) {\n        fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x, y);\n    }\n\n    fillFunctionCell(matrices, 1, matrix.length - 8, 8);\n\n    for (x = matrix.length - 7, y = 8; x < matrix.length; x++) {\n        fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x, y);\n    }\n}\n\nexport function encodeVersionInformation(version) {\n    return encodeBCH(version, versionGeneratorPolynomial, 18);\n}\n\nexport function addVersionInformation(matrices, dataString) {\n    var matrix = matrices[0],\n        modules = matrix.length,\n        x1 = 0,\n        y1 = modules - 11,\n        x2 = modules - 11,\n        y2 = 0,\n        quotient,\n        mod,\n        value;\n\n    for (var idx = 0; idx < dataString.length; idx++) {\n        quotient = Math.floor(idx / 3);\n        mod = idx % 3;\n        value = getNumberAt(dataString, dataString.length - idx - 1);\n\n        fillFunctionCell(matrices, value, x1 + quotient, y1 + mod);\n        fillFunctionCell(matrices, value, x2 + mod, y2 + quotient);\n    }\n}\n\nexport function addCentricPattern(matrices, pattern, x, y) {\n    var size = pattern.length + 2,\n        length = pattern.length + 1,\n        value;\n\n    for (var i = 0; i < pattern.length; i++) {\n        for (var j = i; j < size - i; j++) {\n            value = pattern[i];\n\n            fillFunctionCell(matrices, value, x + j, y + i);\n            fillFunctionCell(matrices, value, x + i, y + j);\n            fillFunctionCell(matrices, value, x + length - j, y + length - i);\n            fillFunctionCell(matrices, value, x + length - i, y + length - j);\n        }\n    }\n}\n\nexport function addFinderSeparator(matrices, direction, x, y) {\n    var nextX = x,\n        nextY = y,\n        matrix = matrices[0];\n\n    do {\n        fillFunctionCell(matrices, 0, nextX, y);\n        fillFunctionCell(matrices, 0, x, nextY);\n        nextX += direction[0];\n        nextY += direction[1];\n    }\n    while (nextX >= 0 && nextX < matrix.length);\n}\n\nexport function addFinderPatterns(matrices) {\n    var modules = matrices[0].length;\n\n    addCentricPattern(matrices, finderPattern, 0, 0);\n    addFinderSeparator(matrices, [-1, -1], 7, 7);\n    addCentricPattern(matrices, finderPattern, modules - 7, 0);\n    addFinderSeparator(matrices, [1, -1], modules - 8, 7);\n    addCentricPattern(matrices, finderPattern, 0, modules - 7);\n    addFinderSeparator(matrices, [-1, 1], 7, modules - 8);\n}\n\nexport function addAlignmentPatterns(matrices, version) {\n    if (version < 2) {\n        return;\n    }\n\n    var matrix = matrices[0],\n        modules = matrix.length,\n        pointsCount = Math.floor(version / 7),\n        points = [6],\n        startDistance,\n        distance,\n        idx = 0;\n\n    if ((startDistance = irregularAlignmentPatternsStartDistance[version])) {\n        distance = (modules - 13 - startDistance) / pointsCount;\n    } else {\n        startDistance = distance = (modules - 13) / (pointsCount + 1);\n    }\n\n    points.push(points[idx++] + startDistance);\n\n    while ((points[idx] + distance) < modules) {\n        points.push(points[idx++] + distance);\n    }\n\n    for (var i = 0; i < points.length; i++) {\n        for (var j = 0; j < points.length; j++) {\n            if (matrix[points[i]][points[j]] === undefined) {\n                addCentricPattern(matrices, alignmentPattern, points[i] - 2, points[j] - 2);\n            }\n        }\n    }\n}\n\nexport function addTimingFunctions(matrices) {\n    var row = 6,\n        column = 6,\n        value = 1,\n        modules = matrices[0].length;\n\n    for (var i = 8; i < modules - 8; i++) {\n        fillFunctionCell(matrices, value, row, i);\n        fillFunctionCell(matrices, value, i, column);\n        value ^= 1;\n    }\n}\n\nexport function scoreMaskMatrixes(matrices) {\n    var scores = [],\n        previousBits = [],\n        darkModules = [],\n        patterns = [],\n        adjacentSameBits = [],\n        matrix,\n        i,\n        row = 0,\n        column = 1,\n        modulesLength = matrices[0].length;\n\n    for (i = 0; i < matrices.length; i++) {\n        scores[i] = 0;\n        darkModules[i] = 0;\n        adjacentSameBits[i] = [0, 0];\n        patterns[i] = [0, 0];\n        previousBits[i] = [];\n    }\n\n    for (var rowIndex = 0; rowIndex < modulesLength; rowIndex++) {\n        for (var columnIndex = 0; columnIndex < modulesLength; columnIndex++) {\n            for (var matrixIndex = 0; matrixIndex < matrices.length; matrixIndex++) {\n                matrix = matrices[matrixIndex];\n                darkModules[matrixIndex] += parseInt(matrix[rowIndex][columnIndex], 10);\n\n                if (previousBits[matrixIndex][row] === matrix[rowIndex][columnIndex] &&\n                    rowIndex + 1 < modulesLength &&\n                    columnIndex - 1 >= 0 &&\n                    matrix[rowIndex + 1][columnIndex] === previousBits[matrixIndex][row] &&\n                    matrix[rowIndex + 1][columnIndex - 1] === previousBits[matrixIndex][row]) {\n                    scores[matrixIndex] += 3;\n                }\n\n                scoreFinderPatternOccurance(matrixIndex, patterns, scores, row, matrix[rowIndex][columnIndex]);\n                scoreFinderPatternOccurance(matrixIndex, patterns, scores, column, matrix[columnIndex][rowIndex]);\n                scoreAdjacentSameBits(matrixIndex, scores, previousBits, matrix[rowIndex][columnIndex], adjacentSameBits, row);\n                scoreAdjacentSameBits(matrixIndex, scores, previousBits, matrix[columnIndex][rowIndex], adjacentSameBits, column);\n            }\n        }\n    }\n\n    var total = modulesLength * modulesLength,\n        minIdx,\n        min = Number.MAX_VALUE;\n\n    for (i = 0; i < scores.length; i++) {\n        scores[i] += calculateDarkModulesRatioScore(darkModules[i], total);\n\n        if (scores[i] < min) {\n            min = scores[i];\n            minIdx = i;\n        }\n    }\n\n    return minIdx;\n}\n\nexport function scoreFinderPatternOccurance(idx, patterns, scores, rowColumn, bit) {\n    patterns[idx][rowColumn] = ((patterns[idx][rowColumn] << 1) ^ bit) % 128;\n\n    if (patterns[idx][rowColumn] === finderPatternValue) {\n        scores[idx] += 40;\n    }\n}\n\nexport function scoreAdjacentSameBits(idx, scores, previousBits, bit, adjacentBits, rowColumn) {\n    if (previousBits[idx][rowColumn] === bit) {\n        adjacentBits[idx][rowColumn]++;\n    } else {\n        previousBits[idx][rowColumn] = bit;\n\n        if (adjacentBits[idx][rowColumn] >= 5) {\n            scores[idx] += 3 + adjacentBits[idx][rowColumn] - 5;\n        }\n\n        adjacentBits[idx][rowColumn] = 1;\n    }\n}\n\nexport function calculateDarkModulesRatioScore(darkModules, total) {\n    var percent = Math.floor((darkModules / total) * 100),\n        mod5 = percent % 5,\n        previous = Math.abs(percent - mod5 - 50),\n        next = Math.abs(percent + 5 - mod5 - 50),\n        score = 10 * Math.min(previous / 5, next / 5);\n\n    return score;\n}\n\nexport function createQRCodeDataEncoder(encoding) {\n    if (encoding && encoding.toLowerCase().indexOf(\"utf_8\") >= 0) {\n        return new Utf8Encoder();\n    }\n\n    return new IsoEncoder();\n}\n\nexport function encodeData(inputString, errorCorrectionLevel, encoding) {\n    var encoder = createQRCodeDataEncoder(encoding),\n        encodingResult = encoder.getEncodingResult(inputString, errorCorrectionLevel),\n        version = encodingResult.version,\n        versionInformation = VersionsCodewordsInformation[version - 1][errorCorrectionLevel],\n        dataString = padDataString(encodingResult.dataString, versionInformation.totalDataCodewords),\n        blocks = getBlocks(dataString, versionInformation),\n        matrices = initMatrices(version);\n\n    addFinderPatterns(matrices);\n    addAlignmentPatterns(matrices, version);\n    addTimingFunctions(matrices);\n\n    if (version >= 7) {\n        addVersionInformation(matrices, toBitsString(0, 18));\n    }\n\n    addFormatInformation(matrices, toBitsString(0, 15));\n    fillData(matrices, blocks);\n\n    var minIdx = scoreMaskMatrixes(matrices),\n        optimalMatrix = matrices[minIdx];\n\n    if (version >= 7) {\n        addVersionInformation([optimalMatrix], encodeVersionInformation(version));\n    }\n\n    var formatString = errorCorrectionPatterns[errorCorrectionLevel] + toBitsString(minIdx, 3);\n    addFormatInformation([optimalMatrix], encodeFormatInformation(formatString));\n\n    return optimalMatrix;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}