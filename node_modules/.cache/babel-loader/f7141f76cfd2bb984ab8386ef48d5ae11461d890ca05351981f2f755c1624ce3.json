{"ast":null,"code":"import { geometry as g } from '@progress/kendo-drawing';\nimport { Class, setDefaultOptions, limitValue, rad, deg, deepExtend } from '../common';\nimport { Location } from './location';\nimport { datums } from './datums';\nvar math = Math,\n  atan = math.atan,\n  exp = math.exp,\n  pow = math.pow,\n  sin = math.sin,\n  log = math.log,\n  tan = math.tan,\n  Point = g.Point;\nvar PI = math.PI,\n  PI_DIV_2 = PI / 2,\n  PI_DIV_4 = PI / 4,\n  DEG_TO_RAD = PI / 180;\nvar WGS84 = datums.WGS84;\n\n// WGS 84 / World Mercator\nexport var Mercator = function (Class) {\n  function Mercator(options) {\n    Class.call(this);\n    this.initProperties();\n    this._initOptions(options);\n  }\n  if (Class) Mercator.__proto__ = Class;\n  Mercator.prototype = Object.create(Class && Class.prototype);\n  Mercator.prototype.constructor = Mercator;\n  Mercator.prototype._initOptions = function _initOptions(options) {\n    this.options = deepExtend({}, this.options, options);\n  };\n  Mercator.prototype.initProperties = function initProperties() {\n    // super.initProperties();\n\n    deepExtend(this, {\n      MAX_LNG: 180,\n      MAX_LAT: 85.0840590501,\n      INVERSE_ITERATIONS: 15,\n      INVERSE_CONVERGENCE: 1e-12\n    });\n  };\n  Mercator.prototype.forward = function forward(loc, clamp) {\n    var proj = this,\n      options = proj.options,\n      datum = options.datum,\n      r = datum.a,\n      lng0 = options.centralMeridian,\n      lat = limitValue(loc.lat, -proj.MAX_LAT, proj.MAX_LAT),\n      lng = clamp ? limitValue(loc.lng, -proj.MAX_LNG, proj.MAX_LNG) : loc.lng,\n      x = rad(lng - lng0) * r,\n      y = proj._projectLat(lat);\n    return new Point(x, y);\n  };\n  Mercator.prototype._projectLat = function _projectLat(lat) {\n    var datum = this.options.datum,\n      ecc = datum.e,\n      r = datum.a,\n      y = rad(lat),\n      ts = tan(PI_DIV_4 + y / 2),\n      con = ecc * sin(y),\n      p = pow((1 - con) / (1 + con), ecc / 2);\n\n    // See: http://en.wikipedia.org/wiki/Mercator_projection#Generalization_to_the_ellipsoid\n    return r * log(ts * p);\n  };\n  Mercator.prototype.inverse = function inverse(point, clamp) {\n    var proj = this,\n      options = proj.options,\n      datum = options.datum,\n      r = datum.a,\n      lng0 = options.centralMeridian,\n      lng = point.x / (DEG_TO_RAD * r) + lng0,\n      lat = limitValue(proj._inverseY(point.y), -proj.MAX_LAT, proj.MAX_LAT);\n    if (clamp) {\n      lng = limitValue(lng, -proj.MAX_LNG, proj.MAX_LNG);\n    }\n    return new Location(lat, lng);\n  };\n  Mercator.prototype._inverseY = function _inverseY(y) {\n    var proj = this,\n      datum = proj.options.datum,\n      r = datum.a,\n      ecc = datum.e,\n      ecch = ecc / 2,\n      ts = exp(-y / r),\n      phi = PI_DIV_2 - 2 * atan(ts),\n      i;\n    for (i = 0; i <= proj.INVERSE_ITERATIONS; i++) {\n      var con = ecc * sin(phi),\n        p = pow((1 - con) / (1 + con), ecch),\n        dphi = PI_DIV_2 - 2 * atan(ts * p) - phi;\n      phi += dphi;\n      if (math.abs(dphi) <= proj.INVERSE_CONVERGENCE) {\n        break;\n      }\n    }\n    return deg(phi);\n  };\n  return Mercator;\n}(Class);\nsetDefaultOptions(Mercator, {\n  centralMeridian: 0,\n  datum: WGS84\n});\n\n// WGS 84 / Pseudo-Mercator\n// Used by Google Maps, Bing, OSM, etc.\n// Spherical projection of ellipsoidal coordinates.\nexport var SphericalMercator = function (Mercator) {\n  function SphericalMercator() {\n    Mercator.apply(this, arguments);\n  }\n  if (Mercator) SphericalMercator.__proto__ = Mercator;\n  SphericalMercator.prototype = Object.create(Mercator && Mercator.prototype);\n  SphericalMercator.prototype.constructor = SphericalMercator;\n  SphericalMercator.prototype.initProperties = function initProperties() {\n    Mercator.prototype.initProperties.call(this);\n    deepExtend(this, {\n      MAX_LAT: 85.0511287798\n    });\n  };\n  SphericalMercator.prototype._projectLat = function _projectLat(lat) {\n    var r = this.options.datum.a,\n      y = rad(lat),\n      ts = tan(PI_DIV_4 + y / 2);\n    return r * log(ts);\n  };\n  SphericalMercator.prototype._inverseY = function _inverseY(y) {\n    var r = this.options.datum.a,\n      ts = exp(-y / r);\n    return deg(PI_DIV_2 - 2 * atan(ts));\n  };\n  return SphericalMercator;\n}(Mercator);\nexport var Equirectangular = function (Class) {\n  function Equirectangular() {\n    Class.apply(this, arguments);\n  }\n  if (Class) Equirectangular.__proto__ = Class;\n  Equirectangular.prototype = Object.create(Class && Class.prototype);\n  Equirectangular.prototype.constructor = Equirectangular;\n  Equirectangular.prototype.forward = function forward(loc) {\n    return new Point(loc.lng, loc.lat);\n  };\n  Equirectangular.prototype.inverse = function inverse(point) {\n    return new Location(point.y, point.x);\n  };\n  return Equirectangular;\n}(Class);\n\n// This is the projected coordinate system used for rendering maps in Google Maps, OpenStreetMap, etc\n// Unit: metre\n// Geodetic CRS: WGS 84\n// Scope: Certain Web mapping and visualisation applications. It is not a recognised geodetic system: for that see ellipsoidal Mercator CRS code 3395 (WGS 84 / World Mercator).\n// Remarks: Uses spherical development of ellipsoidal coordinates. Relative to WGS 84 / World Mercator (CRS code 3395) errors of 0.7 percent in scale and differences in northing of up to 43km in the map (equivalent to 21km on the ground) may arise.\n// Area of use: World between 85.06°S and 85.06°N.\n// Coordinate system: Cartesian 2D CS. Axes: easting, northing (X,Y). Orientations: east, north. UoM: m.\n// https://epsg.io/3857\nexport var EPSG3857 = function (Class) {\n  function EPSG3857() {\n    Class.call(this);\n    var crs = this,\n      proj = crs._proj = new SphericalMercator();\n    var c = this.c = 2 * PI * proj.options.datum.a;\n\n    // transfrom matrix\n    // Scale circumference to 1, mirror Y and shift origin to top left\n    this._tm = g.transform().translate(0.5, 0.5).scale(1 / c, -1 / c);\n\n    // Inverse transform matrix\n    this._itm = g.transform().scale(c, -c).translate(-0.5, -0.5);\n  }\n  if (Class) EPSG3857.__proto__ = Class;\n  EPSG3857.prototype = Object.create(Class && Class.prototype);\n  EPSG3857.prototype.constructor = EPSG3857;\n\n  // Location <-> Point (screen coordinates for a given scale)\n  EPSG3857.prototype.toPoint = function toPoint(loc, scale, clamp) {\n    var point = this._proj.forward(loc, clamp);\n    return point.transform(this._tm).scale(scale || 1);\n  };\n  EPSG3857.prototype.toLocation = function toLocation(point, scale, clamp) {\n    var newPoint = point.clone().scale(1 / (scale || 1)).transform(this._itm);\n    return this._proj.inverse(newPoint, clamp);\n  };\n  return EPSG3857;\n}(Class);\n\n// Unit: metre\n// Geodetic CRS: WGS 84\n// Scope: Very small scale mapping.\n// Remarks: Euro-centric view of world excluding polar areas.\n// Area of use: World between 80°S and 84°N.\n// Coordinate system: Cartesian 2D CS. Axes: easting, northing (E,N). Orientations: east, north. UoM: m.\n// https://epsg.io/3395\nexport var EPSG3395 = function (Class) {\n  function EPSG3395() {\n    Class.call(this);\n    this._proj = new Mercator();\n  }\n  if (Class) EPSG3395.__proto__ = Class;\n  EPSG3395.prototype = Object.create(Class && Class.prototype);\n  EPSG3395.prototype.constructor = EPSG3395;\n  EPSG3395.prototype.toPoint = function toPoint(loc) {\n    return this._proj.forward(loc);\n  };\n  EPSG3395.prototype.toLocation = function toLocation(point) {\n    return this._proj.inverse(point);\n  };\n  return EPSG3395;\n}(Class);\n\n// Unit: degree\n// Geodetic CRS: WGS 84\n// Scope: Horizontal component of 3D system. Used by the GPS satellite navigation system and for NATO military geodetic surveying.\n// Area of use: World.\n// Coordinate system: Ellipsoidal 2D CS. Axes: latitude, longitude. Orientations: north, east. UoM: degree\n// https://epsg.io/4326\nexport var EPSG4326 = function (Class) {\n  function EPSG4326() {\n    Class.call(this);\n    this._proj = new Equirectangular();\n  }\n  if (Class) EPSG4326.__proto__ = Class;\n  EPSG4326.prototype = Object.create(Class && Class.prototype);\n  EPSG4326.prototype.constructor = EPSG4326;\n  EPSG4326.prototype.toPoint = function toPoint(loc) {\n    return this._proj.forward(loc);\n  };\n  EPSG4326.prototype.toLocation = function toLocation(point) {\n    return this._proj.inverse(point);\n  };\n  return EPSG4326;\n}(Class);","map":{"version":3,"names":["geometry","g","Class","setDefaultOptions","limitValue","rad","deg","deepExtend","Location","datums","math","Math","atan","exp","pow","sin","log","tan","Point","PI","PI_DIV_2","PI_DIV_4","DEG_TO_RAD","WGS84","Mercator","options","call","initProperties","_initOptions","__proto__","prototype","Object","create","constructor","MAX_LNG","MAX_LAT","INVERSE_ITERATIONS","INVERSE_CONVERGENCE","forward","loc","clamp","proj","datum","r","a","lng0","centralMeridian","lat","lng","x","y","_projectLat","ecc","e","ts","con","p","inverse","point","_inverseY","ecch","phi","i","dphi","abs","SphericalMercator","apply","arguments","Equirectangular","EPSG3857","crs","_proj","c","_tm","transform","translate","scale","_itm","toPoint","toLocation","newPoint","clone","EPSG3395","EPSG4326"],"sources":["C:/Users/Павел/Desktop/react humster/my-app/node_modules/@progress/kendo-charts/dist/es/map/crs.js"],"sourcesContent":["import {\n    geometry as g\n} from '@progress/kendo-drawing';\n\nimport {\n    Class,\n    setDefaultOptions,\n    limitValue,\n    rad,\n    deg,\n    deepExtend\n} from '../common';\n\nimport {\n    Location\n} from './location';\n\nimport {\n    datums\n} from './datums';\n\n\nvar math = Math,\n    atan = math.atan,\n    exp = math.exp,\n    pow = math.pow,\n    sin = math.sin,\n    log = math.log,\n    tan = math.tan,\n    Point = g.Point;\n\nvar PI = math.PI,\n    PI_DIV_2 = PI / 2,\n    PI_DIV_4 = PI / 4,\n    DEG_TO_RAD = PI / 180;\n\nvar WGS84 = datums.WGS84;\n\n// WGS 84 / World Mercator\nexport var Mercator = (function (Class) {\n    function Mercator(options) {\n        Class.call(this);\n        this.initProperties();\n        this._initOptions(options);\n    }\n\n    if ( Class ) Mercator.__proto__ = Class;\n    Mercator.prototype = Object.create( Class && Class.prototype );\n    Mercator.prototype.constructor = Mercator;\n\n    Mercator.prototype._initOptions = function _initOptions (options) {\n        this.options = deepExtend({}, this.options, options);\n    };\n\n    Mercator.prototype.initProperties = function initProperties () {\n        // super.initProperties();\n\n        deepExtend(this, {\n            MAX_LNG: 180,\n            MAX_LAT: 85.0840590501,\n            INVERSE_ITERATIONS: 15,\n            INVERSE_CONVERGENCE: 1e-12\n        });\n    };\n\n    Mercator.prototype.forward = function forward (loc, clamp) {\n        var proj = this,\n            options = proj.options,\n            datum = options.datum,\n            r = datum.a,\n            lng0 = options.centralMeridian,\n            lat = limitValue(loc.lat, -proj.MAX_LAT, proj.MAX_LAT),\n            lng = clamp ? limitValue(loc.lng, -proj.MAX_LNG, proj.MAX_LNG) : loc.lng,\n            x = rad(lng - lng0) * r,\n            y = proj._projectLat(lat);\n        return new Point(x, y);\n    };\n    Mercator.prototype._projectLat = function _projectLat (lat) {\n        var datum = this.options.datum,\n            ecc = datum.e,\n            r = datum.a,\n            y = rad(lat),\n            ts = tan(PI_DIV_4 + y / 2),\n            con = ecc * sin(y),\n            p = pow((1 - con) / (1 + con), ecc / 2);\n\n        // See: http://en.wikipedia.org/wiki/Mercator_projection#Generalization_to_the_ellipsoid\n        return r * log(ts * p);\n    };\n    Mercator.prototype.inverse = function inverse (point, clamp) {\n        var proj = this,\n            options = proj.options,\n            datum = options.datum,\n            r = datum.a,\n            lng0 = options.centralMeridian,\n            lng = point.x / (DEG_TO_RAD * r) + lng0,\n            lat = limitValue(proj._inverseY(point.y), -proj.MAX_LAT, proj.MAX_LAT);\n        if (clamp) {\n            lng = limitValue(lng, -proj.MAX_LNG, proj.MAX_LNG);\n        }\n        return new Location(lat, lng);\n    };\n    Mercator.prototype._inverseY = function _inverseY (y) {\n        var proj = this,\n            datum = proj.options.datum,\n            r = datum.a,\n            ecc = datum.e,\n            ecch = ecc / 2,\n            ts = exp(-y / r),\n            phi = PI_DIV_2 - 2 * atan(ts),\n            i;\n        for (i = 0; i <= proj.INVERSE_ITERATIONS; i++) {\n            var con = ecc * sin(phi),\n                p = pow((1 - con) / (1 + con), ecch),\n                dphi = PI_DIV_2 - 2 * atan(ts * p) - phi;\n            phi += dphi;\n            if (math.abs(dphi) <= proj.INVERSE_CONVERGENCE) {\n                break;\n            }\n        }\n        return deg(phi);\n    };\n\n    return Mercator;\n}(Class));\n\nsetDefaultOptions(Mercator, {\n    centralMeridian: 0,\n    datum: WGS84\n});\n\n\n// WGS 84 / Pseudo-Mercator\n// Used by Google Maps, Bing, OSM, etc.\n// Spherical projection of ellipsoidal coordinates.\nexport var SphericalMercator = (function (Mercator) {\n    function SphericalMercator () {\n        Mercator.apply(this, arguments);\n    }\n\n    if ( Mercator ) SphericalMercator.__proto__ = Mercator;\n    SphericalMercator.prototype = Object.create( Mercator && Mercator.prototype );\n    SphericalMercator.prototype.constructor = SphericalMercator;\n\n    SphericalMercator.prototype.initProperties = function initProperties () {\n        Mercator.prototype.initProperties.call(this);\n\n        deepExtend(this, {\n            MAX_LAT: 85.0511287798\n        });\n    };\n\n    SphericalMercator.prototype._projectLat = function _projectLat (lat) {\n        var r = this.options.datum.a,\n            y = rad(lat),\n            ts = tan(PI_DIV_4 + y / 2);\n        return r * log(ts);\n    };\n\n    SphericalMercator.prototype._inverseY = function _inverseY (y) {\n        var r = this.options.datum.a,\n            ts = exp(-y / r);\n        return deg(PI_DIV_2 - 2 * atan(ts));\n    };\n\n    return SphericalMercator;\n}(Mercator));\n\nexport var Equirectangular = (function (Class) {\n    function Equirectangular () {\n        Class.apply(this, arguments);\n    }\n\n    if ( Class ) Equirectangular.__proto__ = Class;\n    Equirectangular.prototype = Object.create( Class && Class.prototype );\n    Equirectangular.prototype.constructor = Equirectangular;\n\n    Equirectangular.prototype.forward = function forward (loc) {\n        return new Point(loc.lng, loc.lat);\n    };\n    Equirectangular.prototype.inverse = function inverse (point) {\n        return new Location(point.y, point.x);\n    };\n\n    return Equirectangular;\n}(Class));\n\n// This is the projected coordinate system used for rendering maps in Google Maps, OpenStreetMap, etc\n// Unit: metre\n// Geodetic CRS: WGS 84\n// Scope: Certain Web mapping and visualisation applications. It is not a recognised geodetic system: for that see ellipsoidal Mercator CRS code 3395 (WGS 84 / World Mercator).\n// Remarks: Uses spherical development of ellipsoidal coordinates. Relative to WGS 84 / World Mercator (CRS code 3395) errors of 0.7 percent in scale and differences in northing of up to 43km in the map (equivalent to 21km on the ground) may arise.\n// Area of use: World between 85.06°S and 85.06°N.\n// Coordinate system: Cartesian 2D CS. Axes: easting, northing (X,Y). Orientations: east, north. UoM: m.\n// https://epsg.io/3857\nexport var EPSG3857 = (function (Class) {\n    function EPSG3857() {\n        Class.call(this);\n        var crs = this,\n            proj = crs._proj = new SphericalMercator();\n        var c = this.c = 2 * PI * proj.options.datum.a;\n\n        // transfrom matrix\n        // Scale circumference to 1, mirror Y and shift origin to top left\n        this._tm = g.transform().translate(0.5, 0.5).scale(1 / c, -1 / c);\n\n        // Inverse transform matrix\n        this._itm = g.transform().scale(c, -c).translate(-0.5, -0.5);\n    }\n\n    if ( Class ) EPSG3857.__proto__ = Class;\n    EPSG3857.prototype = Object.create( Class && Class.prototype );\n    EPSG3857.prototype.constructor = EPSG3857;\n\n    // Location <-> Point (screen coordinates for a given scale)\n    EPSG3857.prototype.toPoint = function toPoint (loc, scale, clamp) {\n        var point = this._proj.forward(loc, clamp);\n        return point.transform(this._tm).scale(scale || 1);\n    };\n    EPSG3857.prototype.toLocation = function toLocation (point, scale, clamp) {\n        var newPoint = point.clone().scale(1 / (scale || 1)).transform(this._itm);\n        return this._proj.inverse(newPoint, clamp);\n    };\n\n    return EPSG3857;\n}(Class));\n\n// Unit: metre\n// Geodetic CRS: WGS 84\n// Scope: Very small scale mapping.\n// Remarks: Euro-centric view of world excluding polar areas.\n// Area of use: World between 80°S and 84°N.\n// Coordinate system: Cartesian 2D CS. Axes: easting, northing (E,N). Orientations: east, north. UoM: m.\n// https://epsg.io/3395\nexport var EPSG3395 = (function (Class) {\n    function EPSG3395() {\n        Class.call(this);\n        this._proj = new Mercator();\n    }\n\n    if ( Class ) EPSG3395.__proto__ = Class;\n    EPSG3395.prototype = Object.create( Class && Class.prototype );\n    EPSG3395.prototype.constructor = EPSG3395;\n    EPSG3395.prototype.toPoint = function toPoint (loc) {\n        return this._proj.forward(loc);\n    };\n    EPSG3395.prototype.toLocation = function toLocation (point) {\n        return this._proj.inverse(point);\n    };\n\n    return EPSG3395;\n}(Class));\n\n// Unit: degree\n// Geodetic CRS: WGS 84\n// Scope: Horizontal component of 3D system. Used by the GPS satellite navigation system and for NATO military geodetic surveying.\n// Area of use: World.\n// Coordinate system: Ellipsoidal 2D CS. Axes: latitude, longitude. Orientations: north, east. UoM: degree\n// https://epsg.io/4326\nexport var EPSG4326 = (function (Class) {\n    function EPSG4326() {\n        Class.call(this);\n        this._proj = new Equirectangular();\n    }\n\n    if ( Class ) EPSG4326.__proto__ = Class;\n    EPSG4326.prototype = Object.create( Class && Class.prototype );\n    EPSG4326.prototype.constructor = EPSG4326;\n    EPSG4326.prototype.toPoint = function toPoint (loc) {\n        return this._proj.forward(loc);\n    };\n    EPSG4326.prototype.toLocation = function toLocation (point) {\n        return this._proj.inverse(point);\n    };\n\n    return EPSG4326;\n}(Class));\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}