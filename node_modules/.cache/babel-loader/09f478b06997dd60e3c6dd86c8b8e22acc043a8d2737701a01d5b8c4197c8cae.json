{"ast":null,"code":"import ErrorRangeCalculator from './error-bars/error-range-calculator';\nimport CategoricalErrorBar from './error-bars/categorical-error-bar';\nimport SeriesBinder from './series-binder';\nimport { ERROR_LOW_FIELD, ERROR_HIGH_FIELD } from './constants';\nimport evalOptions from './utils/eval-options';\nimport categoriesCount from './utils/categories-count';\nimport { ChartElement, Box } from '../core';\nimport { VALUE, STRING, MIN_VALUE, MAX_VALUE } from '../common/constants';\nimport { convertableToNumber, deepExtend, defined, isNumber, last, setDefaultOptions, sparseArrayLimits } from '../common';\nvar CategoricalChart = function (ChartElement) {\n  function CategoricalChart(plotArea, options) {\n    ChartElement.call(this, options);\n    this.plotArea = plotArea;\n    this.chartService = plotArea.chartService;\n    this.categoryAxis = plotArea.seriesCategoryAxis(options.series[0]);\n\n    // Value axis ranges grouped by axis name, e.g.:\n    // primary: { min: 0, max: 1 }\n    this.valueAxisRanges = {};\n    this.points = [];\n    this.categoryPoints = [];\n    this.seriesPoints = [];\n    this.seriesOptions = [];\n    this._evalSeries = [];\n    this.render();\n  }\n  if (ChartElement) CategoricalChart.__proto__ = ChartElement;\n  CategoricalChart.prototype = Object.create(ChartElement && ChartElement.prototype);\n  CategoricalChart.prototype.constructor = CategoricalChart;\n  CategoricalChart.prototype.render = function render() {\n    this.traverseDataPoints(this.addValue.bind(this));\n  };\n  CategoricalChart.prototype.pointOptions = function pointOptions(series, seriesIx) {\n    var options = this.seriesOptions[seriesIx];\n    if (!options) {\n      var defaults = this.pointType().prototype.defaults;\n      this.seriesOptions[seriesIx] = options = deepExtend({}, defaults, {\n        vertical: !this.options.invertAxes\n      }, series);\n    }\n    return options;\n  };\n  CategoricalChart.prototype.plotValue = function plotValue(point) {\n    if (!point) {\n      return 0;\n    }\n    if (this.options.isStacked100 && isNumber(point.value)) {\n      var categoryIx = point.categoryIx;\n      var categoryPoints = this.categoryPoints[categoryIx];\n      var otherValues = [];\n      var categorySum = 0;\n      for (var i = 0; i < categoryPoints.length; i++) {\n        var other = categoryPoints[i];\n        if (other) {\n          var stack = point.series.stack;\n          var otherStack = other.series.stack;\n          if (stack && otherStack && stack.group !== otherStack.group) {\n            continue;\n          }\n          if (isNumber(other.value)) {\n            categorySum += Math.abs(other.value);\n            otherValues.push(Math.abs(other.value));\n          }\n        }\n      }\n      if (categorySum > 0) {\n        return point.value / categorySum;\n      }\n    }\n    return point.value;\n  };\n  CategoricalChart.prototype.plotRange = function plotRange(point, startValue) {\n    var this$1 = this;\n    if (startValue === void 0) startValue = 0;\n    var categoryPoints = this.categoryPoints[point.categoryIx];\n    if (this.options.isStacked) {\n      var plotValue = this.plotValue(point);\n      var positive = plotValue >= 0;\n      var prevValue = startValue;\n      var isStackedBar = false;\n      for (var i = 0; i < categoryPoints.length; i++) {\n        var other = categoryPoints[i];\n        if (point === other) {\n          break;\n        }\n        var stack = point.series.stack;\n        var otherStack = other.series.stack;\n        if (stack && otherStack) {\n          if (typeof stack === STRING && stack !== otherStack) {\n            continue;\n          }\n          if (stack.group && stack.group !== otherStack.group) {\n            continue;\n          }\n        }\n        var otherValue = this$1.plotValue(other);\n        if (otherValue >= 0 && positive || otherValue < 0 && !positive) {\n          prevValue += otherValue;\n          plotValue += otherValue;\n          isStackedBar = true;\n          if (this$1.options.isStacked100) {\n            plotValue = Math.min(plotValue, 1);\n          }\n        }\n      }\n      if (isStackedBar) {\n        prevValue -= startValue;\n      }\n      return [prevValue, plotValue];\n    }\n    var series = point.series;\n    var valueAxis = this.seriesValueAxis(series);\n    var axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);\n    return [axisCrossingValue, convertableToNumber(point.value) ? point.value : axisCrossingValue];\n  };\n  CategoricalChart.prototype.stackLimits = function stackLimits(axisName, stackName) {\n    var this$1 = this;\n    var min = MAX_VALUE;\n    var max = MIN_VALUE;\n    for (var i = 0; i < this.categoryPoints.length; i++) {\n      var categoryPoints = this$1.categoryPoints[i];\n      if (!categoryPoints) {\n        continue;\n      }\n      for (var pIx = 0; pIx < categoryPoints.length; pIx++) {\n        var point = categoryPoints[pIx];\n        if (point) {\n          if (point.series.stack === stackName || point.series.axis === axisName) {\n            var to = this$1.plotRange(point, 0)[1];\n            if (defined(to) && isFinite(to)) {\n              max = Math.max(max, to);\n              min = Math.min(min, to);\n            }\n          }\n        }\n      }\n    }\n    return {\n      min: min,\n      max: max\n    };\n  };\n  CategoricalChart.prototype.updateStackRange = function updateStackRange() {\n    var this$1 = this;\n    var ref = this.options;\n    var isStacked = ref.isStacked;\n    var chartSeries = ref.series;\n    var limitsCache = {};\n    if (isStacked) {\n      for (var i = 0; i < chartSeries.length; i++) {\n        var series = chartSeries[i];\n        var axisName = series.axis;\n        var key = axisName + series.stack;\n        var limits = limitsCache[key];\n        if (!limits) {\n          limits = this$1.stackLimits(axisName, series.stack);\n          var errorTotals = this$1.errorTotals;\n          if (errorTotals) {\n            if (errorTotals.negative.length) {\n              limits.min = Math.min(limits.min, sparseArrayLimits(errorTotals.negative).min);\n            }\n            if (errorTotals.positive.length) {\n              limits.max = Math.max(limits.max, sparseArrayLimits(errorTotals.positive).max);\n            }\n          }\n          if (limits.min !== MAX_VALUE || limits.max !== MIN_VALUE) {\n            limitsCache[key] = limits;\n          } else {\n            limits = null;\n          }\n        }\n        if (limits) {\n          this$1.valueAxisRanges[axisName] = limits;\n        }\n      }\n    }\n  };\n  CategoricalChart.prototype.addErrorBar = function addErrorBar(point, data, categoryIx) {\n    var value = point.value;\n    var series = point.series;\n    var seriesIx = point.seriesIx;\n    var errorBars = point.options.errorBars;\n    var lowValue = data.fields[ERROR_LOW_FIELD];\n    var highValue = data.fields[ERROR_HIGH_FIELD];\n    var errorRange;\n    if (isNumber(lowValue) && isNumber(highValue)) {\n      errorRange = {\n        low: lowValue,\n        high: highValue\n      };\n    } else if (errorBars && defined(errorBars.value)) {\n      this.seriesErrorRanges = this.seriesErrorRanges || [];\n      this.seriesErrorRanges[seriesIx] = this.seriesErrorRanges[seriesIx] || new ErrorRangeCalculator(errorBars.value, series, VALUE);\n      errorRange = this.seriesErrorRanges[seriesIx].getErrorRange(value, errorBars.value);\n    }\n    if (errorRange) {\n      point.low = errorRange.low;\n      point.high = errorRange.high;\n      this.addPointErrorBar(point, categoryIx);\n    }\n  };\n  CategoricalChart.prototype.addPointErrorBar = function addPointErrorBar(point, categoryIx) {\n    var isVertical = !this.options.invertAxes;\n    var options = point.options.errorBars;\n    var series = point.series;\n    var low = point.low;\n    var high = point.high;\n    if (this.options.isStacked) {\n      var stackedErrorRange = this.stackedErrorRange(point, categoryIx);\n      low = stackedErrorRange.low;\n      high = stackedErrorRange.high;\n    } else {\n      var fields = {\n        categoryIx: categoryIx,\n        series: series\n      };\n      this.updateRange({\n        value: low\n      }, fields);\n      this.updateRange({\n        value: high\n      }, fields);\n    }\n    var errorBar = new CategoricalErrorBar(low, high, isVertical, this, series, options);\n    point.errorBars = [errorBar];\n    point.append(errorBar);\n  };\n  CategoricalChart.prototype.stackedErrorRange = function stackedErrorRange(point, categoryIx) {\n    var plotValue = this.plotRange(point, 0)[1] - point.value;\n    var low = point.low + plotValue;\n    var high = point.high + plotValue;\n    this.errorTotals = this.errorTotals || {\n      positive: [],\n      negative: []\n    };\n    if (low < 0) {\n      this.errorTotals.negative[categoryIx] = Math.min(this.errorTotals.negative[categoryIx] || 0, low);\n    }\n    if (high > 0) {\n      this.errorTotals.positive[categoryIx] = Math.max(this.errorTotals.positive[categoryIx] || 0, high);\n    }\n    return {\n      low: low,\n      high: high\n    };\n  };\n  CategoricalChart.prototype.addValue = function addValue(data, fields) {\n    var categoryIx = fields.categoryIx;\n    var series = fields.series;\n    var seriesIx = fields.seriesIx;\n    var categoryPoints = this.categoryPoints[categoryIx];\n    if (!categoryPoints) {\n      this.categoryPoints[categoryIx] = categoryPoints = [];\n    }\n    var seriesPoints = this.seriesPoints[seriesIx];\n    if (!seriesPoints) {\n      this.seriesPoints[seriesIx] = seriesPoints = [];\n    }\n    var point = this.createPoint(data, fields);\n    if (point) {\n      Object.assign(point, fields);\n      point.owner = this;\n      point.noteText = data.fields.noteText;\n      if (!defined(point.dataItem)) {\n        point.dataItem = series.data[categoryIx];\n      }\n      this.addErrorBar(point, data, categoryIx);\n    }\n    this.points.push(point);\n    seriesPoints.push(point);\n    categoryPoints.push(point);\n    this.updateRange(data.valueFields, fields);\n  };\n  CategoricalChart.prototype.evalPointOptions = function evalPointOptions(options, value, category, categoryIx, series, seriesIx) {\n    var state = {\n      defaults: series._defaults,\n      excluded: [\"data\", \"aggregate\", \"_events\", \"tooltip\", \"content\", \"template\", \"visual\", \"toggle\", \"_outOfRangeMinPoint\", \"_outOfRangeMaxPoint\"]\n    };\n    var doEval = this._evalSeries[seriesIx];\n    if (!defined(doEval)) {\n      this._evalSeries[seriesIx] = doEval = evalOptions(options, {}, state, true);\n    }\n    var pointOptions = options;\n    if (doEval) {\n      pointOptions = deepExtend({}, pointOptions);\n      evalOptions(pointOptions, {\n        value: value,\n        category: category,\n        index: categoryIx,\n        series: series,\n        dataItem: series.data[categoryIx]\n      }, state);\n    }\n    return pointOptions;\n  };\n  CategoricalChart.prototype.updateRange = function updateRange(data, fields) {\n    var axisName = fields.series.axis;\n    var value = data.value;\n    var axisRange = this.valueAxisRanges[axisName];\n    if (isFinite(value) && value !== null) {\n      axisRange = this.valueAxisRanges[axisName] = axisRange || {\n        min: MAX_VALUE,\n        max: MIN_VALUE\n      };\n      axisRange.min = Math.min(axisRange.min, value);\n      axisRange.max = Math.max(axisRange.max, value);\n    }\n  };\n  CategoricalChart.prototype.seriesValueAxis = function seriesValueAxis(series) {\n    var plotArea = this.plotArea;\n    var axisName = series.axis;\n    var axis = axisName ? plotArea.namedValueAxes[axisName] : plotArea.valueAxis;\n    if (!axis) {\n      throw new Error(\"Unable to locate value axis with name \" + axisName);\n    }\n    return axis;\n  };\n  CategoricalChart.prototype.reflow = function reflow(targetBox) {\n    var this$1 = this;\n    var categorySlots = this.categorySlots = [];\n    var chartPoints = this.points;\n    var categoryAxis = this.categoryAxis;\n    var pointIx = 0;\n    this.traverseDataPoints(function (data, fields) {\n      var categoryIx = fields.categoryIx;\n      var currentSeries = fields.series;\n      var valueAxis = this$1.seriesValueAxis(currentSeries);\n      var point = chartPoints[pointIx++];\n      var categorySlot = categorySlots[categoryIx];\n      if (!categorySlot) {\n        categorySlots[categoryIx] = categorySlot = this$1.categorySlot(categoryAxis, categoryIx, valueAxis);\n      }\n      if (point) {\n        var plotRange = this$1.plotRange(point, valueAxis.startValue());\n        var valueSlot = this$1.valueSlot(valueAxis, plotRange);\n        if (valueSlot) {\n          var pointSlot = this$1.pointSlot(categorySlot, valueSlot);\n          point.aboveAxis = this$1.aboveAxis(point, valueAxis);\n          point.stackValue = plotRange[1];\n          if (this$1.options.isStacked100) {\n            point.percentage = this$1.plotValue(point);\n          }\n          this$1.reflowPoint(point, pointSlot);\n        } else {\n          point.visible = false;\n        }\n      }\n    });\n    this.reflowCategories(categorySlots);\n    if (!this.options.clip && this.options.limitPoints && this.points.length) {\n      this.limitPoints();\n    }\n    this.box = targetBox;\n  };\n  CategoricalChart.prototype.valueSlot = function valueSlot(valueAxis, plotRange) {\n    return valueAxis.getSlot(plotRange[0], plotRange[1], !this.options.clip);\n  };\n  CategoricalChart.prototype.limitPoints = function limitPoints() {\n    var this$1 = this;\n    var categoryPoints = this.categoryPoints;\n    var points = categoryPoints[0].concat(last(categoryPoints));\n    for (var idx = 0; idx < points.length; idx++) {\n      if (points[idx]) {\n        this$1.limitPoint(points[idx]);\n      }\n    }\n  };\n  CategoricalChart.prototype.limitPoint = function limitPoint(point) {\n    var limittedSlot = this.categoryAxis.limitSlot(point.box);\n    if (!limittedSlot.equals(point.box)) {\n      point.reflow(limittedSlot);\n    }\n  };\n  CategoricalChart.prototype.aboveAxis = function aboveAxis(point, valueAxis) {\n    var axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);\n    var value = point.value;\n    return valueAxis.options.reverse ? value < axisCrossingValue : value >= axisCrossingValue;\n  };\n  CategoricalChart.prototype.categoryAxisCrossingValue = function categoryAxisCrossingValue(valueAxis) {\n    var categoryAxis = this.categoryAxis;\n    var options = valueAxis.options;\n    var crossingValues = [].concat(options.axisCrossingValues || options.axisCrossingValue);\n    return crossingValues[categoryAxis.axisIndex || 0] || 0;\n  };\n  CategoricalChart.prototype.reflowPoint = function reflowPoint(point, pointSlot) {\n    point.reflow(pointSlot);\n  };\n  CategoricalChart.prototype.reflowCategories = function reflowCategories() {};\n  CategoricalChart.prototype.pointSlot = function pointSlot(categorySlot, valueSlot) {\n    var options = this.options;\n    var invertAxes = options.invertAxes;\n    var slotX = invertAxes ? valueSlot : categorySlot;\n    var slotY = invertAxes ? categorySlot : valueSlot;\n    return new Box(slotX.x1, slotY.y1, slotX.x2, slotY.y2);\n  };\n  CategoricalChart.prototype.categorySlot = function categorySlot(categoryAxis, categoryIx) {\n    return categoryAxis.getSlot(categoryIx);\n  };\n  CategoricalChart.prototype.traverseDataPoints = function traverseDataPoints(callback) {\n    var this$1 = this;\n    var series = this.options.series;\n    var count = categoriesCount(series);\n    var seriesCount = series.length;\n    for (var seriesIx = 0; seriesIx < seriesCount; seriesIx++) {\n      this$1._outOfRangeCallback(series[seriesIx], \"_outOfRangeMinPoint\", seriesIx, callback);\n    }\n    for (var categoryIx = 0; categoryIx < count; categoryIx++) {\n      for (var seriesIx$1 = 0; seriesIx$1 < seriesCount; seriesIx$1++) {\n        var currentSeries = series[seriesIx$1];\n        var currentCategory = this$1.categoryAxis.categoryAt(categoryIx);\n        var pointData = this$1._bindPoint(currentSeries, seriesIx$1, categoryIx);\n        callback(pointData, {\n          category: currentCategory,\n          categoryIx: categoryIx,\n          categoriesCount: count,\n          series: currentSeries,\n          seriesIx: seriesIx$1\n        });\n      }\n    }\n    for (var seriesIx$2 = 0; seriesIx$2 < seriesCount; seriesIx$2++) {\n      this$1._outOfRangeCallback(series[seriesIx$2], \"_outOfRangeMaxPoint\", seriesIx$2, callback);\n    }\n  };\n  CategoricalChart.prototype._outOfRangeCallback = function _outOfRangeCallback(series, field, seriesIx, callback) {\n    var outOfRangePoint = series[field];\n    if (outOfRangePoint) {\n      var categoryIx = outOfRangePoint.categoryIx;\n      var pointData = this._bindPoint(series, seriesIx, categoryIx, outOfRangePoint.item);\n      callback(pointData, {\n        category: outOfRangePoint.category,\n        categoryIx: categoryIx,\n        series: series,\n        seriesIx: seriesIx,\n        dataItem: outOfRangePoint.item\n      });\n    }\n  };\n  CategoricalChart.prototype._bindPoint = function _bindPoint(series, seriesIx, categoryIx, item) {\n    if (!this._bindCache) {\n      this._bindCache = [];\n    }\n    var bindCache = this._bindCache[seriesIx];\n    if (!bindCache) {\n      bindCache = this._bindCache[seriesIx] = [];\n    }\n    var data = bindCache[categoryIx];\n    if (!data) {\n      data = bindCache[categoryIx] = SeriesBinder.current.bindPoint(series, categoryIx, item);\n    }\n    return data;\n  };\n  CategoricalChart.prototype.formatPointValue = function formatPointValue(point, format) {\n    if (point.value === null) {\n      return \"\";\n    }\n    return this.chartService.format.auto(format, point.value);\n  };\n  CategoricalChart.prototype.pointValue = function pointValue(data) {\n    return data.valueFields.value;\n  };\n  return CategoricalChart;\n}(ChartElement);\nsetDefaultOptions(CategoricalChart, {\n  series: [],\n  invertAxes: false,\n  isStacked: false,\n  clip: true,\n  limitPoints: true\n});\nexport default CategoricalChart;","map":{"version":3,"names":["ErrorRangeCalculator","CategoricalErrorBar","SeriesBinder","ERROR_LOW_FIELD","ERROR_HIGH_FIELD","evalOptions","categoriesCount","ChartElement","Box","VALUE","STRING","MIN_VALUE","MAX_VALUE","convertableToNumber","deepExtend","defined","isNumber","last","setDefaultOptions","sparseArrayLimits","CategoricalChart","plotArea","options","call","chartService","categoryAxis","seriesCategoryAxis","series","valueAxisRanges","points","categoryPoints","seriesPoints","seriesOptions","_evalSeries","render","__proto__","prototype","Object","create","constructor","traverseDataPoints","addValue","bind","pointOptions","seriesIx","defaults","pointType","vertical","invertAxes","plotValue","point","isStacked100","value","categoryIx","otherValues","categorySum","i","length","other","stack","otherStack","group","Math","abs","push","plotRange","startValue","this$1","isStacked","positive","prevValue","isStackedBar","otherValue","min","valueAxis","seriesValueAxis","axisCrossingValue","categoryAxisCrossingValue","stackLimits","axisName","stackName","max","pIx","axis","to","isFinite","updateStackRange","ref","chartSeries","limitsCache","key","limits","errorTotals","negative","addErrorBar","data","errorBars","lowValue","fields","highValue","errorRange","low","high","seriesErrorRanges","getErrorRange","addPointErrorBar","isVertical","stackedErrorRange","updateRange","errorBar","append","createPoint","assign","owner","noteText","dataItem","valueFields","evalPointOptions","category","state","_defaults","excluded","doEval","index","axisRange","namedValueAxes","Error","reflow","targetBox","categorySlots","chartPoints","pointIx","currentSeries","categorySlot","valueSlot","pointSlot","aboveAxis","stackValue","percentage","reflowPoint","visible","reflowCategories","clip","limitPoints","box","getSlot","concat","idx","limitPoint","limittedSlot","limitSlot","equals","reverse","crossingValues","axisCrossingValues","axisIndex","slotX","slotY","x1","y1","x2","y2","callback","count","seriesCount","_outOfRangeCallback","seriesIx$1","currentCategory","categoryAt","pointData","_bindPoint","seriesIx$2","field","outOfRangePoint","item","_bindCache","bindCache","current","bindPoint","formatPointValue","format","auto","pointValue"],"sources":["C:/Users/Павел/Desktop/react humster/my-app/node_modules/@progress/kendo-charts/dist/es/chart/categorical-chart.js"],"sourcesContent":["import ErrorRangeCalculator from './error-bars/error-range-calculator';\nimport CategoricalErrorBar from './error-bars/categorical-error-bar';\n\nimport SeriesBinder from './series-binder';\nimport { ERROR_LOW_FIELD, ERROR_HIGH_FIELD } from './constants';\n\nimport evalOptions from './utils/eval-options';\nimport categoriesCount from './utils/categories-count';\n\nimport { ChartElement, Box } from '../core';\n\nimport { VALUE, STRING, MIN_VALUE, MAX_VALUE } from '../common/constants';\nimport { convertableToNumber, deepExtend, defined, isNumber, last, setDefaultOptions, sparseArrayLimits } from '../common';\n\nvar CategoricalChart = (function (ChartElement) {\n    function CategoricalChart(plotArea, options) {\n        ChartElement.call(this, options);\n\n        this.plotArea = plotArea;\n        this.chartService = plotArea.chartService;\n        this.categoryAxis = plotArea.seriesCategoryAxis(options.series[0]);\n\n        // Value axis ranges grouped by axis name, e.g.:\n        // primary: { min: 0, max: 1 }\n        this.valueAxisRanges = {};\n\n        this.points = [];\n        this.categoryPoints = [];\n        this.seriesPoints = [];\n        this.seriesOptions = [];\n        this._evalSeries = [];\n\n        this.render();\n    }\n\n    if ( ChartElement ) CategoricalChart.__proto__ = ChartElement;\n    CategoricalChart.prototype = Object.create( ChartElement && ChartElement.prototype );\n    CategoricalChart.prototype.constructor = CategoricalChart;\n\n    CategoricalChart.prototype.render = function render () {\n        this.traverseDataPoints(this.addValue.bind(this));\n    };\n\n    CategoricalChart.prototype.pointOptions = function pointOptions (series, seriesIx) {\n        var options = this.seriesOptions[seriesIx];\n        if (!options) {\n            var defaults = this.pointType().prototype.defaults;\n            this.seriesOptions[seriesIx] = options = deepExtend({ }, defaults, {\n                vertical: !this.options.invertAxes\n            }, series);\n        }\n\n        return options;\n    };\n\n    CategoricalChart.prototype.plotValue = function plotValue (point) {\n        if (!point) {\n            return 0;\n        }\n\n        if (this.options.isStacked100 && isNumber(point.value)) {\n            var categoryIx = point.categoryIx;\n            var categoryPoints = this.categoryPoints[categoryIx];\n            var otherValues = [];\n            var categorySum = 0;\n\n            for (var i = 0; i < categoryPoints.length; i++) {\n                var other = categoryPoints[i];\n                if (other) {\n                    var stack = point.series.stack;\n                    var otherStack = other.series.stack;\n\n                    if ((stack && otherStack) && stack.group !== otherStack.group) {\n                        continue;\n                    }\n\n                    if (isNumber(other.value)) {\n                        categorySum += Math.abs(other.value);\n                        otherValues.push(Math.abs(other.value));\n                    }\n                }\n            }\n\n            if (categorySum > 0) {\n                return point.value / categorySum;\n            }\n        }\n\n        return point.value;\n    };\n\n    CategoricalChart.prototype.plotRange = function plotRange (point, startValue) {\n        var this$1 = this;\n        if ( startValue === void 0 ) startValue = 0;\n\n        var categoryPoints = this.categoryPoints[point.categoryIx];\n\n        if (this.options.isStacked) {\n            var plotValue = this.plotValue(point);\n            var positive = plotValue >= 0;\n            var prevValue = startValue;\n            var isStackedBar = false;\n\n            for (var i = 0; i < categoryPoints.length; i++) {\n                var other = categoryPoints[i];\n\n                if (point === other) {\n                    break;\n                }\n\n                var stack = point.series.stack;\n                var otherStack = other.series.stack;\n                if (stack && otherStack) {\n                    if (typeof stack === STRING && stack !== otherStack) {\n                        continue;\n                    }\n\n                    if (stack.group && stack.group !== otherStack.group) {\n                        continue;\n                    }\n                }\n\n                var otherValue = this$1.plotValue(other);\n                if ((otherValue >= 0 && positive) ||\n                    (otherValue < 0 && !positive)) {\n                    prevValue += otherValue;\n                    plotValue += otherValue;\n                    isStackedBar = true;\n\n                    if (this$1.options.isStacked100) {\n                        plotValue = Math.min(plotValue, 1);\n                    }\n                }\n            }\n\n            if (isStackedBar) {\n                prevValue -= startValue;\n            }\n\n            return [ prevValue, plotValue ];\n        }\n\n        var series = point.series;\n        var valueAxis = this.seriesValueAxis(series);\n        var axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);\n\n        return [ axisCrossingValue, convertableToNumber(point.value) ? point.value : axisCrossingValue ];\n    };\n\n    CategoricalChart.prototype.stackLimits = function stackLimits (axisName, stackName) {\n        var this$1 = this;\n\n        var min = MAX_VALUE;\n        var max = MIN_VALUE;\n\n        for (var i = 0; i < this.categoryPoints.length; i++) {\n            var categoryPoints = this$1.categoryPoints[i];\n            if (!categoryPoints) {\n                continue;\n            }\n\n            for (var pIx = 0; pIx < categoryPoints.length; pIx++) {\n                var point = categoryPoints[pIx];\n                if (point) {\n                    if (point.series.stack === stackName || point.series.axis === axisName) {\n                        var to = this$1.plotRange(point, 0)[1];\n                        if (defined(to) && isFinite(to)) {\n                            max = Math.max(max, to);\n                            min = Math.min(min, to);\n                        }\n                    }\n                }\n            }\n        }\n\n        return { min: min, max: max };\n    };\n\n    CategoricalChart.prototype.updateStackRange = function updateStackRange () {\n        var this$1 = this;\n\n        var ref = this.options;\n        var isStacked = ref.isStacked;\n        var chartSeries = ref.series;\n        var limitsCache = {};\n\n        if (isStacked) {\n            for (var i = 0; i < chartSeries.length; i++) {\n                var series = chartSeries[i];\n                var axisName = series.axis;\n                var key = axisName + series.stack;\n\n                var limits = limitsCache[key];\n                if (!limits) {\n                    limits = this$1.stackLimits(axisName, series.stack);\n\n                    var errorTotals = this$1.errorTotals;\n                    if (errorTotals) {\n                        if (errorTotals.negative.length) {\n                            limits.min = Math.min(limits.min, sparseArrayLimits(errorTotals.negative).min);\n                        }\n                        if (errorTotals.positive.length) {\n                            limits.max = Math.max(limits.max, sparseArrayLimits(errorTotals.positive).max);\n                        }\n                    }\n\n                    if (limits.min !== MAX_VALUE || limits.max !== MIN_VALUE) {\n                        limitsCache[key] = limits;\n                    } else {\n                        limits = null;\n                    }\n                }\n\n                if (limits) {\n                    this$1.valueAxisRanges[axisName] = limits;\n                }\n            }\n        }\n    };\n\n    CategoricalChart.prototype.addErrorBar = function addErrorBar (point, data, categoryIx) {\n        var value = point.value;\n        var series = point.series;\n        var seriesIx = point.seriesIx;\n        var errorBars = point.options.errorBars;\n        var lowValue = data.fields[ERROR_LOW_FIELD];\n        var highValue = data.fields[ERROR_HIGH_FIELD];\n        var errorRange;\n\n        if (isNumber(lowValue) && isNumber(highValue)) {\n            errorRange = { low: lowValue, high: highValue };\n        } else if (errorBars && defined(errorBars.value)) {\n            this.seriesErrorRanges = this.seriesErrorRanges || [];\n            this.seriesErrorRanges[seriesIx] = this.seriesErrorRanges[seriesIx] ||\n                new ErrorRangeCalculator(errorBars.value, series, VALUE);\n\n            errorRange = this.seriesErrorRanges[seriesIx].getErrorRange(value, errorBars.value);\n        }\n\n        if (errorRange) {\n            point.low = errorRange.low;\n            point.high = errorRange.high;\n            this.addPointErrorBar(point, categoryIx);\n        }\n    };\n\n    CategoricalChart.prototype.addPointErrorBar = function addPointErrorBar (point, categoryIx) {\n        var isVertical = !this.options.invertAxes;\n        var options = point.options.errorBars;\n        var series = point.series;\n        var low = point.low;\n        var high = point.high;\n\n        if (this.options.isStacked) {\n            var stackedErrorRange = this.stackedErrorRange(point, categoryIx);\n            low = stackedErrorRange.low;\n            high = stackedErrorRange.high;\n        } else {\n            var fields = { categoryIx: categoryIx, series: series };\n            this.updateRange({ value: low }, fields);\n            this.updateRange({ value: high }, fields);\n        }\n\n        var errorBar = new CategoricalErrorBar(low, high, isVertical, this, series, options);\n        point.errorBars = [ errorBar ];\n        point.append(errorBar);\n    };\n\n    CategoricalChart.prototype.stackedErrorRange = function stackedErrorRange (point, categoryIx) {\n        var plotValue = this.plotRange(point, 0)[1] - point.value;\n        var low = point.low + plotValue;\n        var high = point.high + plotValue;\n\n        this.errorTotals = this.errorTotals || { positive: [], negative: [] };\n\n        if (low < 0) {\n            this.errorTotals.negative[categoryIx] = Math.min(this.errorTotals.negative[categoryIx] || 0, low);\n        }\n\n        if (high > 0) {\n            this.errorTotals.positive[categoryIx] = Math.max(this.errorTotals.positive[categoryIx] || 0, high);\n        }\n\n        return { low: low, high: high };\n    };\n\n    CategoricalChart.prototype.addValue = function addValue (data, fields) {\n        var categoryIx = fields.categoryIx;\n        var series = fields.series;\n        var seriesIx = fields.seriesIx;\n\n        var categoryPoints = this.categoryPoints[categoryIx];\n        if (!categoryPoints) {\n            this.categoryPoints[categoryIx] = categoryPoints = [];\n        }\n\n        var seriesPoints = this.seriesPoints[seriesIx];\n        if (!seriesPoints) {\n            this.seriesPoints[seriesIx] = seriesPoints = [];\n        }\n\n        var point = this.createPoint(data, fields);\n        if (point) {\n            Object.assign(point, fields);\n\n            point.owner = this;\n            point.noteText = data.fields.noteText;\n            if (!defined(point.dataItem)) {\n                point.dataItem = series.data[categoryIx];\n            }\n            this.addErrorBar(point, data, categoryIx);\n        }\n\n        this.points.push(point);\n        seriesPoints.push(point);\n        categoryPoints.push(point);\n\n        this.updateRange(data.valueFields, fields);\n    };\n\n    CategoricalChart.prototype.evalPointOptions = function evalPointOptions (options, value, category, categoryIx, series, seriesIx) {\n        var state = { defaults: series._defaults, excluded: [ \"data\", \"aggregate\", \"_events\", \"tooltip\", \"content\", \"template\", \"visual\", \"toggle\", \"_outOfRangeMinPoint\", \"_outOfRangeMaxPoint\" ] };\n\n        var doEval = this._evalSeries[seriesIx];\n        if (!defined(doEval)) {\n            this._evalSeries[seriesIx] = doEval = evalOptions(options, {}, state, true);\n        }\n\n        var pointOptions = options;\n        if (doEval) {\n            pointOptions = deepExtend({}, pointOptions);\n            evalOptions(pointOptions, {\n                value: value,\n                category: category,\n                index: categoryIx,\n                series: series,\n                dataItem: series.data[categoryIx]\n            }, state);\n        }\n\n        return pointOptions;\n    };\n\n    CategoricalChart.prototype.updateRange = function updateRange (data, fields) {\n        var axisName = fields.series.axis;\n        var value = data.value;\n        var axisRange = this.valueAxisRanges[axisName];\n\n        if (isFinite(value) && value !== null) {\n            axisRange = this.valueAxisRanges[axisName] =\n                axisRange || { min: MAX_VALUE, max: MIN_VALUE };\n\n            axisRange.min = Math.min(axisRange.min, value);\n            axisRange.max = Math.max(axisRange.max, value);\n        }\n    };\n\n    CategoricalChart.prototype.seriesValueAxis = function seriesValueAxis (series) {\n        var plotArea = this.plotArea;\n        var axisName = series.axis;\n        var axis = axisName ? plotArea.namedValueAxes[axisName] : plotArea.valueAxis;\n\n        if (!axis) {\n            throw new Error(\"Unable to locate value axis with name \" + axisName);\n        }\n\n        return axis;\n    };\n\n    CategoricalChart.prototype.reflow = function reflow (targetBox) {\n        var this$1 = this;\n\n        var categorySlots = this.categorySlots = [];\n        var chartPoints = this.points;\n        var categoryAxis = this.categoryAxis;\n        var pointIx = 0;\n\n        this.traverseDataPoints(function (data, fields) {\n            var categoryIx = fields.categoryIx;\n            var currentSeries = fields.series;\n\n            var valueAxis = this$1.seriesValueAxis(currentSeries);\n            var point = chartPoints[pointIx++];\n\n            var categorySlot = categorySlots[categoryIx];\n            if (!categorySlot) {\n                categorySlots[categoryIx] = categorySlot =\n                    this$1.categorySlot(categoryAxis, categoryIx, valueAxis);\n            }\n\n            if (point) {\n                var plotRange = this$1.plotRange(point, valueAxis.startValue());\n                var valueSlot = this$1.valueSlot(valueAxis, plotRange);\n                if (valueSlot) {\n                    var pointSlot = this$1.pointSlot(categorySlot, valueSlot);\n\n                    point.aboveAxis = this$1.aboveAxis(point, valueAxis);\n                    point.stackValue = plotRange[1];\n\n                    if (this$1.options.isStacked100) {\n                        point.percentage = this$1.plotValue(point);\n                    }\n\n                    this$1.reflowPoint(point, pointSlot);\n                } else {\n                    point.visible = false;\n                }\n            }\n        });\n\n        this.reflowCategories(categorySlots);\n        if (!this.options.clip && this.options.limitPoints && this.points.length) {\n            this.limitPoints();\n        }\n\n        this.box = targetBox;\n    };\n\n    CategoricalChart.prototype.valueSlot = function valueSlot (valueAxis, plotRange) {\n        return valueAxis.getSlot(plotRange[0], plotRange[1], !this.options.clip);\n    };\n\n    CategoricalChart.prototype.limitPoints = function limitPoints () {\n        var this$1 = this;\n\n        var categoryPoints = this.categoryPoints;\n        var points = categoryPoints[0].concat(last(categoryPoints));\n        for (var idx = 0; idx < points.length; idx++) {\n            if (points[idx]) {\n                this$1.limitPoint(points[idx]);\n            }\n        }\n    };\n\n    CategoricalChart.prototype.limitPoint = function limitPoint (point) {\n        var limittedSlot = this.categoryAxis.limitSlot(point.box);\n        if (!limittedSlot.equals(point.box)) {\n            point.reflow(limittedSlot);\n        }\n    };\n\n    CategoricalChart.prototype.aboveAxis = function aboveAxis (point, valueAxis) {\n        var axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);\n        var value = point.value;\n\n        return valueAxis.options.reverse ?\n            value < axisCrossingValue : value >= axisCrossingValue;\n    };\n\n    CategoricalChart.prototype.categoryAxisCrossingValue = function categoryAxisCrossingValue (valueAxis) {\n        var categoryAxis = this.categoryAxis;\n        var options = valueAxis.options;\n        var crossingValues = [].concat(\n            options.axisCrossingValues || options.axisCrossingValue\n        );\n\n        return crossingValues[categoryAxis.axisIndex || 0] || 0;\n    };\n\n    CategoricalChart.prototype.reflowPoint = function reflowPoint (point, pointSlot) {\n        point.reflow(pointSlot);\n    };\n\n    CategoricalChart.prototype.reflowCategories = function reflowCategories () { };\n\n    CategoricalChart.prototype.pointSlot = function pointSlot (categorySlot, valueSlot) {\n        var options = this.options;\n        var invertAxes = options.invertAxes;\n        var slotX = invertAxes ? valueSlot : categorySlot;\n        var slotY = invertAxes ? categorySlot : valueSlot;\n\n        return new Box(slotX.x1, slotY.y1, slotX.x2, slotY.y2);\n    };\n\n    CategoricalChart.prototype.categorySlot = function categorySlot (categoryAxis, categoryIx) {\n        return categoryAxis.getSlot(categoryIx);\n    };\n\n    CategoricalChart.prototype.traverseDataPoints = function traverseDataPoints (callback) {\n        var this$1 = this;\n\n        var series = this.options.series;\n        var count = categoriesCount(series);\n        var seriesCount = series.length;\n\n        for (var seriesIx = 0; seriesIx < seriesCount; seriesIx++) {\n            this$1._outOfRangeCallback(series[seriesIx], \"_outOfRangeMinPoint\", seriesIx, callback);\n        }\n\n        for (var categoryIx = 0; categoryIx < count; categoryIx++) {\n            for (var seriesIx$1 = 0; seriesIx$1 < seriesCount; seriesIx$1++) {\n                var currentSeries = series[seriesIx$1];\n                var currentCategory = this$1.categoryAxis.categoryAt(categoryIx);\n                var pointData = this$1._bindPoint(currentSeries, seriesIx$1, categoryIx);\n\n                callback(pointData, {\n                    category: currentCategory,\n                    categoryIx: categoryIx,\n                    categoriesCount: count,\n                    series: currentSeries,\n                    seriesIx: seriesIx$1\n                });\n            }\n        }\n\n        for (var seriesIx$2 = 0; seriesIx$2 < seriesCount; seriesIx$2++) {\n            this$1._outOfRangeCallback(series[seriesIx$2], \"_outOfRangeMaxPoint\", seriesIx$2, callback);\n        }\n    };\n\n    CategoricalChart.prototype._outOfRangeCallback = function _outOfRangeCallback (series, field, seriesIx, callback) {\n        var outOfRangePoint = series[field];\n        if (outOfRangePoint) {\n            var categoryIx = outOfRangePoint.categoryIx;\n            var pointData = this._bindPoint(series, seriesIx, categoryIx, outOfRangePoint.item);\n\n            callback(pointData, {\n                category: outOfRangePoint.category,\n                categoryIx: categoryIx,\n                series: series,\n                seriesIx: seriesIx,\n                dataItem: outOfRangePoint.item\n            });\n        }\n    };\n\n    CategoricalChart.prototype._bindPoint = function _bindPoint (series, seriesIx, categoryIx, item) {\n        if (!this._bindCache) {\n            this._bindCache = [];\n        }\n\n        var bindCache = this._bindCache[seriesIx];\n        if (!bindCache) {\n            bindCache = this._bindCache[seriesIx] = [];\n        }\n\n        var data = bindCache[categoryIx];\n        if (!data) {\n            data = bindCache[categoryIx] = SeriesBinder.current.bindPoint(series, categoryIx, item);\n        }\n\n        return data;\n    };\n\n    CategoricalChart.prototype.formatPointValue = function formatPointValue (point, format) {\n        if (point.value === null) {\n            return \"\";\n        }\n\n        return this.chartService.format.auto(format, point.value);\n    };\n\n    CategoricalChart.prototype.pointValue = function pointValue (data) {\n        return data.valueFields.value;\n    };\n\n    return CategoricalChart;\n}(ChartElement));\n\nsetDefaultOptions(CategoricalChart, {\n    series: [],\n    invertAxes: false,\n    isStacked: false,\n    clip: true,\n    limitPoints: true\n});\n\nexport default CategoricalChart;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}