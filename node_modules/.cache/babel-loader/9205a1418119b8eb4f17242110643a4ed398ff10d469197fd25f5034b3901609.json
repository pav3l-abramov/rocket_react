{"ast":null,"code":"import { INTERPOLATE, ZERO } from '../constants';\nimport { convertableToNumber } from '../../common';\nimport SeriesBinder from '../series-binder';\nvar AREA_REGEX = /area/i;\nfunction seriesMissingValues(series) {\n  if (series.missingValues) {\n    return series.missingValues;\n  }\n  return AREA_REGEX.test(series.type) || series.stack ? ZERO : INTERPOLATE;\n}\nfunction hasValue(series, item) {\n  var fields = SeriesBinder.current.bindPoint(series, null, item);\n  var valueFields = fields.valueFields;\n  for (var field in valueFields) {\n    if (convertableToNumber(valueFields[field])) {\n      return true;\n    }\n  }\n}\nfunction findNext(ref) {\n  var start = ref.start;\n  var dir = ref.dir;\n  var min = ref.min;\n  var max = ref.max;\n  var getter = ref.getter;\n  var hasItem = ref.hasItem;\n  var series = ref.series;\n  var pointHasValue, outPoint;\n  var idx = start;\n  do {\n    idx += dir;\n    //aggregating and binding the item takes too much time for large number of categories\n    //will assume that if the aggregation does not create value for a missing item for one it will not create for others\n    if (hasItem(idx)) {\n      outPoint = getter(idx);\n      pointHasValue = hasValue(series, outPoint.item);\n    }\n  } while (min <= idx && idx <= max && !pointHasValue);\n  if (pointHasValue) {\n    return outPoint;\n  }\n}\nexport default function createOutOfRangePoints(series, range, count, getter, hasItem) {\n  var min = range.min;\n  var max = range.max;\n  var hasMinPoint = min > 0 && min < count;\n  var hasMaxPoint = max + 1 < count;\n  if (hasMinPoint || hasMaxPoint) {\n    var missingValues = seriesMissingValues(series);\n    var minPoint, maxPoint;\n    if (missingValues !== INTERPOLATE) {\n      if (hasMinPoint) {\n        minPoint = getter(min - 1);\n      }\n      if (hasMaxPoint) {\n        maxPoint = getter(max + 1);\n      }\n    } else {\n      var outPoint, pointHasValue;\n      if (hasMinPoint) {\n        outPoint = getter(min - 1);\n        pointHasValue = hasValue(series, outPoint.item);\n        if (!pointHasValue) {\n          minPoint = findNext({\n            start: min,\n            dir: -1,\n            min: 0,\n            max: count - 1,\n            getter: getter,\n            hasItem: hasItem,\n            series: series\n          });\n        } else {\n          minPoint = outPoint;\n        }\n      }\n      if (hasMaxPoint) {\n        outPoint = getter(max + 1);\n        pointHasValue = hasValue(series, outPoint.item);\n        if (!pointHasValue) {\n          maxPoint = findNext({\n            start: max,\n            dir: 1,\n            min: 0,\n            max: count - 1,\n            getter: getter,\n            hasItem: hasItem,\n            series: series\n          });\n        } else {\n          maxPoint = outPoint;\n        }\n      }\n    }\n    if (minPoint) {\n      series._outOfRangeMinPoint = minPoint;\n    }\n    if (maxPoint) {\n      series._outOfRangeMaxPoint = maxPoint;\n    }\n  }\n}","map":{"version":3,"names":["INTERPOLATE","ZERO","convertableToNumber","SeriesBinder","AREA_REGEX","seriesMissingValues","series","missingValues","test","type","stack","hasValue","item","fields","current","bindPoint","valueFields","field","findNext","ref","start","dir","min","max","getter","hasItem","pointHasValue","outPoint","idx","createOutOfRangePoints","range","count","hasMinPoint","hasMaxPoint","minPoint","maxPoint","_outOfRangeMinPoint","_outOfRangeMaxPoint"],"sources":["C:/Users/Павел/Desktop/react humster/my-app/node_modules/@progress/kendo-charts/dist/es/chart/utils/create-out-of-range-points.js"],"sourcesContent":["import { INTERPOLATE, ZERO } from '../constants';\nimport { convertableToNumber } from '../../common';\nimport SeriesBinder from '../series-binder';\n\nvar AREA_REGEX = /area/i;\n\nfunction seriesMissingValues(series) {\n    if (series.missingValues) {\n        return series.missingValues;\n    }\n\n    return AREA_REGEX.test(series.type) || series.stack ? ZERO : INTERPOLATE;\n}\n\nfunction hasValue(series, item) {\n    var fields = SeriesBinder.current.bindPoint(series, null, item);\n    var valueFields = fields.valueFields;\n\n    for (var field in valueFields) {\n        if (convertableToNumber(valueFields[field])) {\n            return true;\n        }\n    }\n}\n\nfunction findNext(ref) {\n    var start = ref.start;\n    var dir = ref.dir;\n    var min = ref.min;\n    var max = ref.max;\n    var getter = ref.getter;\n    var hasItem = ref.hasItem;\n    var series = ref.series;\n\n    var pointHasValue, outPoint;\n    var idx = start;\n    do {\n        idx += dir;\n        //aggregating and binding the item takes too much time for large number of categories\n        //will assume that if the aggregation does not create value for a missing item for one it will not create for others\n        if (hasItem(idx)) {\n            outPoint = getter(idx);\n            pointHasValue = hasValue(series, outPoint.item);\n        }\n    } while (min <= idx && idx <= max && !pointHasValue);\n\n    if (pointHasValue) {\n        return outPoint;\n    }\n}\n\nexport default function createOutOfRangePoints(series, range, count, getter, hasItem) {\n    var min = range.min;\n    var max = range.max;\n    var hasMinPoint = min > 0 && min < count;\n    var hasMaxPoint = max + 1 < count;\n\n    if (hasMinPoint || hasMaxPoint) {\n        var missingValues = seriesMissingValues(series);\n        var minPoint, maxPoint;\n        if (missingValues !== INTERPOLATE) {\n            if (hasMinPoint) {\n                minPoint = getter(min - 1);\n            }\n\n            if (hasMaxPoint) {\n                maxPoint = getter(max + 1);\n            }\n        } else {\n            var outPoint, pointHasValue;\n            if (hasMinPoint) {\n                outPoint = getter(min - 1);\n                pointHasValue = hasValue(series, outPoint.item);\n                if (!pointHasValue) {\n                    minPoint = findNext({\n                        start: min,\n                        dir: -1,\n                        min: 0,\n                        max: count - 1,\n                        getter: getter,\n                        hasItem: hasItem,\n                        series: series\n                    });\n                } else {\n                    minPoint = outPoint;\n                }\n            }\n\n            if (hasMaxPoint) {\n                outPoint = getter(max + 1);\n                pointHasValue = hasValue(series, outPoint.item);\n                if (!pointHasValue) {\n                    maxPoint = findNext({\n                        start: max,\n                        dir: 1,\n                        min: 0,\n                        max: count - 1,\n                        getter: getter,\n                        hasItem: hasItem,\n                        series: series\n                    });\n                } else {\n                    maxPoint = outPoint;\n                }\n            }\n        }\n\n        if (minPoint) {\n            series._outOfRangeMinPoint = minPoint;\n        }\n\n        if (maxPoint) {\n            series._outOfRangeMaxPoint = maxPoint;\n        }\n    }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}