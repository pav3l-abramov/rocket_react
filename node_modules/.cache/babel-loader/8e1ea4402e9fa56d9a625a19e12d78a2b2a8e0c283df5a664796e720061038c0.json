{"ast":null,"code":"import BarChart from '../bar-chart/bar-chart';\nimport SeriesBinder from '../series-binder';\nimport WaterfallSegment from './waterfall-segment';\nimport categoriesCount from '../utils/categories-count';\nimport { isNumber } from '../../common';\nvar WaterfallChart = function (BarChart) {\n  function WaterfallChart() {\n    BarChart.apply(this, arguments);\n  }\n  if (BarChart) WaterfallChart.__proto__ = BarChart;\n  WaterfallChart.prototype = Object.create(BarChart && BarChart.prototype);\n  WaterfallChart.prototype.constructor = WaterfallChart;\n  WaterfallChart.prototype.render = function render() {\n    BarChart.prototype.render.call(this);\n    this.createSegments();\n  };\n  WaterfallChart.prototype.traverseDataPoints = function traverseDataPoints(callback) {\n    var this$1 = this;\n    var series = this.options.series;\n    var totalCategories = categoriesCount(series);\n    var isVertical = !this.options.invertAxes;\n    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {\n      var currentSeries = series[seriesIx];\n      var total = 0;\n      var runningTotal = 0;\n      for (var categoryIx = 0; categoryIx < totalCategories; categoryIx++) {\n        var data = SeriesBinder.current.bindPoint(currentSeries, categoryIx);\n        var value = data.valueFields.value;\n        var summary = data.fields.summary;\n        var from = total;\n        var to = void 0;\n        if (summary) {\n          if (summary.toLowerCase() === \"total\") {\n            data.valueFields.value = total;\n            from = 0;\n            to = total;\n          } else {\n            data.valueFields.value = runningTotal;\n            to = from - runningTotal;\n            runningTotal = 0;\n          }\n        } else if (isNumber(value)) {\n          runningTotal += value;\n          total += value;\n          to = total;\n        }\n        callback(data, {\n          category: this$1.categoryAxis.categoryAt(categoryIx),\n          categoryIx: categoryIx,\n          series: currentSeries,\n          seriesIx: seriesIx,\n          total: total,\n          runningTotal: runningTotal,\n          from: from,\n          to: to,\n          isVertical: isVertical\n        });\n      }\n    }\n  };\n  WaterfallChart.prototype.updateRange = function updateRange(value, fields) {\n    BarChart.prototype.updateRange.call(this, {\n      value: fields.to\n    }, fields);\n  };\n  WaterfallChart.prototype.aboveAxis = function aboveAxis(point) {\n    return point.value >= 0;\n  };\n  WaterfallChart.prototype.plotRange = function plotRange(point) {\n    return [point.from, point.to];\n  };\n  WaterfallChart.prototype.createSegments = function createSegments() {\n    var this$1 = this;\n    var series = this.options.series;\n    var seriesPoints = this.seriesPoints;\n    var segments = this.segments = [];\n    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {\n      var currentSeries = series[seriesIx];\n      var points = seriesPoints[seriesIx];\n      if (points) {\n        var prevPoint = void 0;\n        for (var pointIx = 0; pointIx < points.length; pointIx++) {\n          var point = points[pointIx];\n          if (point && prevPoint) {\n            var segment = new WaterfallSegment(prevPoint, point, currentSeries);\n            segments.push(segment);\n            this$1.append(segment);\n          }\n          prevPoint = point;\n        }\n      }\n    }\n  };\n  return WaterfallChart;\n}(BarChart);\nexport default WaterfallChart;","map":{"version":3,"names":["BarChart","SeriesBinder","WaterfallSegment","categoriesCount","isNumber","WaterfallChart","apply","arguments","__proto__","prototype","Object","create","constructor","render","call","createSegments","traverseDataPoints","callback","this$1","series","options","totalCategories","isVertical","invertAxes","seriesIx","length","currentSeries","total","runningTotal","categoryIx","data","current","bindPoint","value","valueFields","summary","fields","from","to","toLowerCase","category","categoryAxis","categoryAt","updateRange","aboveAxis","point","plotRange","seriesPoints","segments","points","prevPoint","pointIx","segment","push","append"],"sources":["C:/Users/Павел/Desktop/react humster/my-app/node_modules/@progress/kendo-charts/dist/es/chart/waterfall-chart/waterfall-chart.js"],"sourcesContent":["import BarChart from '../bar-chart/bar-chart';\nimport SeriesBinder from '../series-binder';\nimport WaterfallSegment from './waterfall-segment';\n\nimport categoriesCount from '../utils/categories-count';\n\nimport { isNumber } from '../../common';\n\nvar WaterfallChart = (function (BarChart) {\n    function WaterfallChart () {\n        BarChart.apply(this, arguments);\n    }\n\n    if ( BarChart ) WaterfallChart.__proto__ = BarChart;\n    WaterfallChart.prototype = Object.create( BarChart && BarChart.prototype );\n    WaterfallChart.prototype.constructor = WaterfallChart;\n\n    WaterfallChart.prototype.render = function render () {\n        BarChart.prototype.render.call(this);\n        this.createSegments();\n    };\n\n    WaterfallChart.prototype.traverseDataPoints = function traverseDataPoints (callback) {\n        var this$1 = this;\n\n        var series = this.options.series;\n        var totalCategories = categoriesCount(series);\n        var isVertical = !this.options.invertAxes;\n\n        for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {\n            var currentSeries = series[seriesIx];\n            var total = 0;\n            var runningTotal = 0;\n\n            for (var categoryIx = 0; categoryIx < totalCategories; categoryIx++) {\n                var data = SeriesBinder.current.bindPoint(currentSeries, categoryIx);\n                var value = data.valueFields.value;\n                var summary = data.fields.summary;\n                var from = total;\n                var to = (void 0);\n\n                if (summary) {\n                    if (summary.toLowerCase() === \"total\") {\n                        data.valueFields.value = total;\n                        from = 0;\n                        to = total;\n                    } else {\n                        data.valueFields.value = runningTotal;\n                        to = from - runningTotal;\n                        runningTotal = 0;\n                    }\n                } else if (isNumber(value)) {\n                    runningTotal += value;\n                    total += value;\n                    to = total;\n                }\n\n                callback(data, {\n                    category: this$1.categoryAxis.categoryAt(categoryIx),\n                    categoryIx: categoryIx,\n                    series: currentSeries,\n                    seriesIx: seriesIx,\n                    total: total,\n                    runningTotal: runningTotal,\n                    from: from,\n                    to: to,\n                    isVertical: isVertical\n                });\n            }\n        }\n    };\n\n    WaterfallChart.prototype.updateRange = function updateRange (value, fields) {\n        BarChart.prototype.updateRange.call(this, { value: fields.to }, fields);\n    };\n\n    WaterfallChart.prototype.aboveAxis = function aboveAxis (point) {\n        return point.value >= 0;\n    };\n\n    WaterfallChart.prototype.plotRange = function plotRange (point) {\n        return [ point.from, point.to ];\n    };\n\n    WaterfallChart.prototype.createSegments = function createSegments () {\n        var this$1 = this;\n\n        var series = this.options.series;\n        var seriesPoints = this.seriesPoints;\n        var segments = this.segments = [];\n\n        for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {\n            var currentSeries = series[seriesIx];\n            var points = seriesPoints[seriesIx];\n\n            if (points) {\n                var prevPoint = (void 0);\n                for (var pointIx = 0; pointIx < points.length; pointIx++) {\n                    var point = points[pointIx];\n\n                    if (point && prevPoint) {\n                        var segment = new WaterfallSegment(prevPoint, point, currentSeries);\n                        segments.push(segment);\n                        this$1.append(segment);\n                    }\n\n                    prevPoint = point;\n                }\n            }\n        }\n    };\n\n    return WaterfallChart;\n}(BarChart));\n\nexport default WaterfallChart;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}