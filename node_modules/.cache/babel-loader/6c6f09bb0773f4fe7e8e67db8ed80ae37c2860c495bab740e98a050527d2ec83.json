{"ast":null,"code":"import { drawing, Color } from '@progress/kendo-drawing';\nimport { interpolateValue, setDefaultOptions, round, limitValue } from '../../common';\nimport { ANGULAR_SPEED, LINEAR, RADIAL_RANGE_POINTER } from '../constants';\nvar MAX_DURATION = 800;\nvar RangePointerAnimation = function (superclass) {\n  function RangePointerAnimation(element, options) {\n    superclass.call(this, element, options);\n    var animationOptions = this.options;\n    var duration = Math.abs(animationOptions.newAngle - animationOptions.oldAngle) / animationOptions.duration * 1000;\n    animationOptions.duration = limitValue(duration, ANGULAR_SPEED, MAX_DURATION);\n    var startColor = element.elements.options.get(\"stroke.color\");\n    var color = element.currentColor();\n    if (startColor !== color) {\n      this.startColor = new Color(startColor);\n      this.color = new Color(color);\n    }\n  }\n  if (superclass) RangePointerAnimation.__proto__ = superclass;\n  RangePointerAnimation.prototype = Object.create(superclass && superclass.prototype);\n  RangePointerAnimation.prototype.constructor = RangePointerAnimation;\n  RangePointerAnimation.prototype.step = function step(pos) {\n    var ref = this;\n    var options = ref.options;\n    var startColor = ref.startColor;\n    var color = ref.color;\n    var angle = interpolateValue(options.oldAngle, options.newAngle, pos);\n    this.element.angle(angle);\n    if (color) {\n      var r = round(interpolateValue(startColor.r, color.r, pos));\n      var g = round(interpolateValue(startColor.g, color.g, pos));\n      var b = round(interpolateValue(startColor.b, color.b, pos));\n      this.element.stroke(new Color(r, g, b).toHex());\n    }\n  };\n  return RangePointerAnimation;\n}(drawing.Animation);\nsetDefaultOptions(RangePointerAnimation, {\n  easing: LINEAR,\n  duration: ANGULAR_SPEED\n});\ndrawing.AnimationFactory.current.register(RADIAL_RANGE_POINTER, RangePointerAnimation);\nexport default RangePointerAnimation;","map":{"version":3,"names":["drawing","Color","interpolateValue","setDefaultOptions","round","limitValue","ANGULAR_SPEED","LINEAR","RADIAL_RANGE_POINTER","MAX_DURATION","RangePointerAnimation","superclass","element","options","call","animationOptions","duration","Math","abs","newAngle","oldAngle","startColor","elements","get","color","currentColor","__proto__","prototype","Object","create","constructor","step","pos","ref","angle","r","g","b","stroke","toHex","Animation","easing","AnimationFactory","current","register"],"sources":["C:/Users/Павел/Desktop/react humster/my-app/node_modules/@progress/kendo-charts/dist/es/gauges/arc/range-pointer-animation.js"],"sourcesContent":["import { drawing, Color } from '@progress/kendo-drawing';\nimport { interpolateValue, setDefaultOptions, round, limitValue } from '../../common';\nimport { ANGULAR_SPEED, LINEAR, RADIAL_RANGE_POINTER } from '../constants';\n\nvar MAX_DURATION = 800;\n\nvar RangePointerAnimation = (function (superclass) {\n    function RangePointerAnimation(element, options) {\n        superclass.call(this, element, options);\n\n        var animationOptions = this.options;\n        var duration = (Math.abs(animationOptions.newAngle - animationOptions.oldAngle) / animationOptions.duration) * 1000;\n        animationOptions.duration = limitValue(duration, ANGULAR_SPEED, MAX_DURATION);\n\n        var startColor = element.elements.options.get(\"stroke.color\");\n        var color = element.currentColor();\n        if (startColor !== color) {\n            this.startColor = new Color(startColor);\n            this.color = new Color(color);\n        }\n    }\n\n    if ( superclass ) RangePointerAnimation.__proto__ = superclass;\n    RangePointerAnimation.prototype = Object.create( superclass && superclass.prototype );\n    RangePointerAnimation.prototype.constructor = RangePointerAnimation;\n\n    RangePointerAnimation.prototype.step = function step (pos) {\n        var ref = this;\n        var options = ref.options;\n        var startColor = ref.startColor;\n        var color = ref.color;\n        var angle = interpolateValue(options.oldAngle, options.newAngle, pos);\n        this.element.angle(angle);\n\n        if (color) {\n            var r = round(interpolateValue(startColor.r, color.r, pos));\n            var g = round(interpolateValue(startColor.g, color.g, pos));\n            var b = round(interpolateValue(startColor.b, color.b, pos));\n\n            this.element.stroke(new Color(r, g, b).toHex());\n        }\n    };\n\n    return RangePointerAnimation;\n}(drawing.Animation));\n\nsetDefaultOptions(RangePointerAnimation, {\n    easing: LINEAR,\n    duration: ANGULAR_SPEED\n});\n\ndrawing.AnimationFactory.current.register(RADIAL_RANGE_POINTER, RangePointerAnimation);\n\nexport default RangePointerAnimation;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}