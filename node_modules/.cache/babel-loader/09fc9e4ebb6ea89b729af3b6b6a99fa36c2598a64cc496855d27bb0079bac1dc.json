{"ast":null,"code":"import { geometry as geom } from '@progress/kendo-drawing';\nimport { X, Y } from '../common/constants';\nimport { Class, last, round } from '../common';\nvar WEIGHT = 0.333;\nvar EXTREMUM_ALLOWED_DEVIATION = 0.01;\nvar CurveProcessor = function (Class) {\n  function CurveProcessor(closed) {\n    Class.call(this);\n    this.closed = closed;\n  }\n  if (Class) CurveProcessor.__proto__ = Class;\n  CurveProcessor.prototype = Object.create(Class && Class.prototype);\n  CurveProcessor.prototype.constructor = CurveProcessor;\n  CurveProcessor.prototype.process = function process(dataPoints) {\n    var this$1 = this;\n    var points = dataPoints.slice(0);\n    var segments = [];\n    var closed = this.closed;\n    var length = points.length;\n    if (length > 2) {\n      this.removeDuplicates(0, points);\n      length = points.length;\n    }\n    if (length < 2 || length === 2 && points[0].equals(points[1])) {\n      return segments;\n    }\n    var p0 = points[0];\n    var p1 = points[1];\n    var p2 = points[2];\n    segments.push(new geom.Segment(p0));\n    while (p0.equals(points[length - 1])) {\n      closed = true;\n      points.pop();\n      length--;\n    }\n    if (length === 2) {\n      var tangent = this.tangent(p0, p1, X, Y);\n      last(segments).controlOut(this.firstControlPoint(tangent, p0, p1, X, Y));\n      segments.push(new geom.Segment(p1, this.secondControlPoint(tangent, p0, p1, X, Y)));\n      return segments;\n    }\n    var initialControlPoint, lastControlPoint;\n    if (closed) {\n      p0 = points[length - 1];\n      p1 = points[0];\n      p2 = points[1];\n      var controlPoints = this.controlPoints(p0, p1, p2);\n      initialControlPoint = controlPoints[1];\n      lastControlPoint = controlPoints[0];\n    } else {\n      var tangent$1 = this.tangent(p0, p1, X, Y);\n      initialControlPoint = this.firstControlPoint(tangent$1, p0, p1, X, Y);\n    }\n    var cp0 = initialControlPoint;\n    for (var idx = 0; idx <= length - 3; idx++) {\n      this$1.removeDuplicates(idx, points);\n      length = points.length;\n      if (idx + 3 <= length) {\n        p0 = points[idx];\n        p1 = points[idx + 1];\n        p2 = points[idx + 2];\n        var controlPoints$1 = this$1.controlPoints(p0, p1, p2);\n        last(segments).controlOut(cp0);\n        cp0 = controlPoints$1[1];\n        var cp1 = controlPoints$1[0];\n        segments.push(new geom.Segment(p1, cp1));\n      }\n    }\n    if (closed) {\n      p0 = points[length - 2];\n      p1 = points[length - 1];\n      p2 = points[0];\n      var controlPoints$2 = this.controlPoints(p0, p1, p2);\n      last(segments).controlOut(cp0);\n      segments.push(new geom.Segment(p1, controlPoints$2[0]));\n      last(segments).controlOut(controlPoints$2[1]);\n      segments.push(new geom.Segment(p2, lastControlPoint));\n    } else {\n      var tangent$2 = this.tangent(p1, p2, X, Y);\n      last(segments).controlOut(cp0);\n      segments.push(new geom.Segment(p2, this.secondControlPoint(tangent$2, p1, p2, X, Y)));\n    }\n    return segments;\n  };\n  CurveProcessor.prototype.removeDuplicates = function removeDuplicates(idx, points) {\n    while (points[idx + 1] && (points[idx].equals(points[idx + 1]) || points[idx + 1].equals(points[idx + 2]))) {\n      points.splice(idx + 1, 1);\n    }\n  };\n  CurveProcessor.prototype.invertAxis = function invertAxis(p0, p1, p2) {\n    var invertAxis = false;\n    if (p0.x === p1.x) {\n      invertAxis = true;\n    } else if (p1.x === p2.x) {\n      if (p1.y < p2.y && p0.y <= p1.y || p2.y < p1.y && p1.y <= p0.y) {\n        invertAxis = true;\n      }\n    } else {\n      var fn = this.lineFunction(p0, p1);\n      var y2 = this.calculateFunction(fn, p2.x);\n      if (!(p0.y <= p1.y && p2.y <= y2) && !(p1.y <= p0.y && p2.y >= y2)) {\n        invertAxis = true;\n      }\n    }\n    return invertAxis;\n  };\n  CurveProcessor.prototype.isLine = function isLine(p0, p1, p2) {\n    var fn = this.lineFunction(p0, p1);\n    var y2 = this.calculateFunction(fn, p2.x);\n    return p0.x === p1.x && p1.x === p2.x || round(y2, 1) === round(p2.y, 1);\n  };\n  CurveProcessor.prototype.lineFunction = function lineFunction(p1, p2) {\n    var a = (p2.y - p1.y) / (p2.x - p1.x);\n    var b = p1.y - a * p1.x;\n    return [b, a];\n  };\n  CurveProcessor.prototype.controlPoints = function controlPoints(p0, p1, p2) {\n    var xField = X;\n    var yField = Y;\n    var restrict = false;\n    var switchOrientation = false;\n    var tangent;\n    if (this.isLine(p0, p1, p2)) {\n      tangent = this.tangent(p0, p1, X, Y);\n    } else {\n      var monotonic = {\n        x: this.isMonotonicByField(p0, p1, p2, X),\n        y: this.isMonotonicByField(p0, p1, p2, Y)\n      };\n      if (monotonic.x && monotonic.y) {\n        tangent = this.tangent(p0, p2, X, Y);\n        restrict = true;\n      } else {\n        if (this.invertAxis(p0, p1, p2)) {\n          xField = Y;\n          yField = X;\n        }\n        if (monotonic[xField]) {\n          tangent = 0;\n        } else {\n          var sign;\n          if (p2[yField] < p0[yField] && p0[yField] <= p1[yField] || p0[yField] < p2[yField] && p1[yField] <= p0[yField]) {\n            sign = numberSign((p2[yField] - p0[yField]) * (p1[xField] - p0[xField]));\n          } else {\n            sign = -numberSign((p2[xField] - p0[xField]) * (p1[yField] - p0[yField]));\n          }\n          tangent = EXTREMUM_ALLOWED_DEVIATION * sign;\n          switchOrientation = true;\n        }\n      }\n    }\n    var secondControlPoint = this.secondControlPoint(tangent, p0, p1, xField, yField);\n    if (switchOrientation) {\n      var oldXField = xField;\n      xField = yField;\n      yField = oldXField;\n    }\n    var firstControlPoint = this.firstControlPoint(tangent, p1, p2, xField, yField);\n    if (restrict) {\n      this.restrictControlPoint(p0, p1, secondControlPoint, tangent);\n      this.restrictControlPoint(p1, p2, firstControlPoint, tangent);\n    }\n    return [secondControlPoint, firstControlPoint];\n  };\n  CurveProcessor.prototype.restrictControlPoint = function restrictControlPoint(p1, p2, cp, tangent) {\n    if (p1.y < p2.y) {\n      if (p2.y < cp.y) {\n        cp.x = p1.x + (p2.y - p1.y) / tangent;\n        cp.y = p2.y;\n      } else if (cp.y < p1.y) {\n        cp.x = p2.x - (p2.y - p1.y) / tangent;\n        cp.y = p1.y;\n      }\n    } else {\n      if (cp.y < p2.y) {\n        cp.x = p1.x - (p1.y - p2.y) / tangent;\n        cp.y = p2.y;\n      } else if (p1.y < cp.y) {\n        cp.x = p2.x + (p1.y - p2.y) / tangent;\n        cp.y = p1.y;\n      }\n    }\n  };\n  CurveProcessor.prototype.tangent = function tangent(p0, p1, xField, yField) {\n    var x = p1[xField] - p0[xField];\n    var y = p1[yField] - p0[yField];\n    var tangent;\n    if (x === 0) {\n      tangent = 0;\n    } else {\n      tangent = y / x;\n    }\n    return tangent;\n  };\n  CurveProcessor.prototype.isMonotonicByField = function isMonotonicByField(p0, p1, p2, field) {\n    return p2[field] > p1[field] && p1[field] > p0[field] || p2[field] < p1[field] && p1[field] < p0[field];\n  };\n  CurveProcessor.prototype.firstControlPoint = function firstControlPoint(tangent, p0, p3, xField, yField) {\n    var t1 = p0[xField];\n    var t2 = p3[xField];\n    var distance = (t2 - t1) * WEIGHT;\n    return this.point(t1 + distance, p0[yField] + distance * tangent, xField, yField);\n  };\n  CurveProcessor.prototype.secondControlPoint = function secondControlPoint(tangent, p0, p3, xField, yField) {\n    var t1 = p0[xField];\n    var t2 = p3[xField];\n    var distance = (t2 - t1) * WEIGHT;\n    return this.point(t2 - distance, p3[yField] - distance * tangent, xField, yField);\n  };\n  CurveProcessor.prototype.point = function point(xValue, yValue, xField, yField) {\n    var controlPoint = new geom.Point();\n    controlPoint[xField] = xValue;\n    controlPoint[yField] = yValue;\n    return controlPoint;\n  };\n  CurveProcessor.prototype.calculateFunction = function calculateFunction(fn, x) {\n    var length = fn.length;\n    var result = 0;\n    for (var i = 0; i < length; i++) {\n      result += Math.pow(x, i) * fn[i];\n    }\n    return result;\n  };\n  return CurveProcessor;\n}(Class);\nfunction numberSign(value) {\n  return value <= 0 ? -1 : 1;\n}\nexport default CurveProcessor;","map":{"version":3,"names":["geometry","geom","X","Y","Class","last","round","WEIGHT","EXTREMUM_ALLOWED_DEVIATION","CurveProcessor","closed","call","__proto__","prototype","Object","create","constructor","process","dataPoints","this$1","points","slice","segments","length","removeDuplicates","equals","p0","p1","p2","push","Segment","pop","tangent","controlOut","firstControlPoint","secondControlPoint","initialControlPoint","lastControlPoint","controlPoints","tangent$1","cp0","idx","controlPoints$1","cp1","controlPoints$2","tangent$2","splice","invertAxis","x","y","fn","lineFunction","y2","calculateFunction","isLine","a","b","xField","yField","restrict","switchOrientation","monotonic","isMonotonicByField","sign","numberSign","oldXField","restrictControlPoint","cp","field","p3","t1","t2","distance","point","xValue","yValue","controlPoint","Point","result","i","Math","pow","value"],"sources":["C:/Users/Павел/Desktop/react humster/my-app/node_modules/@progress/kendo-charts/dist/es/core/curve-processor.js"],"sourcesContent":["import { geometry as geom } from '@progress/kendo-drawing';\n\nimport { X, Y } from '../common/constants';\nimport { Class, last, round } from '../common';\n\nvar WEIGHT = 0.333;\nvar EXTREMUM_ALLOWED_DEVIATION = 0.01;\n\nvar CurveProcessor = (function (Class) {\n    function CurveProcessor(closed) {\n        Class.call(this);\n\n        this.closed = closed;\n    }\n\n    if ( Class ) CurveProcessor.__proto__ = Class;\n    CurveProcessor.prototype = Object.create( Class && Class.prototype );\n    CurveProcessor.prototype.constructor = CurveProcessor;\n\n    CurveProcessor.prototype.process = function process (dataPoints) {\n        var this$1 = this;\n\n        var points = dataPoints.slice(0);\n        var segments = [];\n        var closed = this.closed;\n        var length = points.length;\n\n        if (length > 2) {\n            this.removeDuplicates(0, points);\n            length = points.length;\n        }\n\n        if (length < 2 || (length === 2 && points[0].equals(points[1]))) {\n            return segments;\n        }\n\n        var p0 = points[0];\n        var p1 = points[1];\n        var p2 = points[2];\n\n        segments.push(new geom.Segment(p0));\n\n        while (p0.equals(points[length - 1])) {\n            closed = true;\n            points.pop();\n            length--;\n        }\n\n        if (length === 2) {\n            var tangent = this.tangent(p0,p1, X, Y);\n\n            last(segments).controlOut(\n                this.firstControlPoint(tangent, p0, p1, X, Y)\n            );\n\n            segments.push(new geom.Segment(\n                p1,\n                this.secondControlPoint(tangent, p0, p1, X, Y)\n            ));\n\n            return segments;\n        }\n\n        var initialControlPoint, lastControlPoint;\n\n        if (closed) {\n            p0 = points[length - 1]; p1 = points[0]; p2 = points[1];\n            var controlPoints = this.controlPoints(p0, p1, p2);\n            initialControlPoint = controlPoints[1];\n            lastControlPoint = controlPoints[0];\n        } else {\n            var tangent$1 = this.tangent(p0, p1, X,Y);\n            initialControlPoint = this.firstControlPoint(tangent$1, p0, p1, X, Y);\n        }\n\n        var cp0 = initialControlPoint;\n        for (var idx = 0; idx <= length - 3; idx++) {\n            this$1.removeDuplicates(idx, points);\n            length = points.length;\n            if (idx + 3 <= length) {\n                p0 = points[idx]; p1 = points[idx + 1]; p2 = points[idx + 2];\n                var controlPoints$1 = this$1.controlPoints(p0,p1,p2);\n\n                last(segments).controlOut(cp0);\n                cp0 = controlPoints$1[1];\n\n                var cp1 = controlPoints$1[0];\n                segments.push(new geom.Segment(p1, cp1));\n            }\n        }\n\n        if (closed) {\n            p0 = points[length - 2]; p1 = points[length - 1]; p2 = points[0];\n            var controlPoints$2 = this.controlPoints(p0, p1, p2);\n\n            last(segments).controlOut(cp0);\n            segments.push(new geom.Segment(\n                p1,\n                controlPoints$2[0]\n            ));\n\n            last(segments).controlOut(controlPoints$2[1]);\n            segments.push(new geom.Segment(\n                p2,\n                lastControlPoint\n            ));\n        } else {\n            var tangent$2 = this.tangent(p1, p2, X, Y);\n\n            last(segments).controlOut(cp0);\n            segments.push(new geom.Segment(\n                p2,\n                this.secondControlPoint(tangent$2, p1, p2, X, Y)\n            ));\n        }\n\n        return segments;\n    };\n\n    CurveProcessor.prototype.removeDuplicates = function removeDuplicates (idx, points) {\n        while (points[idx + 1] && (points[idx].equals(points[idx + 1]) || points[idx + 1].equals(points[idx + 2]))) {\n            points.splice(idx + 1, 1);\n        }\n    };\n\n    CurveProcessor.prototype.invertAxis = function invertAxis (p0, p1, p2) {\n        var invertAxis = false;\n\n        if (p0.x === p1.x) {\n            invertAxis = true;\n        } else if (p1.x === p2.x) {\n            if ((p1.y < p2.y && p0.y <= p1.y) || (p2.y < p1.y && p1.y <= p0.y)) {\n                invertAxis = true;\n            }\n        } else {\n            var fn = this.lineFunction(p0,p1);\n            var y2 = this.calculateFunction(fn, p2.x);\n            if (!(p0.y <= p1.y && p2.y <= y2) &&\n                !(p1.y <= p0.y && p2.y >= y2)) {\n                invertAxis = true;\n            }\n        }\n\n        return invertAxis;\n    };\n\n    CurveProcessor.prototype.isLine = function isLine (p0, p1, p2) {\n        var fn = this.lineFunction(p0, p1);\n        var y2 = this.calculateFunction(fn, p2.x);\n\n        return (p0.x === p1.x && p1.x === p2.x) || round(y2, 1) === round(p2.y, 1);\n    };\n\n    CurveProcessor.prototype.lineFunction = function lineFunction (p1, p2) {\n        var a = (p2.y - p1.y) / (p2.x - p1.x);\n        var b = p1.y - a * p1.x;\n\n        return [ b, a ];\n    };\n\n    CurveProcessor.prototype.controlPoints = function controlPoints (p0, p1, p2) {\n        var xField = X;\n        var yField = Y;\n        var restrict = false;\n        var switchOrientation = false;\n        var tangent;\n\n        if (this.isLine(p0, p1, p2)) {\n            tangent = this.tangent(p0, p1, X, Y);\n        } else {\n            var monotonic = {\n                x: this.isMonotonicByField(p0, p1, p2, X),\n                y: this.isMonotonicByField(p0, p1, p2, Y)\n            };\n\n            if (monotonic.x && monotonic.y) {\n                tangent = this.tangent(p0, p2, X, Y);\n                restrict = true;\n            } else {\n                if (this.invertAxis(p0, p1, p2)) {\n                    xField = Y;\n                    yField = X;\n                }\n\n                if (monotonic[xField]) {\n                    tangent = 0;\n                } else {\n                    var sign;\n                    if ((p2[yField] < p0[yField] && p0[yField] <= p1[yField]) ||\n                        (p0[yField] < p2[yField] && p1[yField] <= p0[yField])) {\n                        sign = numberSign((p2[yField] - p0[yField]) * (p1[xField] - p0[xField]));\n                    } else {\n                        sign = -numberSign((p2[xField] - p0[xField]) * (p1[yField] - p0[yField]));\n                    }\n\n                    tangent = EXTREMUM_ALLOWED_DEVIATION * sign;\n                    switchOrientation = true;\n                }\n            }\n        }\n\n        var secondControlPoint = this.secondControlPoint(tangent, p0, p1, xField, yField);\n\n        if (switchOrientation) {\n            var oldXField = xField;\n            xField = yField;\n            yField = oldXField;\n        }\n\n        var firstControlPoint = this.firstControlPoint(tangent, p1, p2, xField, yField);\n\n        if (restrict) {\n            this.restrictControlPoint(p0, p1, secondControlPoint, tangent);\n            this.restrictControlPoint(p1, p2, firstControlPoint, tangent);\n        }\n\n        return [ secondControlPoint, firstControlPoint ];\n    };\n\n    CurveProcessor.prototype.restrictControlPoint = function restrictControlPoint (p1, p2, cp, tangent) {\n        if (p1.y < p2.y) {\n            if (p2.y < cp.y) {\n                cp.x = p1.x + (p2.y - p1.y) / tangent;\n                cp.y = p2.y;\n            } else if (cp.y < p1.y) {\n                cp.x = p2.x - (p2.y - p1.y) / tangent;\n                cp.y = p1.y;\n            }\n        } else {\n            if (cp.y < p2.y) {\n                cp.x = p1.x - (p1.y - p2.y) / tangent;\n                cp.y = p2.y;\n            } else if (p1.y < cp.y) {\n                cp.x = p2.x + (p1.y - p2.y) / tangent;\n                cp.y = p1.y;\n            }\n        }\n    };\n\n    CurveProcessor.prototype.tangent = function tangent (p0, p1, xField, yField) {\n        var x = p1[xField] - p0[xField];\n        var y = p1[yField] - p0[yField];\n        var tangent;\n\n        if (x === 0) {\n            tangent = 0;\n        } else {\n            tangent = y / x;\n        }\n\n        return tangent;\n    };\n\n    CurveProcessor.prototype.isMonotonicByField = function isMonotonicByField (p0, p1, p2, field) {\n        return (p2[field] > p1[field] && p1[field] > p0[field]) ||\n                    (p2[field] < p1[field] && p1[field] < p0[field]);\n    };\n\n    CurveProcessor.prototype.firstControlPoint = function firstControlPoint (tangent, p0, p3, xField, yField) {\n        var t1 = p0[xField];\n        var t2 = p3[xField];\n        var distance = (t2 - t1) * WEIGHT;\n\n        return this.point(t1 + distance, p0[yField] + distance * tangent, xField, yField);\n    };\n\n    CurveProcessor.prototype.secondControlPoint = function secondControlPoint (tangent, p0, p3, xField, yField) {\n        var t1 = p0[xField];\n        var t2 = p3[xField];\n        var distance = (t2 - t1) * WEIGHT;\n\n        return this.point(t2 - distance, p3[yField] - distance * tangent, xField, yField);\n    };\n\n    CurveProcessor.prototype.point = function point (xValue, yValue, xField, yField) {\n        var controlPoint = new geom.Point();\n        controlPoint[xField] = xValue;\n        controlPoint[yField] = yValue;\n\n        return controlPoint;\n    };\n\n    CurveProcessor.prototype.calculateFunction = function calculateFunction (fn, x) {\n        var length = fn.length;\n        var result = 0;\n\n        for (var i = 0; i < length; i++) {\n            result += Math.pow(x,i) * fn[i];\n        }\n        return result;\n    };\n\n    return CurveProcessor;\n}(Class));\n\nfunction numberSign(value) {\n    return value <= 0 ? -1 : 1;\n}\n\nexport default CurveProcessor;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}